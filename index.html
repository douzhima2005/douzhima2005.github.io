<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>COC7 æˆ˜æ–—æ§åˆ¶å° v4.3.6c</title>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Noto+Sans+SC:wght@400;700;900&display=swap" rel="stylesheet">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Tailwind é…ç½® -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['"Noto Sans SC"', 'sans-serif'],
                        mono: ['"JetBrains Mono"', 'monospace'],
                    },
                    colors: {
                        canvas: '#f3f4f6',
                        main: '#111111',
                        player: '#2563eb',
                        enemy: '#dc2626',
                        pulp: '#9333ea',
                    },
                    boxShadow: {
                        'hard': '8px 8px 0px 0px #000000',
                        'hard-sm': '4px 4px 0px 0px #000000',
                        'hard-hover': '2px 2px 0px 0px #000000',
                        'pulp': '4px 4px 0px 0px #9333ea',
                    }
                }
            }
        }
    </script>
    
    <style>
        /* =====================================================
           RATIONAL ARCHIVE - ç†æ€§æ¡£æ¡ˆè®¾è®¡ç³»ç»Ÿ v4.2
           Neo-Brutalism + å³æ—¶ä»ªè¡¨ç›˜ (Instant Dashboard)
           ===================================================== */
        
        /* å…¨å±€é‡ç½® */
        * { 
            box-sizing: border-box; 
            border-radius: 0 !important;
            -webkit-tap-highlight-color: transparent;
        }
        
        html, body { 
            height: 100vh;
            height: 100dvh;
            width: 100vw;
            margin: 0; 
            padding: 0;
            overflow: hidden; 
            position: fixed;
            overscroll-behavior: none;
            font-family: "Noto Sans SC", -apple-system, sans-serif;
            color: #111;
            background-color: #f3f4f6;
        }

        /* å­—ä½“ç­–ç•¥ï¼šä¸­æ–‡åŠ å®½ï¼Œæ•°å­—ç´§å‡‘ */
        .tracking-cjk { letter-spacing: 0.05em; }
        .font-num { font-family: 'JetBrains Mono', monospace; letter-spacing: -0.5px; }

        #root {
            height: 100%;
            width: 100%;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .main-layout {
            height: 100%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        header { flex: 0 0 56px; }

        main {
            flex: 1;
            overflow: hidden;
            position: relative;
            height: calc(100% - 56px);
            display: flex;
            flex-direction: column;
            min-height: 0; 
        }

        /* =====================================================
           ä¸‰æ å¸ƒå±€ - æˆ˜æœ¯æŒ‡æŒ¥å°
           ===================================================== */
        .combat-grid {
            display: grid;
            grid-template-columns: 280px 1fr 320px;
            height: 100%;
            overflow: hidden;
            background: #f3f4f6;
        }

        .panel-scroll {
            height: 100%;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            overscroll-behavior: contain;
        }

        .panel-left {
            background-color: #fff;
            border-right: 1px solid #e5e7eb;
            display: flex;
            flex-direction: column;
        }

        .panel-right {
            background-color: #fff;
            border-left: 1px solid #e5e7eb;
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
        }
        
        .log-scroll-area {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
            -webkit-overflow-scrolling: touch;
            background: #fafafa;
            font-family: "JetBrains Mono", monospace;
        }

        .panel-center {
            position: relative;
            background-color: #f3f4f6;
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
        }

        .action-area {
            flex: 1;
            position: relative;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            min-height: 0;
            padding: 24px;
        }

        /* æ ¸å¿ƒå¡ç‰‡ - ç¡¬é˜´å½±æ•ˆæœ */
        .centered-card {
            width: 90%;
            max-width: 480px;
            max-height: 95%;
            overflow-y: auto;
            background: #fff;
            border: 2px solid #000;
            z-index: 10;
            margin-bottom: 20px;
            box-shadow: 8px 8px 0px 0px #000;
            position: relative;
        }

        /* è®¾ç½®é¡µé¢ */
        .setup-grid {
            display: flex;
            height: 100%;
            overflow: hidden;
            flex-direction: row; 
        }

        .setup-sidebar {
            width: 280px;
            background-color: #fff;
            flex-shrink: 0;
            height: 100%;
            overflow-y: auto;
            border-right: 1px solid #e5e7eb;
        }

        .setup-content {
            flex: 1;
            background-color: #f3f4f6;
            height: 100%;
            overflow-y: auto;
            min-height: 0;
        }

        /* KPé¢æ¿ - çº¢è‰²è­¦ç¤ºè¾¹æ¡† */
        .kp-panel {
            position: fixed;
            top: 56px;
            right: 0;
            bottom: 0;
            width: 400px;
            background: #fff;
            border-left: 4px solid #dc2626;
            z-index: 100;
            transform: translateX(100%);
            transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1);
            overflow-y: auto;
            box-shadow: -10px 0 30px rgba(0,0,0,0.2);
        }
        .kp-panel.open { transform: translateX(0); }

        /* =====================================================
           æ»šåŠ¨æ¡ç¾åŒ– - æ–¹æ­£é«˜å¯¹æ¯”
           ===================================================== */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #e5e7eb; border: 1px solid #d1d5db; }
        ::-webkit-scrollbar-thumb:hover { background: #9ca3af; border-color: #6b7280; }

        /* =====================================================
           è§’è‰²å¡ç‰‡ - åè‰²é€‰ä¸­ç³»ç»Ÿ
           ===================================================== */
        .char-card {
            background: #fff;
            color: #000;
            border-bottom: 1px solid #e5e7eb;
            transition: all 0.15s ease;
            cursor: pointer;
            position: relative;
            border-left: 6px solid transparent;
        }
        .char-card:hover { background: #f9fafb; }
        
        .faction-strip-player { border-left-color: #2563eb !important; }
        .faction-strip-enemy { border-left-color: #dc2626 !important; }
        
        /* é€‰ä¸­æ€ - é»‘åº•ç™½å­—åè‰² */
        .char-card.selected {
            background: #111 !important;
            color: #fff !important;
            transform: scale(1.02) translateX(4px);
            z-index: 10;
            box-shadow: 0 4px 12px rgba(0,0,0,0.25);
            border-left-width: 6px !important;
        }
        .char-card.selected * { color: inherit !important; }
        .char-card.selected .sub-text { color: #9ca3af !important; }
        
        /* ç›®æ ‡é€‰ä¸­ */
        .char-card.target-selected {
            background: #fef2f2 !important;
            border-left-color: #dc2626 !important;
        }

        /* =====================================================
           æ•°å­—é”®ç›˜ - ç»ˆç«¯é£æ ¼
           ===================================================== */
        .numpad-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(4px);
            z-index: 9999;
            display: flex;
            align-items: flex-end;
            justify-content: center;
        }
        .numpad-container {
            background: #fff;
            width: 100%;
            max-width: 420px;
            padding: 20px;
            padding-bottom: calc(20px + env(safe-area-inset-bottom, 0));
            border-top: 4px solid #000;
        }
        .numpad-display {
            font-size: 48px;
            font-family: "JetBrains Mono", monospace;
            text-align: center;
            padding: 16px;
            background: #111;
            color: #fff;
            margin-bottom: 20px;
            font-weight: bold;
            letter-spacing: -2px;
        }
        .numpad-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }
        .numpad-btn {
            height: 60px;
            font-size: 22px;
            font-weight: 700;
            font-family: "JetBrains Mono", monospace;
            border: 2px solid #000;
            background: #fff;
            color: #000;
            cursor: pointer;
            transition: all 0.1s;
        }
        .numpad-btn:active { 
            background: #000; 
            color: #fff;
            transform: translate(2px, 2px); 
        }
        .numpad-btn.confirm { 
            background: #000; 
            color: #fff; 
        }

        /* Smart Input */
        .smart-input-container {
            display: flex;
            flex-direction: column;
        }
        .smart-input-label {
            font-size: 10px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #6b7280;
            margin-bottom: 4px;
            font-family: "Noto Sans SC", sans-serif;
        }
        .smart-input-value {
            font-family: "JetBrains Mono", monospace;
            font-size: 15px;
            padding: 10px 12px;
            border: none;
            border-bottom: 2px solid #d1d5db;
            background: #fff;
            cursor: pointer;
            min-height: 42px;
            display: flex;
            align-items: center;
            transition: border-color 0.15s;
        }
        .smart-input-value:hover { border-color: #000; }
        .smart-input-value:focus { border-color: #000; outline: none; }
        .smart-input-value.readonly {
            background: #f9fafb;
            color: #6b7280;
            border-color: #e5e7eb;
            cursor: default;
        }

        /* =====================================================
           Step Dice - é»‘æš—ç»ˆç«¯é£æ ¼
           ===================================================== */
        .step-dice-overlay {
            background: rgba(0,0,0,0.95);
            backdrop-filter: blur(8px);
        }
        .step-dice-container {
            border: 2px solid #333;
        }
        .dice-block {
            background: #000;
            border: 2px solid #fff;
            color: #fff;
            font-family: "JetBrains Mono", monospace;
            box-shadow: 4px 4px 0 #fff;
        }

        /* =====================================================
           ç§»åŠ¨ç«¯é€‚é…
           ===================================================== */
        .mobile-nav { display: none; }

        @media (max-width: 1024px) {
            input, select, textarea { font-size: 16px !important; }

            @media (orientation: portrait) {
                .combat-grid { display: flex; flex-direction: column; width: 100%; }
                .panel-left, .panel-center, .panel-right { display: none; width: 100%; height: 100%; border: none; }
                .panel-mobile-active { display: flex !important; flex-direction: column; }
                .setup-grid { flex-direction: column !important; }
                
                .setup-sidebar {
                    width: 100% !important;
                    height: auto !important;
                    max-height: 35dvh;
                    border-right: none !important;
                    border-bottom: 2px solid #000;
                }
                .setup-content { width: 100% !important; padding-bottom: 100px !important; }

                .mobile-nav { 
                    display: flex !important; 
                    position: fixed;
                    bottom: 0; left: 0; right: 0;
                    height: calc(56px + env(safe-area-inset-bottom, 0));
                    padding-bottom: env(safe-area-inset-bottom, 0);
                    background: #fff;
                    border-top: 2px solid #000;
                    z-index: 9000;
                }

                .centered-card {
                    width: 100%;
                    max-width: none;
                    border: none;
                    box-shadow: none;
                    margin-bottom: 80px;
                    background: #fff;
                }
                
                .action-area { padding: 12px; background: #f3f4f6; }
                
                /* ç§»åŠ¨ç«¯éšè—æ»šåŠ¨æ¡ */
                .panel-scroll::-webkit-scrollbar,
                .log-scroll-area::-webkit-scrollbar { 
                    display: none; 
                    width: 0; 
                    height: 0; 
                }
            }

            @media (orientation: landscape) {
                .combat-grid { display: flex !important; flex-direction: row !important; }
                .panel-left { display: flex !important; width: 220px !important; }
                .panel-center { display: flex !important; flex: 1 !important; }
                .action-area { flex: 1 !important; }
                .panel-right { display: flex !important; width: 260px !important; }
                .mobile-nav { display: none !important; }
                .centered-card { max-height: 90%; margin-bottom: 0; box-shadow: 8px 8px 0 #000; }
            }
        }

        /* =====================================================
           UI ç»„ä»¶ - æ–°é‡å…½æ´¾é£æ ¼
           ===================================================== */
        
        /* æ—¥å¿—æ¡ç›® */
        .log-item {
            padding: 8px 12px;
            border-left: 3px solid #e5e7eb;
            margin-bottom: 6px;
            font-size: 11px;
            line-height: 1.5;
            background: #fff;
            color: #333;
            font-family: "JetBrains Mono", monospace;
        }
        .log-item.damage { border-left-color: #dc2626; background: #fef2f2; }
        .log-item.success { border-left-color: #16a34a; background: #f0fdf4; }
        .log-item.roll { border-left-color: #2563eb; background: #eff6ff; }
        .log-item.system { border-left-color: #000; background: #f3f4f6; font-style: italic; }

        /* æ ‡ç­¾ */
        .label {
            font-size: 10px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            color: #6b7280;
            margin-bottom: 4px;
            font-family: "Noto Sans SC", sans-serif;
        }

        /* æ“ä½œæŒ‰é’® - æ ¸å¿ƒè§†è§‰ */
        .action-btn {
            width: 100%;
            padding: 16px 20px;
            font-weight: 700;
            font-size: 14px;
            border: 2px solid #000;
            background: #fff;
            color: #000;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-family: "Noto Sans SC", sans-serif;
            position: relative;
            overflow: hidden;
        }
        .action-btn:hover { 
            background: #000; 
            color: #fff; 
        }
        .action-btn:active { 
            transform: translate(2px, 2px);
            box-shadow: none;
        }
        
        /* ä¸»æŒ‰é’® - æ‰«å…‰åŠ¨ç”» */
        .action-btn.primary {
            background: #000;
            color: #fff;
            height: 64px;
            font-size: 16px;
            letter-spacing: 1px;
            box-shadow: 4px 4px 0 #000;
        }
        .action-btn.primary:hover { 
            background: #1a1a1a; 
        }
        .action-btn.primary:active {
            transform: translate(4px, 4px);
            box-shadow: none;
        }
        
        /* æ‰«å…‰åŠ¨ç”» */
        @keyframes shine {
            0% { left: -100%; }
            20% { left: 200%; }
            100% { left: 200%; }
        }
        .action-btn.primary::after {
            content: "";
            position: absolute;
            top: 0;
            left: -100%;
            width: 50%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transform: skewX(-20deg);
            animation: shine 3s infinite;
        }
        
        /* =====================================================
           v4.2.0 å³æ—¶ç»“ç®—åŠ¨ç”»
           ===================================================== */
        @keyframes slideUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-slide-up { animation: slideUp 0.3s ease-out; }
        
        @keyframes pulse-success {
            0%, 100% { box-shadow: 8px 8px 0 #000, 0 0 0 0 rgba(22, 163, 74, 0.4); }
            50% { box-shadow: 8px 8px 0 #000, 0 0 0 8px rgba(22, 163, 74, 0); }
        }
        .animate-success { animation: pulse-success 0.6s ease-out; }
        
        @keyframes pulse-fail {
            0%, 100% { box-shadow: 8px 8px 0 #000, 0 0 0 0 rgba(220, 38, 38, 0.4); }
            50% { box-shadow: 8px 8px 0 #000, 0 0 0 8px rgba(220, 38, 38, 0); }
        }
        .animate-fail { animation: pulse-fail 0.6s ease-out; }
        
        /* ç»“ç®—å¡ç‰‡ */
        .resolution-card {
            background: #fff;
            border: 2px solid #000;
            box-shadow: 8px 8px 0 #000;
            padding: 20px;
            margin-bottom: 16px;
        }
        .resolution-card.success { border-color: #16a34a; }
        .resolution-card.fail { border-color: #dc2626; }
        
        /* éª°å­ä¿®æ­£å¼€å…³ */
        .modifier-toggle {
            display: flex;
            gap: 2px;
            padding: 4px;
            background: #f3f4f6;
            border: 2px solid #e5e7eb;
        }
        .modifier-toggle button {
            flex: 1;
            padding: 8px 12px;
            font-size: 12px;
            font-weight: 700;
            border: none;
            background: #fff;
            color: #6b7280;
            cursor: pointer;
            transition: all 0.15s;
        }
        .modifier-toggle button.active {
            background: #111;
            color: #fff;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
        }
        .modifier-toggle button.bonus.active { background: #16a34a; }
        .modifier-toggle button.penalty.active { background: #dc2626; }
        
        .action-btn span.detail {
            font-family: "JetBrains Mono", monospace;
            font-size: 11px;
            opacity: 0.7;
        }
        
        /* çŠ¶æ€æŒ‰é’® */
        .status-btn {
            padding: 10px;
            font-size: 11px;
            font-weight: 700;
            text-align: center;
            border: 2px solid #e5e7eb;
            background: #fff;
            color: #9ca3af;
            cursor: pointer;
            transition: all 0.15s;
            font-family: "Noto Sans SC", sans-serif;
        }
        .status-btn:hover { border-color: #000; color: #000; }
        .status-btn.active-danger { 
            background: #dc2626; 
            color: #fff; 
            border-color: #dc2626; 
        }
        .status-btn.active-dark { 
            background: #000; 
            color: #fff; 
            border-color: #000; 
        }

        /* =====================================================
           æ–°æ‰‹å¼•å¯¼ - ä¿æŒåŸæœ‰é£æ ¼
           ===================================================== */
        .tutorial-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.9);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            backdrop-filter: blur(4px);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        .tutorial-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        .tutorial-card-container {
            width: 100%;
            max-width: 380px;
            background: #fff;
            border: 2px solid #000;
            overflow: hidden;
            position: relative;
            box-shadow: 8px 8px 0 #000;
        }

        .tutorial-slides-wrapper {
            display: flex;
            transition: transform 0.4s cubic-bezier(0.25, 1, 0.5, 1);
            width: 400%;
        }

        .tutorial-slide {
            width: 25%;
            flex-shrink: 0;
            padding: 28px;
            display: flex;
            flex-direction: column;
        }

        .tut-header {
            text-align: center;
            margin-bottom: 24px;
        }
        .tut-icon {
            font-size: 56px;
            margin-bottom: 16px;
            line-height: 1;
        }
        .tut-title {
            font-size: 20px;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-family: "Noto Sans SC", sans-serif;
        }

        .tut-body {
            flex: 1;
            font-size: 14px;
            line-height: 1.7;
            color: #333;
        }
        .tut-body ul {
            padding-left: 20px;
            margin: 0;
        }
        .tut-body li {
            margin-bottom: 14px;
            list-style-type: square;
        }
        .tut-highlight {
            font-weight: 700;
            color: #000;
            background: #f3f4f6;
            padding: 2px 6px;
            font-family: "JetBrains Mono", monospace;
        }

        .tut-footer {
            padding: 20px 28px;
            border-top: 2px solid #000;
            display: flex;
            flex-direction: column;
            gap: 16px;
            background: #f9fafb;
        }

        .tut-dots {
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        .tut-dot {
            width: 12px;
            height: 12px;
            background: #e5e7eb;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
        }
        .tut-dot.active {
            background: #000;
            transform: scale(1.2);
        }

        .tut-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .tut-btn {
            font-size: 13px;
            font-weight: 700;
            text-transform: uppercase;
            padding: 12px 20px;
            border: 2px solid #000;
            background: #fff;
            color: #000;
            cursor: pointer;
            transition: all 0.15s;
            font-family: "Noto Sans SC", sans-serif;
        }
        .tut-btn:hover {
            background: #000;
            color: #fff;
        }
        .tut-btn.skip {
            border-color: transparent;
            color: #666;
            background: transparent;
        }
        .tut-btn.skip:hover {
            color: #000;
            text-decoration: underline;
            background: transparent;
        }
        .tut-btn.start {
            background: #000;
            color: #fff;
            width: 100%;
            text-align: center;
            padding: 16px;
            font-size: 16px;
            letter-spacing: 1px;
        }
        .tut-btn.start:hover {
            background: #333;
        }

    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
const { useState, useEffect, useMemo, useRef } = React;

// ... (KEEPING ALL LOGIC CONSTANTS UNCHANGED) ...
const BASE_CHARACTER = {
    str: 50, con: 50, siz: 60, dex: 50,
    fight: 50, firearms: 20, dodge: 25,
    firstAid: 30, medicine: 5,
    armorValue: 0, hasGunReady: false,
    meleeWeapon: { name: "æ‹³å¤´", damage: "1D3", type: "melee", impale: false },
    rangedWeapon: null,
    weapons: [], 
    customSkills: [],
    attacksPerRound: 1,  // æ¯è½®æ”»å‡»æ¬¡æ•°
    attacksLeft: 1,      // æœ¬è½®å‰©ä½™æ”»å‡»æ¬¡æ•°
    luck: 50,            // å¹¸è¿å€¼ (é€šä¿—æ¨¡å¼)
    maxLuck: 50,         // æœ€å¤§å¹¸è¿å€¼ (é€šä¿—æ¨¡å¼)
    talents: [],         // å¤©èµ‹åˆ—è¡¨ (é€šä¿—æ¨¡å¼)
    isMook: false,       // å–½å•°æ ‡è®° (é€šä¿—æ¨¡å¼)
    status: { majorWound: false, dying: false, unconscious: false, prone: false, defenseUsedThisRound: false, grappled: false, grappling: false }
};

// é€šä¿—å…‹è‹é²å¤©èµ‹åˆ—è¡¨
const PULP_TALENTS = [
    { id: 'tough', name: 'ç¡¬æ±‰', desc: '+4 HPä¸Šé™', effect: 'hp_bonus' },
    { id: 'quick_healer', name: 'å¿«é€Ÿæ¢å¤', desc: 'è‡ªç„¶æ¢å¤+2 HP', effect: 'heal_bonus' },
    { id: 'iron_liver', name: 'é“è‚', desc: 'æ¯’ç´ /é…’ç²¾æ£€å®šå¥–åŠ±éª°', effect: 'skill_bonus', skills: ['con_poison', 'con_alcohol'] },
    { id: 'quick_draw', name: 'å¿«æ‹”', desc: 'å…ˆæ”»+10 (æ¶æªçŠ¶æ€)', effect: 'initiative_bonus' },
    { id: 'hard_boiled', name: 'é“çŸ³å¿ƒè‚ ', desc: 'ç†æ™ºæ£€å®šå¥–åŠ±éª°', effect: 'skill_bonus', skills: ['sanity'] },
    { id: 'brawler', name: 'è¡—å¤´æ–—å£«', desc: 'å¾’æ‰‹ä¼¤å®³+1D4', effect: 'unarmed_bonus' },
    { id: 'keen_vision', name: 'é¹°çœ¼', desc: 'ä¾¦æŸ¥æ£€å®šå¥–åŠ±éª°', effect: 'skill_bonus', skills: ['spot_hidden'] },
    { id: 'fleet_footed', name: 'é£æ¯›è…¿', desc: 'MOV+1', effect: 'mov_bonus' },
    { id: 'handy', name: 'å·§æ‰‹', desc: 'æœºæ¢°/ç”µæ°”ä¿®ç†å¥–åŠ±éª°', effect: 'skill_bonus', skills: ['mechanical_repair', 'electrical_repair'] },
    { id: 'strong_willed', name: 'æ„å¿—åšå®š', desc: 'å¯¹æŠ—å‚¬çœ /é­…æƒ‘å¥–åŠ±éª°', effect: 'skill_bonus', skills: ['pow_resist'] },
    { id: 'alert', name: 'è­¦è§‰', desc: 'è†å¬æ£€å®šå¥–åŠ±éª°', effect: 'skill_bonus', skills: ['listen'] },
    { id: 'smooth_talker', name: 'å·§èˆŒå¦‚ç°§', desc: 'è¯æœ¯/è¯´æœæ£€å®šå¥–åŠ±éª°', effect: 'skill_bonus', skills: ['fast_talk', 'persuade'] },
    { id: 'resilient', name: 'åšéŸ§', desc: 'CONæ£€å®šå¥–åŠ±éª°', effect: 'skill_bonus', skills: ['con'] },
    { id: 'lucky', name: 'å¹¸è¿å„¿', desc: 'å¹¸è¿æ¢å¤+1D10/åœºæ™¯', effect: 'luck_recovery' },
    { id: 'weird_science', name: 'å¥‡å¼‚ç§‘å­¦', desc: 'å¯ä½¿ç”¨ç–¯ç‹‚å‘æ˜', effect: 'weird_science' },
];

// é€šç”¨æŠ€èƒ½åˆ—è¡¨ (ç”¨äºæŠ€èƒ½æ£€å®š)
const SKILL_CHECKS = [
    { id: 'spot_hidden', name: 'ä¾¦æŸ¥', base: 25 },
    { id: 'listen', name: 'è†å¬', base: 20 },
    { id: 'sanity', name: 'ç†æ™º', base: 50 },
    { id: 'con', name: 'ä½“è´¨', base: 50 },
    { id: 'con_poison', name: 'æŠµæŠ—æ¯’ç´ ', base: 50 },
    { id: 'con_alcohol', name: 'æŠµæŠ—é…’ç²¾', base: 50 },
    { id: 'pow_resist', name: 'POWå¯¹æŠ—', base: 50 },
    { id: 'fast_talk', name: 'è¯æœ¯', base: 5 },
    { id: 'persuade', name: 'è¯´æœ', base: 10 },
    { id: 'mechanical_repair', name: 'æœºæ¢°ç»´ä¿®', base: 10 },
    { id: 'electrical_repair', name: 'ç”µæ°”ç»´ä¿®', base: 10 },
    { id: 'climb', name: 'æ”€çˆ¬', base: 20 },
    { id: 'swim', name: 'æ¸¸æ³³', base: 20 },
    { id: 'jump', name: 'è·³è·ƒ', base: 20 },
    { id: 'stealth', name: 'æ½œè¡Œ', base: 20 },
    { id: 'locksmith', name: 'é”åŒ ', base: 1 },
    { id: 'drive', name: 'é©¾é©¶', base: 20 },
    { id: 'pilot', name: 'é©¾é©¶é£æœº', base: 1 },
];

const MELEE_WEAPONS = [
    { name: "æ‹³å¤´", damage: "1D3", type: "melee", impale: false },
    { name: "å°åˆ€", damage: "1D4", type: "melee", impale: true },
    { name: "åŒ•é¦–", damage: "1D4+2", type: "melee", impale: true },
    { name: "æ£’çƒæ£", damage: "1D8", type: "melee", impale: false },
    { name: "æ–§å¤´", damage: "1D8+2", type: "melee", impale: true },
    { name: "é•¿å‰‘", damage: "1D8+1", type: "melee", impale: true },
    { name: "å¤§åˆ€", damage: "1D8", type: "melee", impale: true },
];

const RANGED_WEAPONS = [
    { name: ".38å·¦è½®", damage: "1D10", type: "ranged", impale: true, range: 15, ammo: 6, maxAmmo: 6, malfunction: 100 },
    { name: ".45è‡ªåŠ¨æ‰‹æª", damage: "1D10+2", type: "ranged", impale: true, range: 15, ammo: 7, maxAmmo: 7, malfunction: 100 },
    { name: "9mmæ‰‹æª", damage: "1D10", type: "ranged", impale: true, range: 15, ammo: 15, maxAmmo: 15, malfunction: 98 },
    { name: "æ­¥æª", damage: "2D6+4", type: "ranged", impale: true, range: 110, ammo: 5, maxAmmo: 5, malfunction: 100 },
    { name: "éœ°å¼¹æª", damage: "4D6", type: "ranged", impale: false, range: 10, ammo: 2, maxAmmo: 2, malfunction: 100 },
    { name: "å†²é”‹æª", damage: "1D10", type: "ranged", impale: true, range: 20, ammo: 30, maxAmmo: 30, malfunction: 96, autoFire: true },
    { name: "çªå‡»æ­¥æª", damage: "2D6", type: "ranged", impale: true, range: 90, ammo: 30, maxAmmo: 30, malfunction: 98, autoFire: true },
    { name: "è½»æœºæª", damage: "2D6+4", type: "ranged", impale: true, range: 110, ammo: 100, maxAmmo: 100, malfunction: 96, autoFire: true },
];

const WEAPON_PRESETS = [...MELEE_WEAPONS, ...RANGED_WEAPONS];

// ... (KEEPING ALL HELPER FUNCTIONS UNCHANGED) ...
const rollDice = (expr) => {
    const match = expr.match(/(\d+)[dD](\d+)(?:\+(\d+))?(?:\-(\d+))?/);
    if (!match) return { total: parseInt(expr) || 0, rolls: [] };
    const [, numStr, sidesStr, plusStr, minusStr] = match;
    const num = parseInt(numStr), sides = parseInt(sidesStr);
    const plus = parseInt(plusStr) || 0, minus = parseInt(minusStr) || 0;
    const rolls = Array(num).fill().map(() => Math.floor(Math.random() * sides) + 1);
    return { total: rolls.reduce((s, r) => s + r, 0) + plus - minus, rolls };
};

const getMaxDamage = (expr) => {
    const match = expr.match(/(\d+)[dD](\d+)(?:\+(\d+))?(?:\-(\d+))?/);
    if (!match) return parseInt(expr) || 0;
    const [, numStr, sidesStr, plusStr, minusStr] = match;
    return parseInt(numStr) * parseInt(sidesStr) + (parseInt(plusStr) || 0) - (parseInt(minusStr) || 0);
};

const calcDerived = (c, hpMultiplier = 1) => {
    // æ ‡å‡†: HP = (CON + SIZ) / 10
    // é€šä¿—: HP = (CON + SIZ) / 5 (å³ multiplier = 2)
    let hp = Math.floor((c.con + c.siz) * hpMultiplier / 10);
    
    // ç¡¬æ±‰å¤©èµ‹ (é€šä¿—æ¨¡å¼): +1D6 HPä¸Šé™
    // æ³¨æ„ï¼šè¿™é‡Œä½¿ç”¨å›ºå®šå€¼+4ï¼ˆ1D6å¹³å‡å€¼çº¦3.5ï¼Œå–æ•´ä¸º4ï¼‰ä½œä¸ºé™æ€åŠ æˆ
    // å®é™…æ¸¸æˆä¸­KPå¯ä»¥æ‰‹åŠ¨è°ƒæ•´
    if (hpMultiplier === 2 && (c.talents || []).includes('tough')) {
        hp += 4; // ç¡¬æ±‰å¤©èµ‹åŠ æˆ
    }
    
    const mov = c.str < c.siz && c.dex < c.siz ? 7 : c.str > c.siz && c.dex > c.siz ? 9 : 8;
    
    // é£æ¯›è…¿å¤©èµ‹ (é€šä¿—æ¨¡å¼): MOV+1
    const movBonus = (hpMultiplier === 2 && (c.talents || []).includes('fleet_footed')) ? 1 : 0;
    
    const sum = c.str + c.siz;
    let db = '0', build = 0;
    if (sum <= 64) { db = '-2'; build = -2; }
    else if (sum <= 84) { db = '-1'; build = -1; }
    else if (sum <= 124) { db = '0'; build = 0; }
    else if (sum <= 164) { db = '1D4'; build = 1; }
    else if (sum <= 204) { db = '1D6'; build = 2; }
    else if (sum <= 284) { db = '2D6'; build = 3; }
    else { db = '3D6'; build = 4; }
    return { maxHp: hp, mov: mov + movBonus, db, build };
};

const calculateSuccessLevel = (roll, skill) => {
    if (roll === 1) return 4;
    if (roll <= Math.floor(skill / 5)) return 3;
    if (roll <= Math.floor(skill / 2)) return 2;
    if (roll <= skill) return 1;
    if (skill < 50 && roll >= 96) return -1;
    if (roll === 100) return -1;
    return 0;
};

const getSuccessLabel = (level) => ({ 4: 'å¤§æˆåŠŸ', 3: 'æéš¾æˆåŠŸ', 2: 'å›°éš¾æˆåŠŸ', 1: 'å¸¸è§„æˆåŠŸ', 0: 'å¤±è´¥', '-1': 'å¤§å¤±è´¥' }[level] || 'æœªçŸ¥');

const executeOpposedCheck = (atkSkill, defSkill, atkRoll, defRoll, defType) => {
    const atkLvl = calculateSuccessLevel(atkRoll, atkSkill);
    const defLvl = calculateSuccessLevel(defRoll, defSkill);
    if (atkLvl > defLvl) return { success: true, winner: 'attacker', atkLvl, defLvl };
    if (defLvl > atkLvl) return { success: false, winner: 'defender', atkLvl, defLvl };
    return { success: defType === 'counter', winner: defType === 'counter' ? 'attacker' : 'defender', atkLvl, defLvl, isTie: true };
};

const calculateDamage = (weapon, attacker, successLevel, isCounterAttack, hpMultiplier = 1) => {
    if (isCounterAttack) successLevel = Math.min(successLevel, 2);
    const wDmg = rollDice(weapon.damage);
    const dbDmg = attacker.db !== '0' ? rollDice(attacker.db) : { total: 0, rolls: [] };
    let total = wDmg.total + dbDmg.total;
    let log = `${weapon.damage}(${wDmg.total})`;
    if (dbDmg.total !== 0) log += ` + DB ${attacker.db}(${dbDmg.total})`;
    
    // è¡—å¤´æ–—å£«å¤©èµ‹ (é€šä¿—æ¨¡å¼): å¾’æ‰‹ä¼¤å®³+1D4
    const isUnarmed = weapon.name === 'æ‹³å¤´' || weapon.damage === '1D3';
    const hasBrawler = hpMultiplier === 2 && (attacker.talents || []).includes('brawler');
    if (isUnarmed && hasBrawler) {
        const brawlerDmg = rollDice('1D4');
        total += brawlerDmg.total;
        log += ` + è¡—å¤´æ–—å£«(${brawlerDmg.total})`;
    }
    
    if (successLevel >= 3) {
        const maxW = getMaxDamage(weapon.damage);
        const maxDB = attacker.db !== '0' ? getMaxDamage(attacker.db) : 0;
        if (weapon.impale) {
            const extra = rollDice(weapon.damage);
            total = maxW + maxDB + extra.total;
            log = `æœ€å¤§${maxW} + DB${maxDB} + è´¯ç©¿${weapon.damage}(${extra.total})`;
            // è¡—å¤´æ–—å£«å¤©èµ‹æéš¾æˆåŠŸæ—¶ä¹ŸåŠ æˆ
            if (isUnarmed && hasBrawler) {
                const brawlerMax = rollDice('1D4');
                total += brawlerMax.total;
                log += ` + è¡—å¤´æ–—å£«(${brawlerMax.total})`;
            }
        } else {
            total = maxW + maxDB;
            log = `æœ€å¤§ä¼¤å®³ ${maxW} + DB${maxDB}`;
            if (isUnarmed && hasBrawler) {
                total += 4; // 1D4æœ€å¤§å€¼
                log += ` + è¡—å¤´æ–—å£«(4)`;
            }
        }
    }
    return { total: Math.max(0, total), damageLog: log };
};

// ... (KEEPING DICE LOGIC UNCHANGED) ...
const rollBasicDice = () => {
    const units = Math.floor(Math.random() * 10);
    const tens = Math.floor(Math.random() * 10) * 10; 
    const result = (tens + units) || 100;
    return { units, tens, result };
};

const rollExtraTens = () => Math.floor(Math.random() * 10) * 10;

const calculateFinalResult = (units, tens1, tens2, modifier) => {
    const roll1 = (tens1 + units) || 100;
    const roll2 = (tens2 + units) || 100;
    
    // æ”¯æŒæ•°å­—æ ¼å¼: æ­£æ•°=å¥–åŠ±éª°(å–å°), è´Ÿæ•°=æƒ©ç½šéª°(å–å¤§), 0=æ ‡å‡†
    const isBonus = modifier === 'bonus' || modifier > 0;
    const isPenalty = modifier === 'penalty' || modifier < 0;
    
    if (isBonus) {
        return roll1 < roll2 
            ? { finalResult: roll1, chosenTens: tens1, discardedTens: tens2 }
            : { finalResult: roll2, chosenTens: tens2, discardedTens: tens1 };
    } else if (isPenalty) {
        return roll1 > roll2 
            ? { finalResult: roll1, chosenTens: tens1, discardedTens: tens2 }
            : { finalResult: roll2, chosenTens: tens2, discardedTens: tens1 };
    }
    return { finalResult: roll1, chosenTens: tens1, discardedTens: null };
};

// =====================================================
// éª°å­æŠ•æ·å‡½æ•° - æ”¯æŒæ•°å­—è®¡æ•°å™¨
// modifier: æ­£æ•°=å¥–åŠ±éª°æ•°é‡, è´Ÿæ•°=æƒ©ç½šéª°æ•°é‡, 0=æ ‡å‡†éª°
// =====================================================
const rollWithModifier = (modifier) => {
    const units = Math.floor(Math.random() * 10);
    const diceCount = Math.abs(modifier) + 1; // è‡³å°‘æŠ•1ä¸ªåä½éª°
    const tensRolls = [];
    
    for (let i = 0; i < diceCount; i++) {
        tensRolls.push(Math.floor(Math.random() * 10) * 10);
    }
    
    const rolls = tensRolls.map(t => (t + units) || 100);
    
    let result;
    if (modifier > 0) {
        // å¥–åŠ±éª°ï¼šå–æœ€å°å€¼
        result = Math.min(...rolls);
    } else if (modifier < 0) {
        // æƒ©ç½šéª°ï¼šå–æœ€å¤§å€¼
        result = Math.max(...rolls);
    } else {
        // æ ‡å‡†éª°
        result = rolls[0];
    }
    
    return { 
        result, 
        rolls,           // æ‰€æœ‰æŠ•æ·ç»“æœ
        units,           // ä¸ªä½æ•°
        modifier,        // ä¿®æ­£å€¼
        type: modifier > 0 ? 'bonus' : modifier < 0 ? 'penalty' : 'normal',
        // å…¼å®¹æ—§ä»£ç 
        roll1: rolls[0],
        roll2: rolls[1] || null
    };
};

const generateId = () => Math.random().toString(36).substr(2, 9);

// =====================================================
// CustomNumPad (UI Update: Cleaner look)
// =====================================================
function CustomNumPad({ isOpen, value, onChange, onConfirm, onClose, label, quickActions }) {
    if (!isOpen) return null;
    
    const handleKey = (key) => {
        if (key === 'back') onChange(value.slice(0, -1));
        else if (key === 'clear') onChange('');
        else onChange(value + key);
    };

    const stopProp = (e) => e.stopPropagation();

    return (
        <div className="numpad-overlay" onClick={onClose}>
            <div className="numpad-container" onClick={stopProp}>
                {label && <div className="text-center text-xs font-bold uppercase mb-2 text-gray-500">{label}</div>}
                <div className="numpad-display">{value || '0'}</div>
                <div className="numpad-grid">
                    {['7','8','9','4','5','6','1','2','3','C','0','âœ“'].map(k => (
                        <button 
                            key={k} 
                            className={`numpad-btn ${k === 'âœ“' ? 'confirm' : ''}`}
                            onClick={() => {
                                if (k === 'âœ“') onConfirm();
                                else if (k === 'C') handleKey('clear');
                                else handleKey(k);
                            }}
                        >
                            {k === 'C' ? 'â†' : k}
                        </button>
                    ))}
                </div>
                {quickActions && quickActions.length > 0 && (
                    <div className="flex gap-2 mt-4">
                        {quickActions.map((action, i) => (
                            <button key={i} onClick={action.action} className="flex-1 py-2 text-sm font-bold border border-black hover:bg-black hover:text-white transition-colors">{action.label}</button>
                        ))}
                    </div>
                )}
            </div>
        </div>
    );
}

// =====================================================
// SmartInput (UNCHANGED LOGIC)
// =====================================================
function SmartInput({ type = 'number', value, onChange, label, sublabel, readonly = false, placeholder }) {
    const [numPadOpen, setNumPadOpen] = useState(false);
    const [tempValue, setTempValue] = useState(String(value ?? ''));
    
    useEffect(() => { setTempValue(String(value ?? '')); }, [value]);

    // æ¸²æŸ“æ ‡ç­¾ï¼ˆæ”¯æŒä¸­æ–‡ä¸»+è‹±æ–‡å‰¯ï¼‰
    const renderLabel = () => {
        if (!label) return null;
        return (
            <div className="flex items-baseline gap-1 mb-1">
                <span className="text-[10px] font-bold text-gray-500">{label}</span>
                {sublabel && <span className="text-[9px] font-mono text-gray-300">{sublabel}</span>}
            </div>
        );
    };

    if (type === 'text') {
        return (
            <div className="smart-input-container">
                {renderLabel()}
                <input 
                    type="text" 
                    value={value || ''} 
                    onChange={e => onChange(e.target.value)}
                    placeholder={placeholder}
                    className="smart-input-value text-lg font-bold"
                    style={{ cursor: 'text' }}
                />
            </div>
        );
    }

    return (
        <div className="smart-input-container">
            {renderLabel()}
            <div 
                className={`smart-input-value text-xl font-bold ${readonly ? 'readonly' : ''}`}
                onClick={() => {
                    if (!readonly) {
                        setTempValue(String(value ?? ''));
                        setNumPadOpen(true);
                    }
                }}
            >
                {value ?? '-'}
            </div>
            {!readonly && (
                <CustomNumPad 
                    isOpen={numPadOpen}
                    value={tempValue}
                    onChange={setTempValue}
                    onConfirm={() => { onChange(parseInt(tempValue) || 0); setNumPadOpen(false); }}
                    onClose={() => setNumPadOpen(false)}
                    label={label}
                    quickActions={[
                        { label: '+5', action: () => setTempValue(String((parseInt(tempValue)||0)+5)) },
                        { label: '-5', action: () => setTempValue(String(Math.max(0,(parseInt(tempValue)||0)-5))) },
                        { label: '+10', action: () => setTempValue(String((parseInt(tempValue)||0)+10)) },
                    ]}
                />
            )}
        </div>
    );
}

// =====================================================
// Toast - æ“ä½œæˆåŠŸæç¤º (ç³»ç»Ÿç»ˆç«¯é£æ ¼ v4.3.6)
// =====================================================
function Toast({ message, type = 'success', onClose }) {
    const [visible, setVisible] = useState(true);
    
    useEffect(() => {
        const timer = setTimeout(() => {
            setVisible(false);
            setTimeout(onClose, 300);
        }, 2500);
        return () => clearTimeout(timer);
    }, [onClose]);
    
    const bgColor = {
        success: 'bg-green-600',
        error: 'bg-red-600',
        info: 'bg-black',
        warning: 'bg-yellow-500',
        damage: 'bg-red-600',
    }[type] || 'bg-black';
    
    return (
        <div 
            className={`fixed top-6 left-1/2 transform -translate-x-1/2 z-[10001] px-6 py-3 text-white font-mono font-bold text-sm border-2 border-white shadow-hard transition-all duration-300 ${bgColor} ${
                visible ? 'opacity-100 translate-y-0' : 'opacity-0 -translate-y-4'
            }`}
        >
            {message}
        </div>
    );
}

// =====================================================
// StatusGrid (UI Update: Chinese Labels)
// =====================================================
function StatusGrid({ status, onChange }) {
    const statuses = [
        { key: 'majorWound', label: 'é‡ä¼¤ Major', type: 'danger' },
        { key: 'dying', label: 'æ¿’æ­» Dying', type: 'danger' },
        { key: 'unconscious', label: 'æ˜è¿· Uncon', type: 'dark' },
        { key: 'prone', label: 'å€’åœ° Prone', type: 'dark' },
    ];

    return (
        <div className="grid grid-cols-2 sm:grid-cols-4 gap-2">
            {statuses.map(s => (
                <button
                    key={s.key}
                    title={`åˆ‡æ¢${s.label}çŠ¶æ€ Toggle`}
                    className={`status-btn ${status[s.key] ? (s.type === 'danger' ? 'active-danger' : 'active-dark') : ''}`}
                    onClick={() => onChange({ ...status, [s.key]: !status[s.key] })}
                >
                    {s.label}
                </button>
            ))}
        </div>
    );
}

// =====================================================
// DiceModifierSelector - ä¸­æ–‡è®¡æ•°å™¨ç‰ˆ (v4.3.6)
// =====================================================
function DiceModifierSelector({ value, onChange }) {
    // è¾…åŠ©å‡½æ•°ï¼šè·å–å½“å‰çŠ¶æ€çš„ä¸­æ–‡æè¿°
    const getStatus = () => {
        if (value === 0) return { text: 'ğŸ² æ ‡å‡†æ£€å®š', color: 'bg-white text-black', sub: 'æ­£å¸¸æŠ•æ·' };
        if (value > 0) return { text: `ğŸ å¥–åŠ±éª° Ã—${value}`, color: 'bg-green-600 text-white', sub: `æŠ• ${value+1} ä¸ªåä½éª°ï¼Œå–æœ€å°å€¼` };
        return { text: `ğŸ’€ æƒ©ç½šéª° Ã—${Math.abs(value)}`, color: 'bg-red-600 text-white', sub: `æŠ• ${Math.abs(value)+1} ä¸ªåä½éª°ï¼Œå–æœ€å¤§å€¼` };
    };

    const status = getStatus();

    return (
        <div className="mb-6">
            {/* æ ‡é¢˜æ  */}
            <div className="flex justify-between items-end mb-2">
                <div className="text-[10px] font-black text-gray-400 tracking-widest">éª°å­ä¿®æ­£</div>
                {value !== 0 && (
                    <button 
                        onClick={() => onChange(0)}
                        className="text-[10px] font-bold text-gray-400 underline hover:text-black transition-colors"
                    >
                        é‡ç½®
                    </button>
                )}
            </div>

            {/* æ ¸å¿ƒæ§åˆ¶å™¨ - æ¡£æ¡ˆæŸœé£æ ¼ */}
            <div className="flex h-14 border-2 border-black shadow-hard-sm">
                {/* å‡å°‘æŒ‰é’® */}
                <button 
                    onClick={() => onChange(Math.max(-3, value - 1))}
                    disabled={value <= -3}
                    className="w-14 bg-gray-100 hover:bg-gray-200 active:bg-gray-300 border-r-2 border-black flex items-center justify-center disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
                >
                    <span className="text-xl font-black">âˆ’</span>
                </button>

                {/* çŠ¶æ€æ˜¾ç¤ºçª—å£ */}
                <div className={`flex-1 flex flex-col items-center justify-center transition-colors duration-200 ${status.color}`}>
                    <div className="text-lg font-black tracking-widest">{status.text}</div>
                </div>

                {/* å¢åŠ æŒ‰é’® */}
                <button 
                    onClick={() => onChange(Math.min(3, value + 1))}
                    disabled={value >= 3}
                    className="w-14 bg-gray-100 hover:bg-gray-200 active:bg-gray-300 border-l-2 border-black flex items-center justify-center disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
                >
                    <span className="text-xl font-black">+</span>
                </button>
            </div>

            {/* è§„åˆ™è§£é‡Š - çº¯ä¸­æ–‡ */}
            <div className="mt-2 text-center">
                <span className="text-[10px] font-mono text-gray-400 bg-gray-100 px-2 py-1">
                    è§„åˆ™: {status.sub}
                </span>
            </div>
        </div>
    );
}

// =====================================================
// ShootingModifierSelector - å°„å‡»ç¯å¢ƒä¿®æ­£ (æˆ˜æœ¯æ ‡ç­¾çŸ©é˜µ v4.3.6)
// =====================================================
function ShootingModifierSelector({ modifiers, onChange }) {
    const modifierOptions = [
        { key: 'targetInCover', label: 'æ©ä½“', icon: 'ğŸ§±', penalty: 1, desc: 'éƒ¨åˆ†é®æŒ¡' },
        { key: 'targetMoving', label: 'ç§»åŠ¨ç›®æ ‡', icon: 'ğŸƒ', penalty: 1, desc: 'éé™æ­¢' },
        { key: 'shooterMoving', label: 'ç§»åŠ¨å°„å‡»', icon: 'ğŸš¶', penalty: 1, desc: 'å°„æ‰‹ç§»åŠ¨ä¸­' },
        { key: 'targetSmall', label: 'å°ç›®æ ‡', icon: 'ğŸ', penalty: 1, desc: 'ä½“å‹å°' },
        { key: 'lowVisibility', label: 'ä½èƒ½è§åº¦', icon: 'ğŸŒ«ï¸', penalty: 1, desc: 'é»‘æš—/çƒŸé›¾' },
    ];
    
    const toggleModifier = (key) => {
        onChange({ ...modifiers, [key]: !modifiers[key] });
    };
    
    const totalPenalty = modifierOptions.reduce((sum, opt) => sum + (modifiers[opt.key] ? opt.penalty : 0), 0);
    
    return (
        <div className="mb-4">
            <div className="flex items-baseline justify-between mb-2">
                <div className="flex items-baseline gap-2">
                    <span className="text-[10px] font-bold text-gray-500">å°„å‡»ç¯å¢ƒ</span>
                    <span className="text-[9px] font-mono text-gray-300">TACTICAL MODIFIERS</span>
                </div>
                {totalPenalty > 0 && (
                    <span className="text-[10px] font-mono font-bold text-red-600 bg-red-50 px-2 py-0.5 border border-red-200">
                        âˆ’{totalPenalty} æƒ©ç½šéª°
                    </span>
                )}
            </div>
            
            {/* æˆ˜æœ¯æ ‡ç­¾ç½‘æ ¼ */}
            <div className="grid grid-cols-3 gap-1.5">
                {modifierOptions.map(opt => (
                    <button
                        key={opt.key}
                        onClick={() => toggleModifier(opt.key)}
                        className={`
                            p-2 text-[10px] font-bold border-2 transition-all duration-150 flex flex-col items-center justify-center h-14
                            ${modifiers[opt.key] 
                                ? 'bg-red-600 text-white border-red-800 shadow-inner' 
                                : 'bg-white text-gray-400 border-gray-200 hover:border-gray-400 hover:text-gray-600'}
                        `}
                    >
                        <span className="text-base mb-0.5">{opt.icon}</span>
                        <span className="leading-tight">{opt.label}</span>
                    </button>
                ))}
            </div>
            
            {/* æç¤ºä¿¡æ¯ */}
            {totalPenalty > 0 && (
                <div className="text-[9px] text-gray-500 mt-2 text-center">
                    æ¯ä¸ªä¸åˆ©å› ç´  = 1ä¸ªæƒ©ç½šéª°ï¼Œä¼šä¸éª°å­ä¿®æ­£å åŠ è®¡ç®—
                </div>
            )}
        </div>
    );
}

// =====================================================
// StepDiceRoller (v4.3.6 æ”¯æŒæ•°å­—æ ¼å¼modifier)
// =====================================================
function StepDiceRoller({ isOpen, modifier, targetNumber, onComplete, onClose }) {
    const [step, setStep] = useState(0);
    const [units, setUnits] = useState(null);
    const [tens1, setTens1] = useState(null);
    const [tens2, setTens2] = useState(null);
    const [finalResult, setFinalResult] = useState(null);
    const [isRolling, setIsRolling] = useState(false);

    useEffect(() => {
        if (isOpen) {
            setStep(0); setUnits(null); setTens1(null); setTens2(null); setFinalResult(null); setIsRolling(false);
        }
    }, [isOpen]);

    if (!isOpen) return null;
    
    // åˆ¤æ–­æ˜¯å¦éœ€è¦é¢å¤–éª°å­
    const isBonus = modifier === 'bonus' || modifier > 0;
    const isPenalty = modifier === 'penalty' || modifier < 0;
    const isNormal = modifier === 'normal' || modifier === 0;
    const needExtraDice = isBonus || isPenalty;

    const startRoll = () => {
        setStep(1); setIsRolling(true);
        let rollCount = 0;
        const rollInterval = setInterval(() => {
            setUnits(Math.floor(Math.random() * 10));
            setTens1(Math.floor(Math.random() * 10) * 10);
            rollCount++;
            if (rollCount >= 10) {
                clearInterval(rollInterval);
                setUnits(Math.floor(Math.random() * 10));
                setTens1(Math.floor(Math.random() * 10) * 10);
                setIsRolling(false); setStep(2);
            }
        }, 80);
    };

    const rollExtraDice = () => {
        setStep(3); setIsRolling(true);
        let rollCount = 0;
        const rollInterval = setInterval(() => {
            setTens2(Math.floor(Math.random() * 10) * 10);
            rollCount++;
            if (rollCount >= 10) {
                clearInterval(rollInterval);
                const finalTens2 = Math.floor(Math.random() * 10) * 10;
                setTens2(finalTens2); setIsRolling(false);
                const result = calculateFinalResult(units, tens1, finalTens2, modifier);
                setFinalResult(result.finalResult); setStep(4);
            }
        }, 80);
    };

    const confirmResult = () => {
        onComplete(isNormal ? ((tens1 + units) || 100) : finalResult);
        onClose();
    };

    const basicResult = (tens1 !== null && units !== null) ? ((tens1 + units) || 100) : null;
    const modifierLabel = isBonus 
        ? `ğŸ ${typeof modifier === 'number' ? `${modifier}ä¸ª` : ''}å¥–åŠ±éª°` 
        : isPenalty 
            ? `ğŸ’€ ${typeof modifier === 'number' ? `${Math.abs(modifier)}ä¸ª` : ''}æƒ©ç½šéª°` 
            : 'ğŸ² æ ‡å‡†éª°';
    const getResultClass = (roll) => (roll === null || targetNumber === null) ? '' : (roll <= targetNumber ? 'success' : 'fail');

    return (
        <div className="step-dice-overlay fixed inset-0 z-[10000] flex items-center justify-center flex-col" onClick={(e) => { if (step === 0) onClose(); }}>
            <div className="step-dice-container bg-black border-2 border-white p-8 w-[90%] max-w-[420px] text-center shadow-[8px_8px_0_white]" onClick={e => e.stopPropagation()}>
                <div className="text-gray-400 text-xs font-black tracking-[0.2em] mb-6">{modifierLabel}</div>
                
                {step === 0 && (
                    <>
                        <div className="flex justify-center gap-4 my-8">
                            <div className="dice-block w-20 h-20 bg-black text-white border-2 border-white text-4xl font-mono flex items-center justify-center font-bold shadow-[4px_4px_0_white]">?</div>
                            <div className="dice-block w-20 h-20 bg-black text-white border-2 border-white text-4xl font-mono flex items-center justify-center font-bold shadow-[4px_4px_0_white]">?</div>
                        </div>
                        {targetNumber && <div className="text-gray-500 text-xs mb-6">ç›®æ ‡å€¼: <span className="text-white font-bold text-lg font-mono">{targetNumber}</span></div>}
                        <button className="w-full bg-white text-black font-black py-4 text-lg tracking-[0.1em] hover:bg-gray-200 transition-colors border-2 border-white" onClick={startRoll}>ğŸ² æ· éª°</button>
                    </>
                )}

                {step === 1 && (
                    <>
                        <div className="flex justify-center gap-4 my-8">
                            <div className={`dice-block w-20 h-20 bg-black text-white border-2 border-white text-4xl font-mono flex items-center justify-center font-bold ${isRolling ? 'animate-pulse' : ''}`}>{tens1 !== null ? String(tens1 / 10) : '?'}</div>
                            <div className={`dice-block w-20 h-20 bg-black text-white border-2 border-white text-4xl font-mono flex items-center justify-center font-bold ${isRolling ? 'animate-pulse' : ''}`}>{units !== null ? units : '?'}</div>
                        </div>
                        <div className="text-gray-400 text-sm font-bold tracking-widest">æ·éª°ä¸­...</div>
                    </>
                )}

                {step === 2 && (
                    <>
                        <div className="flex justify-center gap-4 my-8">
                            <div className="dice-block w-20 h-20 bg-black text-white border-2 border-white text-4xl font-mono flex items-center justify-center font-bold shadow-[4px_4px_0_white]">{String(tens1 / 10)}</div>
                            <div className="dice-block w-20 h-20 bg-black text-white border-2 border-white text-4xl font-mono flex items-center justify-center font-bold shadow-[4px_4px_0_white]">{units}</div>
                        </div>
                        <div className={`text-6xl font-mono font-black p-4 mb-6 ${basicResult <= targetNumber ? 'text-green-400' : 'text-red-400'}`}>{basicResult}</div>
                        {targetNumber && <div className={`text-xs mb-6 font-black tracking-wide ${basicResult <= targetNumber ? 'text-green-400' : 'text-red-400'}`}>{basicResult <= targetNumber ? 'âœ“ æˆåŠŸ' : 'âœ— å¤±è´¥'} (â‰¤{targetNumber})</div>}
                        {isNormal ? (
                            <button className="w-full bg-white text-black font-black py-4 text-lg tracking-[0.1em] hover:bg-gray-200 transition-colors" onClick={confirmResult}>ç¡® è®¤</button>
                        ) : (
                            <button className="w-full bg-white text-black font-black py-4 text-lg tracking-[0.1em] hover:bg-gray-200 transition-colors" onClick={rollExtraDice}>ğŸ² é¢å¤–åä½éª°</button>
                        )}
                    </>
                )}

                {step === 3 && (
                    <div className="text-gray-400 py-10 font-bold tracking-widest">æ·é¢å¤–åä½éª°ä¸­...</div>
                )}

                {step === 4 && (
                    <>
                         <div className="flex justify-center items-center gap-3 my-8 flex-wrap">
                            {(() => {
                                const result1 = (tens1 + units) || 100;
                                const result2 = (tens2 + units) || 100;
                                const isFirstChosen = (isBonus && result1 <= result2) || (isPenalty && result1 >= result2);
                                return (
                                    <>
                                        <div className={`dice-block w-16 h-16 text-3xl font-mono flex items-center justify-center font-bold border-2 ${isFirstChosen ? 'bg-green-500 border-green-400 text-white' : 'bg-red-900 border-red-800 text-red-400 opacity-50'}`}>{String(tens1 / 10)}</div>
                                        <div className="dice-block w-16 h-16 bg-black text-white border-2 border-white text-3xl font-mono flex items-center justify-center font-bold">{units}</div>
                                        <div className="text-gray-600 text-lg font-black">VS</div>
                                        <div className={`dice-block w-16 h-16 text-3xl font-mono flex items-center justify-center font-bold border-2 ${!isFirstChosen ? 'bg-green-500 border-green-400 text-white' : 'bg-red-900 border-red-800 text-red-400 opacity-50'}`}>{String(tens2 / 10)}</div>
                                        <div className="dice-block w-16 h-16 bg-black text-white border-2 border-white text-3xl font-mono flex items-center justify-center font-bold">{units}</div>
                                    </>
                                );
                            })()}
                        </div>
                        <div className={`text-6xl font-mono font-black p-4 mb-6 ${finalResult <= targetNumber ? 'text-green-400' : 'text-red-400'}`}>{finalResult}</div>
                        <button className="w-full bg-white text-black font-black py-4 text-lg tracking-[0.1em] hover:bg-gray-200 transition-colors" onClick={confirmResult}>ç¡® è®¤</button>
                    </>
                )}
            </div>
        </div>
    );
}

// =====================================================
// App ä¸»ç»„ä»¶
// =====================================================
function App() {
    const [view, setView] = useState('setup');
    const [characters, setCharacters] = useState([]);
    const [logs, setLogs] = useState([]);
    const [turn, setTurn] = useState({ round: 1, index: 0 });
    const [history, setHistory] = useState([]);
    const [kpPanelOpen, setKpPanelOpen] = useState(false);
    const [showTutorialForce, setShowTutorialForce] = useState(false);
    const [hpMultiplier, setHpMultiplier] = useState(1); // 1=æ ‡å‡†, 2=é€šä¿—
    const logContainerRef = useRef(null);
    
    // v4.3.6 Toastæç¤ºçŠ¶æ€
    const [toasts, setToasts] = useState([]);
    
    const showToast = (message, type = 'success') => {
        const id = Date.now();
        setToasts(prev => [...prev, { id, message, type }]);
    };
    
    const removeToast = (id) => {
        setToasts(prev => prev.filter(t => t.id !== id));
    };

    useEffect(() => {
        if (logContainerRef.current) logContainerRef.current.scrollTop = logContainerRef.current.scrollHeight;
    }, [logs]);

    const saveToHistory = () => {
        setHistory(prev => [...prev.slice(-19), {
            characters: JSON.parse(JSON.stringify(characters)),
            turn: { ...turn },
            logs: [...logs]
        }]);
    };

    const undo = () => {
        if (history.length === 0) return;
        const last = history[history.length - 1];
        setCharacters(last.characters); setTurn(last.turn); setLogs(last.logs);
        setHistory(prev => prev.slice(0, -1));
    };

    // å­˜æ¡£å¯¼å‡º
    const exportSave = (name) => {
        const saveData = {
            version: "4.3.6",
            name,
            timestamp: new Date().toISOString(),
            characters, turn, logs,
            combatStarted: view === 'combat',
            settings: { hpMultiplier }
        };
        const blob = new Blob([JSON.stringify(saveData, null, 2)], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `COC7_${name}_${new Date().toLocaleDateString().replace(/\//g, '-')}.txt`;
        a.click();
        URL.revokeObjectURL(url);
    };

    // å­˜æ¡£å¯¼å…¥
    const importSave = (file) => {
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = JSON.parse(e.target.result);
                if (data.version && data.characters) {
                    setCharacters(data.characters);
                    setTurn(data.turn || { round: 1, index: 0 });
                    setLogs(data.logs || []);
                    if (data.settings?.hpMultiplier) setHpMultiplier(data.settings.hpMultiplier);
                    if (data.combatStarted) setView('combat');
                    else setView('setup');
                    addLog(`ğŸ“‚ å·²åŠ è½½å­˜æ¡£: ${data.name}${data.settings?.hpMultiplier === 2 ? ' [é€šä¿—æ¨¡å¼]' : ''}`, 'system');
                } else {
                    alert('å­˜æ¡£æ ¼å¼é”™è¯¯: ç¼ºå°‘å¿…è¦å­—æ®µ');
                }
            } catch (err) {
                alert('å­˜æ¡£æ ¼å¼é”™è¯¯: ' + err.message);
            }
        };
        reader.readAsText(file);
    };

    // æˆ˜æ–—æ—¥å¿—å¯¼å‡º - æ´»å­—å¼•æ“æ ¼å¼ (å®Œå…¨æ±‰åŒ–ç‰ˆ)
    const exportLogsToTxt = () => {
        // ä¸Šä¸‹æ–‡çŠ¶æ€è¿½è¸ª
        let currentActor = '';
        let currentWeapon = '';
        let currentTarget = '';
        let currentSkillValue = 50; // é»˜è®¤æŠ€èƒ½å€¼
        let lastBonusPenaltyInfo = ''; // ä¿å­˜å¥–åŠ±éª°/æƒ©ç½šéª°ä¿¡æ¯
        
        // æˆåŠŸç­‰çº§æ±‰åŒ–
        const localizeResult = (text) => {
            return text
                .replace(/æéš¾æˆåŠŸ/g, 'æéš¾æˆåŠŸ')
                .replace(/å›°éš¾æˆåŠŸ/g, 'å›°éš¾æˆåŠŸ')
                .replace(/å¸¸è§„æˆåŠŸ/g, 'æˆåŠŸ')
                .replace(/å¤§æˆåŠŸ/g, 'å¤§æˆåŠŸ')
                .replace(/å¤±è´¥/g, 'å¤±è´¥')
                .replace(/å¤§å¤±è´¥/g, 'å¤§å¤±è´¥');
        };
        
        // è½¬æ¢å•è¡Œæ—¥å¿—
        const convertLine = (text, index, allLogs) => {
            // ğŸ›¡ï¸ v4.3.6 å®‰å…¨è¡¥ä¸ï¼šå¦‚æœæ—¥å¿—åŒ…å« undefinedï¼Œç›´æ¥è·³è¿‡ï¼Œé˜²æ­¢æ±¡æŸ“è„šæœ¬
            if (text.includes('undefined')) return null;
            
            // === æˆ˜æ–—èµ·æ­¢ ===
            if (text.includes('æˆ˜æ–—å¼€å§‹') || text.includes('COMBAT START')) {
                return '<kp>æˆ˜æ–—å¼€å§‹';
            }
            if (text.includes('æˆ˜æ–—ç»“æŸ') || text.includes('COMBAT END')) {
                return '<kp>æˆ˜æ–—ç»“æŸ';
            }
            
            // === å›åˆæ ‡è®° (æ±‰åŒ–) ===
            if (text.includes('ROUND')) {
                const match = text.match(/ROUND\s*(\d+)/);
                if (match) {
                    return `<kp>â€”â€” ç¬¬ ${match[1]} å›åˆ â€”â€”`;
                }
            }
            // ä¸­æ–‡å›åˆæ ‡è®° (ğŸ“… ç¬¬ X è½®)
            if (text.includes('ğŸ“…') && text.includes('ç¬¬') && text.includes('è½®')) {
                const match = text.match(/ç¬¬\s*(\d+)\s*è½®/);
                if (match) {
                    return `<kp>â€”â€” ç¬¬ ${match[1]} å›åˆ â€”â€”`;
                }
            }
            
            // === æ”»å‡»å®£è¨€ - è¿‘æˆ˜ ===
            if (text.startsWith('âš”ï¸') && text.includes('â†’') && !text.includes('COUNTER')) {
                const match = text.match(/âš”ï¸\s*(.+?)\s*â†’\s*(.+?)\s*\[(.+?)\]/);
                if (match) {
                    currentActor = match[1].trim();
                    currentTarget = match[2].trim();
                    currentWeapon = match[3].trim();
                    return `<kp>${currentActor} å¯¹ ${currentTarget} ä½¿ç”¨ [${currentWeapon}] æ”»å‡»`;
                }
            }
            
            // === æˆ˜æŠ€å®£è¨€ ===
            if (text.startsWith('ğŸ¤¼') && text.includes('â†’')) {
                const match = text.match(/ğŸ¤¼\s*(.+?)\s*â†’\s*(.+?)\s*\[(.+?)\]/);
                if (match) {
                    currentActor = match[1].trim();
                    currentTarget = match[2].trim();
                    const maneuverType = match[3].trim();
                    // å°†æˆ˜æŠ€ç±»å‹ä½œä¸º"æ­¦å™¨"ï¼Œç”¨äºåç»­ATK/DEFæ£€å®šçš„å¯¼å‡º
                    const maneuverNames = { disarm: 'ç¼´æ¢°', knockdown: 'å‡»å€’', grapple: 'æ“’æŠ±', push: 'æ¨æ’', stun: 'å‡»æ™•' };
                    currentWeapon = maneuverNames[maneuverType] || maneuverType;
                    return `<kp>${currentActor} å¯¹ ${currentTarget} å‘åŠ¨ [${currentWeapon}]`;
                }
            }
            
            // === æˆ˜æŠ€æˆåŠŸ ===
            if (text.startsWith('âœ…') && (text.includes('ç¼´æ¢°') || text.includes('å‡»å€’') || text.includes('æ“’æŠ±') || text.includes('æ¨æ’') || text.includes('å‡»æ™•'))) {
                const match = text.match(/âœ…\s*(.+?)\s*æˆåŠŸ/);
                if (match) {
                    return `<kp>${currentActor} å¯¹ ${currentTarget} ${match[1].trim()}æˆåŠŸï¼`;
                }
            }
            
            // === ç¼´æ¢°æ•ˆæœ ===
            if (text.startsWith('ğŸ¤š') && text.includes('è¢«å¤ºèµ°')) {
                const match = text.match(/ğŸ¤š\s*(.+?)\s*çš„\s*\[(.+?)\]\s*è¢«å¤ºèµ°/);
                if (match) {
                    return `<kp>${match[1].trim()} çš„ [${match[2].trim()}] è¢«å¤ºèµ°ï¼`;
                }
            }
            
            // === å‡»å€’æ•ˆæœ ===
            if (text.startsWith('ğŸ¦µ') && text.includes('è¢«å‡»å€’')) {
                return `<kp>${text.replace('ğŸ¦µ', '').trim()}`;
            }
            
            // === æ“’æŠ±æ•ˆæœ ===
            if (text.includes('æ“’æŠ±ä½äº†')) {
                return `<kp>${text.replace('ğŸ¤¼', '').trim()}`;
            }
            
            // === æ¨æ’æ•ˆæœ ===
            if (text.startsWith('ğŸ’¨') && (text.includes('è¢«æ¨å€’') || text.includes('è¢«æ¨å¼€'))) {
                return `<kp>${text.replace('ğŸ’¨', '').trim()}`;
            }
            
            // === æ”»å‡»å®£è¨€ - å°„å‡»/è¿å°„/å…¨è‡ªåŠ¨ ===
            if (text.startsWith('ğŸ”«')) {
                // è¿å°„
                let match = text.match(/ğŸ”«\s*(.+?)\s*è¿å°„(\d+)å‘\s*â†’\s*(.+?)\s*\[(.+?)\]/);
                if (match) {
                    currentActor = match[1].trim();
                    currentTarget = match[3].trim();
                    currentWeapon = match[4].trim();
                    return `<kp>${currentActor} å¯¹ ${currentTarget} ä½¿ç”¨ [${currentWeapon}] å°„å‡» (${match[2]}è¿å°„)`;
                }
                // å…¨è‡ªåŠ¨
                match = text.match(/ğŸ”«\s*(.+?)\s*å…¨è‡ªåŠ¨å°„å‡»\s*(\d+)å‘\s*â†’\s*(.+)/);
                if (match) {
                    currentActor = match[1].trim();
                    currentWeapon = 'å…¨è‡ªåŠ¨';
                    return `<kp>${currentActor} å…¨è‡ªåŠ¨å°„å‡» ${match[2]}å‘ â†’ ${match[3]}`;
                }
                // æ™®é€šå°„å‡»
                match = text.match(/ğŸ”«\s*(.+?)\s*â†’\s*(.+?)\s*\[(.+?)\]/);
                if (match) {
                    currentActor = match[1].trim();
                    currentTarget = match[2].trim();
                    currentWeapon = match[3].trim();
                    return `<kp>${currentActor} å¯¹ ${currentTarget} ä½¿ç”¨ [${currentWeapon}] å°„å‡»`;
                }
            }
            
            // === å¥–åŠ±éª°/æƒ©ç½šéª°è¿‡ç¨‹è¡Œ - æ•è·ä¿¡æ¯ä½†ä¸è¾“å‡º ===
            if (text.includes('å¥–åŠ±éª°:') || text.includes('æƒ©ç½šéª°:')) {
                const match = text.match(/(å¥–åŠ±éª°|æƒ©ç½šéª°):\s*\[(\d+),\s*(\d+)\]/);
                if (match) {
                    lastBonusPenaltyInfo = `${match[1]} ${match[2]},${match[3]}`;
                }
                return null; // ä¸ç›´æ¥è¾“å‡ºï¼Œä¿¡æ¯ä¼šè¢«åç»­è¡Œä½¿ç”¨
            }
            
            // === æ ‡å‡†éª°è¿‡ç¨‹è¡Œ - æ•è·ä½†ä¸è¾“å‡º ===
            if (text.includes('æ ‡å‡†éª°:')) {
                lastBonusPenaltyInfo = ''; // æ¸…é™¤ï¼Œæ ‡å‡†éª°ä¸éœ€è¦å¤‡æ³¨
                return null;
            }
            
            // === ATK æ£€å®š ===
            if (text.includes('ATK') && text.includes('[')) {
                const match = text.match(/ATK\s*\[(\d+)\/(\d+)\]\s*(.+)/);
                if (match) {
                    currentSkillValue = parseInt(match[2]);
                    const result = localizeResult(match[3].trim());
                    const extra = lastBonusPenaltyInfo ? `(${lastBonusPenaltyInfo})` : '';
                    lastBonusPenaltyInfo = '';
                    return `ã€éª°å­ã€‘(${currentActor} ${currentWeapon})D100=${match[1]}/${match[2]} ${result}${extra}`;
                }
            }
            
            // === DEF æ£€å®š ===
            if (text.includes('DEF') && text.includes('[')) {
                const match = text.match(/DEF\s*\[(\d+)\/(\d+)\]\s*(.+)/);
                if (match) {
                    const result = localizeResult(match[3].trim());
                    const extra = lastBonusPenaltyInfo ? `(${lastBonusPenaltyInfo})` : '';
                    lastBonusPenaltyInfo = '';
                    // åˆ¤æ–­æ˜¯æˆ˜æŠ€è¿˜æ˜¯æ™®é€šæ”»å‡»
                    const isManeuver = ['ç¼´æ¢°', 'å‡»å€’', 'æ“’æŠ±', 'æ¨æ’', 'å‡»æ™•'].includes(currentWeapon);
                    const defenseType = isManeuver ? 'é˜²å¾¡' : 'é—ªé¿';
                    return `ã€éª°å­ã€‘(${currentTarget} ${defenseType})D100=${match[1]}/${match[2]} ${result}${extra}`;
                }
            }
            
            // === HIT å‘½ä¸­ (å•å‘å°„å‡»æˆåŠŸ) ===
            if (text.includes('ğŸ¯') && text.includes('HIT')) {
                const match = text.match(/HIT\s*\[(\d+)\/(\d+)\]\s*(.+)/);
                if (match) {
                    const result = localizeResult(match[3].trim());
                    const extra = lastBonusPenaltyInfo ? `(${lastBonusPenaltyInfo})` : '';
                    lastBonusPenaltyInfo = '';
                    return `ã€éª°å­ã€‘(${currentActor} ${currentWeapon})D100=${match[1]}/${match[2]} ${result}${extra}`;
                }
            }
            
            // === ğŸ² å°„å‡»æ£€å®š (v4.3.x æ–°æ ¼å¼) ===
            if (text.includes('ğŸ²') && text.includes('å°„å‡»') && text.includes('[')) {
                const match = text.match(/å°„å‡»\s*\[(\d+)\/(\d+)\]\s*(.+)/);
                if (match) {
                    currentSkillValue = parseInt(match[2]);
                    const result = localizeResult(match[3].trim());
                    const extra = lastBonusPenaltyInfo ? `(${lastBonusPenaltyInfo})` : '';
                    lastBonusPenaltyInfo = '';
                    return `ã€éª°å­ã€‘(${currentActor} ${currentWeapon})D100=${match[1]}/${match[2]} ${result}${extra}`;
                }
            }
            
            // === ğŸ² æ”»å‡»æ£€å®š (v4.3.x æ–°æ ¼å¼) ===
            if (text.includes('ğŸ²') && text.includes('æ”»å‡»') && text.includes('[')) {
                const match = text.match(/æ”»å‡»\s*\[(\d+)\/(\d+)\]\s*(.+)/);
                if (match) {
                    currentSkillValue = parseInt(match[2]);
                    const result = localizeResult(match[3].trim());
                    const extra = lastBonusPenaltyInfo ? `(${lastBonusPenaltyInfo})` : '';
                    lastBonusPenaltyInfo = '';
                    return `ã€éª°å­ã€‘(${currentActor} ${currentWeapon})D100=${match[1]}/${match[2]} ${result}${extra}`;
                }
            }
            
            // === ğŸ² æ£€å®š (æ‰‹åŠ¨æ¨¡å¼é€šç”¨æ ¼å¼) ===
            if (text.includes('ğŸ²') && text.includes('æ£€å®š') && text.includes('[')) {
                const match = text.match(/æ£€å®š\s*\[(\d+)\/(\d+)\]\s*(.+)/);
                if (match) {
                    currentSkillValue = parseInt(match[2]);
                    const result = localizeResult(match[3].trim());
                    const extra = lastBonusPenaltyInfo ? `(${lastBonusPenaltyInfo})` : '';
                    lastBonusPenaltyInfo = '';
                    return `ã€éª°å­ã€‘(${currentActor} ${currentWeapon})D100=${match[1]}/${match[2]} ${result}${extra}`;
                }
            }
            
            // === MISS æœªå‘½ä¸­ ===
            if (text.includes('ğŸ’¨') && text.includes('MISS')) {
                const match = text.match(/MISS\s*\[(\d+)\/(\d+)\]/);
                if (match) {
                    const extra = lastBonusPenaltyInfo ? `(${lastBonusPenaltyInfo})` : '';
                    lastBonusPenaltyInfo = '';
                    return `ã€éª°å­ã€‘(${currentActor} ${currentWeapon})D100=${match[1]}/${match[2]} å¤±è´¥${extra}`;
                }
                // å…¼å®¹æ—§æ ¼å¼ï¼ˆæ— æŠ€èƒ½å€¼ï¼‰
                const oldMatch = text.match(/MISS\s*\[(\d+)\]/);
                if (oldMatch) {
                    return `ã€éª°å­ã€‘(${currentActor} ${currentWeapon})D100=${oldMatch[1]}/${currentSkillValue} å¤±è´¥`;
                }
            }
            
            // === æ”»å‡»æœªå‘½ä¸­ (v4.3.x æ‰‹åŠ¨æ¨¡å¼) ===
            if (text.includes('ğŸ’¨') && text.includes('æ”»å‡»æœªå‘½ä¸­')) {
                return '<kp>æ”»å‡»æœªå‘½ä¸­';
            }
            
            // === å…¨éƒ¨è½ç©º (è¿å°„/å…¨è‡ªåŠ¨) ===
            if (text.includes('ğŸ’¨') && (text.includes('å…¨éƒ¨è½ç©º') || text.includes('è½ç©º'))) {
                return '<kp>å…¨éƒ¨æœªå‘½ä¸­ï¼';
            }
            
            // === è¿å°„æ£€å®š ===
            if (text.includes('ç¬¬') && text.includes('å‘') && text.includes('[')) {
                // å®Œæ•´æ ¼å¼: ğŸ² ç¬¬Xå‘ [å‡ºç›®/ç›®æ ‡] (éª°å­ç±»å‹) â†’ ç»“æœ
                let match = text.match(/ç¬¬(\d+)å‘\s*\[(\d+)\/(\d+)\]\s*\((.+?)\)\s*â†’\s*(.+)/);
                if (match) {
                    currentSkillValue = parseInt(match[3]);
                    const diceType = match[4].trim();
                    const result = localizeResult(match[5].trim());
                    let diceNote = '';
                    if (diceType.includes('å¥–åŠ±') || diceType.includes('æƒ©ç½š')) {
                        diceNote = lastBonusPenaltyInfo ? `(${lastBonusPenaltyInfo})` : `(${diceType})`;
                    }
                    lastBonusPenaltyInfo = '';
                    return `ã€éª°å­ã€‘(${currentActor} ${currentWeapon})D100=${match[2]}/${match[3]} ${result}${diceNote}`;
                }
                // ç®€åŒ–æ ¼å¼: ğŸ² ç¬¬Xå‘ [å‡ºç›®/ç›®æ ‡] ç»“æœ
                match = text.match(/ç¬¬(\d+)å‘\s*\[(\d+)\/(\d+)\]\s*(.+)/);
                if (match) {
                    currentSkillValue = parseInt(match[3]);
                    const result = localizeResult(match[4].trim());
                    const diceNote = lastBonusPenaltyInfo ? `(${lastBonusPenaltyInfo})` : '';
                    lastBonusPenaltyInfo = '';
                    return `ã€éª°å­ã€‘(${currentActor} ${currentWeapon})D100=${match[2]}/${match[3]} ${result}${diceNote}`;
                }
            }
            
            // === å¼¹å¹•æ£€å®š (å…¨è‡ªåŠ¨) ===
            if (text.includes('å¼¹å¹•') && text.includes('[')) {
                // å®Œæ•´æ ¼å¼: ğŸ² å¼¹å¹•X [å‡ºç›®/ç›®æ ‡]... â†’ ç»“æœ (å‘½ä¸­Xå‘)
                let match = text.match(/å¼¹å¹•(\d+)\s*\[(\d+)\/(\d+)\](.*)â†’\s*(.+)/);
                if (match) {
                    const extraInfo = match[4].trim();
                    const result = localizeResult(match[5].trim().split('(')[0].trim()); // å»æ‰(å‘½ä¸­Xå‘)
                    const note = extraInfo ? `(${extraInfo.replace(/[\(\)]/g, '')})` : '';
                    return `ã€éª°å­ã€‘(${currentActor} å…¨è‡ªåŠ¨)D100=${match[2]}/${match[3]} ${result}${note}`;
                }
                // ç®€åŒ–æ ¼å¼: ğŸ² å¼¹å¹•X [å‡ºç›®/ç›®æ ‡] ç»“æœ
                match = text.match(/å¼¹å¹•(\d+)\s*\[(\d+)\/(\d+)\]\s*(.+)/);
                if (match) {
                    const result = localizeResult(match[4].trim().split('(')[0].trim());
                    const extra = lastBonusPenaltyInfo ? `(${lastBonusPenaltyInfo})` : '';
                    lastBonusPenaltyInfo = '';
                    return `ã€éª°å­ã€‘(${currentActor} å…¨è‡ªåŠ¨)D100=${match[2]}/${match[3]} ${result}${extra}`;
                }
            }
            
            // === åŒ»ç–—æ£€å®š ===
            if ((text.includes('ğŸ©¹') || text.includes('âš•ï¸')) && text.includes('[')) {
                const match = text.match(/[ğŸ©¹âš•ï¸]\s*(.+?)\s*\[(\d+)\/(\d+)\]\s*â†’\s*(.+)/);
                if (match) {
                    const skillName = match[1].replace(/First Aid|Medicine/gi, '').trim() || 'æ€¥æ•‘';
                    const result = localizeResult(match[4].trim());
                    return `ã€éª°å­ã€‘(${currentActor} ${skillName})D100=${match[2]}/${match[3]} ${result}`;
                }
            }
            
            // === KPæ§åˆ¶å°æŠ€èƒ½æ£€å®š (ğŸ“‹æ ¼å¼) ===
            if (text.includes('ğŸ“‹') && text.includes('æ£€å®š') && text.includes('[')) {
                // æ ¼å¼: ğŸ“‹ è§’è‰²å æŠ€èƒ½åæ£€å®š [å‡ºç›®/ç›®æ ‡å€¼] ç»“æœ [å¤©èµ‹]
                const match = text.match(/ğŸ“‹\s*(.+?)\s+(.+?)æ£€å®š\s*\[(\d+)\/(\d+)\]\s*(.+)/);
                if (match) {
                    const charName = match[1].trim();
                    const skillName = match[2].trim();
                    const roll = match[3];
                    const target = match[4];
                    let result = localizeResult(match[5].trim());
                    // ç§»é™¤å¤©èµ‹æ ‡è®°ä½†ä¿ç•™åœ¨å¤‡æ³¨
                    const talentMatch = result.match(/\[(.+?)\]/);
                    let talentNote = '';
                    if (talentMatch) {
                        talentNote = `(${talentMatch[1]})`;
                        result = result.replace(/\s*\[.+?\]/, '').trim();
                    }
                    const extra = lastBonusPenaltyInfo ? `(${lastBonusPenaltyInfo})` : talentNote;
                    lastBonusPenaltyInfo = '';
                    return `ã€éª°å­ã€‘(${charName} ${skillName})D100=${roll}/${target} ${result}${extra}`;
                }
            }
            
            // === ä¼¤å®³ç»“ç®— ===
            if (text.startsWith('ğŸ’¥')) {
                // å®Œæ•´æ ¼å¼: ğŸ’¥ ç›®æ ‡ -X HP [...] (Aâ†’B)
                const match = text.match(/ğŸ’¥\s*(.+?)\s*(-?\d+)\s*HP.*\((\d+)â†’(\d+)\)/);
                if (match) {
                    return `<kp>${match[1].trim()} HP ${match[2]} (${match[3]}â†’${match[4]})`;
                }
                // ç®€åŒ–æ ¼å¼
                const simpleMatch = text.match(/ğŸ’¥\s*(.+)/);
                if (simpleMatch) {
                    return `<kp>${simpleMatch[1].replace(/\[.*?\]/g, '').trim()}`;
                }
            }
            
            // === é‡ä¼¤çŠ¶æ€ (æ±‰åŒ–) ===
            if (text.includes('MAJOR WOUND')) {
                // å°è¯•æå–è§’è‰²å
                const match = text.match(/(.+?)\s*MAJOR WOUND/);
                if (match) {
                    return `<kp>${match[1].trim()} å—åˆ°äº†é‡ä¼¤ï¼`;
                }
                return '<kp>å—åˆ°äº†é‡ä¼¤ï¼';
            }
            if (text.includes('ğŸ’€') && text.includes('é‡ä¼¤')) {
                return `<kp>${text.replace(/ğŸ’€/g, '').trim()}`;
            }
            
            // === æ¿’æ­»çŠ¶æ€ ===
            if (text.includes('ğŸ’€') && (text.includes('æ¿’æ­»') || text.includes('DYING'))) {
                return `<kp>${text.replace(/ğŸ’€/g, '').replace(/DYING/g, 'æ¿’æ­»').trim()}`;
            }
            
            // === åå‡» ===
            if (text.includes('COUNTER') || text.includes('åå‡»')) {
                const cleanText = text.replace(/[âš”ï¸ğŸ²]/g, '').replace(/COUNTER/g, 'åå‡»').trim();
                return `<kp>${cleanText}`;
            }
            
            // === å‘½ä¸­ç»Ÿè®¡ ===
            if (text.startsWith('âœ…') && (text.includes('å‘½ä¸­') || text.includes('HIT'))) {
                const match = text.match(/å‘½ä¸­\s*(\d+)\s*å‘/);
                if (match) {
                    return `<kp>å‘½ä¸­ ${match[1]} å‘ï¼`;
                }
                return `<kp>${text.replace(/âœ…/g, '').trim()}`;
            }
            
            // === å…¨éƒ¨è½ç©º ===
            if (text.includes('å…¨éƒ¨è½ç©º') || text.includes('å…¨éƒ¨æœªå‘½ä¸­')) {
                return '<kp>å…¨éƒ¨æœªå‘½ä¸­ï¼';
            }
            
            // === æˆåŠŸæç¤º ===
            if (text.startsWith('âœ…')) {
                return `<kp>${text.replace(/âœ…/g, '').trim()}`;
            }
            
            // === KPæ“ä½œ ===
            if (text.startsWith('ğŸ‘‘')) {
                return `<kp>${text.replace(/ğŸ‘‘/g, '').trim()}`;
            }
            
            // === å¤šé‡æ”»å‡»ç»§ç»­è¡ŒåŠ¨ ===
            if (text.includes('ç»§ç»­è¡ŒåŠ¨')) {
                const match = text.match(/(.+?)\s*ç»§ç»­è¡ŒåŠ¨\s*\((\d+)\/(\d+)\)/);
                if (match) {
                    currentActor = match[1].replace(/âš”ï¸/g, '').trim();
                    return `<kp>${currentActor} ç»§ç»­è¡ŒåŠ¨ (${match[2]}/${match[3]})`;
                }
            }
            
            // === è¯¯ä¼¤ ===
            if (text.includes('å¤§å¤±è´¥') && text.includes('è¯¯ä¼¤')) {
                return `<kp>${text.replace(/ğŸ’€/g, '').trim()}`;
            }
            
            // === è¿å°„å‘½ä¸­ç»Ÿè®¡ ===
            if (text.includes('è¿å°„å‘½ä¸­') && text.includes('å‘')) {
                const match = text.match(/è¿å°„å‘½ä¸­\s*(\d+)\s*å‘.*?(\d+)\s*ç‚¹ä¼¤å®³/);
                if (match) {
                    return `<kp>å‘½ä¸­ ${match[1]} å‘ï¼é€ æˆ ${match[2]} ç‚¹ä¼¤å®³`;
                }
                return `<kp>${text.replace(/âœ…/g, '').trim()}`;
            }
            
            // === å…¨è‡ªåŠ¨ä¼¤å®³ ===
            if (text.includes('å…¨è‡ªåŠ¨') && text.includes('ç‚¹ä¼¤å®³')) {
                const match = text.match(/å…¨è‡ªåŠ¨.*?(\d+)\s*ç‚¹ä¼¤å®³/);
                if (match) {
                    return `<kp>å…¨è‡ªåŠ¨é€ æˆ ${match[1]} ç‚¹ä¼¤å®³`;
                }
            }
            
            // === å…¨è‡ªåŠ¨æ— æ•ˆæœ ===
            if (text.includes('å…¨è‡ªåŠ¨å°„å‡»æ— æ•ˆæœ')) {
                return '<kp>å…¨è‡ªåŠ¨å°„å‡»æ— æ•ˆæœ';
            }
            
            // === æ˜è¿·/å€’ä¸‹ ===
            if (text.includes('ğŸ’«') && (text.includes('æ˜è¿·') || text.includes('å€’ä¸‹'))) {
                return `<kp>${text.replace(/ğŸ’«/g, '').trim()}`;
            }
            
            // é»˜è®¤ï¼šè¿”å›nullï¼Œç¨åè¿‡æ»¤
            return null;
        };
        
        // ç¬¬ä¸€éï¼šè½¬æ¢æ‰€æœ‰è¡Œ
        const convertedLines = [];
        logs.forEach((log, index) => {
            const converted = convertLine(log.text, index, logs);
            if (converted !== null) {
                convertedLines.push(converted);
            }
        });
        
        // ç¬¬äºŒéï¼šå®‰å…¨æ¸…ç† - åªä¿ç•™ <kp> å’Œ ã€éª°å­ã€‘ å¼€å¤´çš„è¡Œ
        const finalLines = convertedLines.filter(line => {
            return line.startsWith('<kp>') || line.startsWith('ã€éª°å­ã€‘');
        });
        
        // è¾“å‡º
        const fullText = finalLines.join('\n');
        const blob = new Blob([fullText], { type: 'text/plain;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `COC7_æ´»å­—å¼•æ“_${new Date().toLocaleDateString().replace(/\//g, '-')}.txt`;
        a.click();
        URL.revokeObjectURL(url);
    };

    const addLog = (text, type = 'info') => {
        setLogs(prev => [...prev, { id: Date.now(), text, type, time: new Date().toLocaleTimeString().slice(0, 8) }]);
    };

    const combatOrder = useMemo(() => [...characters].sort((a, b) => {
        // åŸºç¡€å…ˆæ”» = DEXï¼Œæ¶æª+50
        let aDex = a.hasGunReady ? a.dex + 50 : a.dex;
        let bDex = b.hasGunReady ? b.dex + 50 : b.dex;
        
        // å¿«æ‹”å¤©èµ‹ (é€šä¿—æ¨¡å¼): æ¶æªçŠ¶æ€é¢å¤–+10
        if (hpMultiplier === 2) {
            if (a.hasGunReady && (a.talents || []).includes('quick_draw')) aDex += 10;
            if (b.hasGunReady && (b.talents || []).includes('quick_draw')) bDex += 10;
        }
        
        return bDex !== aDex ? bDex - aDex : b.fight - a.fight;
    }), [characters, hpMultiplier]);

    const currentActor = useMemo(() => combatOrder[turn.index % combatOrder.length], [combatOrder, turn.index]);

    const updateChar = (id, updates) => {
        setCharacters(prev => prev.map(c => {
            if (c.id !== id) return c;
            const updated = { ...c, ...updates };
            const derived = calcDerived(updated, hpMultiplier);
            return { ...updated, ...derived, hp: Math.min(updated.hp ?? derived.maxHp, derived.maxHp) };
        }));
    };

    const startNewRound = () => {
        setCharacters(prev => prev.map(c => ({ 
            ...c, 
            attacksLeft: c.attacksPerRound || 1,  // é‡ç½®å‰©ä½™æ”»å‡»æ¬¡æ•°
            status: { ...c.status, defenseUsedThisRound: false, madChargeUsed: false } // é‡ç½®é˜²å¾¡å’Œç–¯ç‹‚å†²é”‹çŠ¶æ€
        })));
    };

    // æ¸…ç©ºé‡ç½®æ‰€æœ‰æ•°æ®
    const resetAll = () => {
        if (!confirm('ç¡®è®¤æ¸…ç©ºæ‰€æœ‰æ•°æ®ï¼Ÿè§’è‰²ã€æ—¥å¿—ã€å›åˆè®°å½•éƒ½å°†è¢«åˆ é™¤')) return;
        setCharacters([]);
        setLogs([]);
        setTurn({ round: 1, index: 0 });
        setHistory([]);
        setView('setup');
    };

    return (
        <div className="main-layout font-sans bg-canvas">
            <header className="h-14 border-b-2 border-black flex items-center justify-between px-4 bg-white shrink-0 z-30 relative">
                <div className="flex items-center gap-3">
                    <div className="w-10 h-10 bg-black flex items-center justify-center text-white font-black text-sm tracking-tight font-mono">C7</div>
                    <div className="flex flex-col">
                        <h1 className="font-black text-sm leading-none text-black tracking-tight">COC7 æˆ˜æ–—æ§åˆ¶å°</h1>
                        <span className="text-[10px] text-gray-300 font-mono">v4.3.6</span>
                    </div>
                </div>
                <div className="flex items-center gap-2">
                    {view === 'setup' && (
                        logs.length > 0 ? (
                            <div className="flex gap-2">
                                <button onClick={() => { setView('combat'); }} title="ç»§ç»­ä¹‹å‰çš„æˆ˜æ–—" className="bg-gray-700 text-white px-4 py-2 text-xs font-bold tracking-wide hover:bg-gray-800 transition-colors border-2 border-gray-700">â–¶ï¸ ç»§ç»­æˆ˜æ–—</button>
                                <button onClick={() => { 
                                    if(!confirm('ç¡®è®¤å¼€å§‹æ–°æˆ˜æ–—ï¼Ÿå°†æ¸…ç©ºæ—¥å¿—å’Œå›åˆè®°å½•')) return;
                                    setLogs([]); 
                                    setTurn({ round: 1, index: 0 }); 
                                    setHistory([]);
                                    // é‡ç½®è§’è‰²HPå’ŒçŠ¶æ€
                                    setCharacters(prev => prev.map(c => {
                                        const derived = calcDerived(c, hpMultiplier);
                                        return { ...c, hp: derived.maxHp, attacksLeft: c.attacksPerRound || 1, status: { majorWound: false, dying: false, unconscious: false, prone: false, defenseUsedThisRound: false, grappled: false, grappling: false } };
                                    }));
                                    setView('combat'); 
                                    addLog("ğŸ æˆ˜æ–—å¼€å§‹", "system"); 
                                }} title="æ¸…ç©ºè®°å½•å¼€å§‹æ–°æˆ˜æ–—" className="bg-black text-white px-4 py-2 text-xs font-bold tracking-wide hover:bg-gray-900 transition-colors border-2 border-black">ğŸ†• æ–°æˆ˜æ–—</button>
                            </div>
                        ) : (
                            <button onClick={() => { if(characters.length<1) return alert("è‡³å°‘æ·»åŠ ä¸€ä¸ªè§’è‰²"); setView('combat'); addLog("ğŸ æˆ˜æ–—å¼€å§‹", "system"); }} title="å¼€å§‹æˆ˜æ–—" className="bg-black text-white px-5 py-2 text-xs font-black tracking-[0.1em] hover:bg-gray-900 transition-colors border-2 border-black shadow-hard-sm hover:shadow-none hover:translate-x-[2px] hover:translate-y-[2px]">âš”ï¸ å¼€ å§‹ æˆ˜ æ–—</button>
                        )
                    )}
                    {view === 'combat' && (
                        <>
                            <span className="font-mono text-xs bg-black text-white px-4 py-2 font-bold">ç¬¬ {turn.round} è½®</span>
                            <button onClick={() => setKpPanelOpen(!kpPanelOpen)} title="æ‰“å¼€/å…³é—­KPæ§åˆ¶å°" className={`font-bold text-xs px-3 py-2 border-2 transition-colors ${kpPanelOpen ? 'bg-red-600 text-white border-red-600' : 'border-black hover:bg-black hover:text-white'}`}>ğŸ‘‘ KP</button>
                            <button onClick={undo} disabled={history.length === 0} title="æ’¤é”€ä¸Šä¸€æ­¥æ“ä½œ" className="font-bold text-xs px-3 py-2 border-2 border-black disabled:opacity-30 hover:bg-black hover:text-white transition-colors">â†©</button>
                            <button onClick={() => {
                                if(!confirm('ç¡®è®¤ç»“æŸæˆ˜æ–—ï¼Ÿ')) return;
                                addLog("ğŸ æˆ˜æ–—ç»“æŸ", "system");
                                setView('setup');
                            }} title="ç»“æŸæˆ˜æ–—" className="font-bold text-xs px-3 py-2 border-2 border-red-600 text-red-600 hover:bg-red-600 hover:text-white transition-colors">ğŸ ç»“æŸ</button>
                            <button onClick={() => setView('setup')} title="ç¼–è¾‘è§’è‰²" className="text-xs font-bold text-gray-400 hover:text-black ml-1">ç¼–è¾‘</button>
                        </>
                    )}
                </div>
            </header>

            <main className="flex-1 overflow-hidden relative">
                {view === 'setup' ? (
                    <SetupModule 
                        characters={characters} 
                        setCharacters={setCharacters} 
                        updateChar={updateChar} 
                        openTutorial={() => setShowTutorialForce(true)}
                        exportSave={exportSave}
                        importSave={importSave}
                        exportLogsToTxt={exportLogsToTxt}
                        logs={logs}
                        hpMultiplier={hpMultiplier}
                        setHpMultiplier={setHpMultiplier}
                        resetAll={resetAll}
                    />
                ) : (
                    <CombatModule 
                        characters={characters} 
                        combatOrder={combatOrder}
                        updateChar={updateChar}
                        turn={turn} 
                        setTurn={setTurn}
                        logs={logs}
                        addLog={addLog}
                        currentActor={currentActor}
                        startNewRound={startNewRound}
                        saveToHistory={saveToHistory}
                        logContainerRef={logContainerRef}
                        hpMultiplier={hpMultiplier}
                    />
                )}
                
                <KPControlPanel 
                    isOpen={kpPanelOpen} 
                    onClose={() => setKpPanelOpen(false)}
                    characters={characters}
                    updateChar={updateChar}
                    addLog={addLog}
                    currentActor={currentActor}
                    hpMultiplier={hpMultiplier}
                    showToast={showToast}
                />
            </main>

            {/* æ–°æ‰‹å¼•å¯¼ç»„ä»¶ */}
            <OnboardingTutorial 
                forceOpen={showTutorialForce} 
                onCloseForce={() => setShowTutorialForce(false)}
            />
            
            {/* v4.3.6 Toast æç¤º */}
            {toasts.map(toast => (
                <Toast 
                    key={toast.id}
                    message={toast.message}
                    type={toast.type}
                    onClose={() => removeToast(toast.id)}
                />
            ))}
        </div>
    );
}

// ... (KPControlPanel logic kept largely the same, mostly Label updates) ...
function KPControlPanel({ isOpen, onClose, characters, updateChar, addLog, currentActor, hpMultiplier, showToast }) {
    const [selectedCharId, setSelectedCharId] = useState('');
    const [editMode, setEditMode] = useState('stats');
    const [customWeaponName, setCustomWeaponName] = useState('');
    const [customWeaponDamage, setCustomWeaponDamage] = useState('1D6');
    const [customWeaponType, setCustomWeaponType] = useState('melee');
    const [customWeaponImpale, setCustomWeaponImpale] = useState(false);
    const [customWeaponRange, setCustomWeaponRange] = useState(10);
    const [customWeaponAmmo, setCustomWeaponAmmo] = useState(6);
    const [customWeaponMalfunction, setCustomWeaponMalfunction] = useState(100);
    
    // æŠ€èƒ½æ£€å®šçŠ¶æ€
    const [selectedSkill, setSelectedSkill] = useState('');
    const [skillValue, setSkillValue] = useState(50);
    const [skillModifier, setSkillModifier] = useState(0); // v4.3.6: æ•°å­—æ ¼å¼

    const selectedChar = characters.find(c => c.id === selectedCharId) || currentActor;

    useEffect(() => {
        if (isOpen && !selectedCharId && currentActor) setSelectedCharId(currentActor.id);
    }, [isOpen, currentActor, selectedCharId]);

    const addCustomWeapon = () => {
        if (!selectedChar || !customWeaponName.trim()) return;
        const newWeapon = {
            id: generateId(), name: customWeaponName.trim(), damage: customWeaponDamage,
            type: customWeaponType, impale: customWeaponImpale,
            range: customWeaponType === 'ranged' ? customWeaponRange : 1,
            ammo: customWeaponType === 'ranged' ? customWeaponAmmo : undefined, 
            maxAmmo: customWeaponType === 'ranged' ? customWeaponAmmo : undefined, 
            malfunction: customWeaponType === 'ranged' ? customWeaponMalfunction : 100,
        };
        if (customWeaponType === 'melee') updateChar(selectedChar.id, { meleeWeapon: newWeapon });
        else updateChar(selectedChar.id, { rangedWeapon: newWeapon });
        addLog(`ğŸ‘‘ KPä¸º${selectedChar.name}æ·»åŠ æ­¦å™¨: ${newWeapon.name}`, 'system');
        setCustomWeaponName('');
    };

    const quickActions = {
        heal: (amount) => {
            if (selectedChar) {
                const newHp = Math.min(selectedChar.maxHp, selectedChar.hp + amount);
                updateChar(selectedChar.id, { hp: newHp });
                addLog(`ğŸ‘‘ +${amount}HP â†’ ${selectedChar.name}`, 'system');
                showToast && showToast(`âœ… ${selectedChar.name} +${amount} HP`, 'success');
            }
        },
        damage: (amount) => {
            if (selectedChar) {
                const newHp = Math.max(0, selectedChar.hp - amount);
                updateChar(selectedChar.id, { hp: newHp });
                addLog(`ğŸ‘‘ -${amount}HP â†’ ${selectedChar.name}`, 'damage');
                showToast && showToast(`ğŸ’¥ ${selectedChar.name} -${amount} HP`, 'damage');
            }
        },
        // è‡ªç„¶æ¢å¤ (æ ‡å‡†: 1HP/å¤©, é€šä¿—: 2HP/å¤©, å¿«é€Ÿæ¢å¤å¤©èµ‹: +2HP)
        naturalRecovery: () => {
            if (selectedChar) {
                let baseHeal = hpMultiplier === 2 ? 2 : 1; // é€šä¿—æ¨¡å¼ç¿»å€
                
                // å¿«é€Ÿæ¢å¤å¤©èµ‹ (é€šä¿—æ¨¡å¼): é¢å¤–+2 HP
                const hasQuickHealer = hpMultiplier === 2 && (selectedChar.talents || []).includes('quick_healer');
                if (hasQuickHealer) baseHeal += 2;
                
                const newHp = Math.min(selectedChar.maxHp, selectedChar.hp + baseHeal);
                updateChar(selectedChar.id, { hp: newHp });
                const talentLabel = hasQuickHealer ? '[å¿«é€Ÿæ¢å¤]' : '';
                const modeLabel = hpMultiplier === 2 ? '(è¿…é€Ÿæ¢å¤)' : '';
                addLog(`ğŸŒ™ ${selectedChar.name} è‡ªç„¶æ¢å¤ +${baseHeal} HP ${modeLabel} ${talentLabel}`, 'success');
                showToast && showToast(`ğŸŒ™ ${selectedChar.name} +${baseHeal} HP`, 'success');
            }
        },
        // é€šç”¨æŠ€èƒ½æ£€å®š
        skillCheck: (skillId, value, modifier) => {
            if (!selectedChar) return;
            
            // æ£€æŸ¥å¤©èµ‹æ˜¯å¦ç»™è¯¥æŠ€èƒ½å¥–åŠ±éª°
            let effectiveModifier = modifier;
            let talentBonus = '';
            if (hpMultiplier === 2 && selectedChar.talents) {
                const matchingTalent = PULP_TALENTS.find(t => 
                    t.effect === 'skill_bonus' && 
                    t.skills && 
                    t.skills.includes(skillId) &&
                    selectedChar.talents.includes(t.id)
                );
                if (matchingTalent) {
                    effectiveModifier = modifier + 1; // å¤©èµ‹æä¾›+1å¥–åŠ±éª°
                    talentBonus = ` [${matchingTalent.name}]`;
                }
            }
            
            // æ‰§è¡Œæ£€å®š
            const result = rollWithModifier(effectiveModifier);
            const skillName = SKILL_CHECKS.find(s => s.id === skillId)?.name || skillId;
            const successLevel = calculateSuccessLevel(result.result, value);
            const levelLabel = getSuccessLabel(successLevel);
            
            // è¾“å‡ºæ—¥å¿—
            const modLabel = effectiveModifier > 0 ? `${effectiveModifier}ä¸ªå¥–åŠ±éª°` : effectiveModifier < 0 ? `${Math.abs(effectiveModifier)}ä¸ªæƒ©ç½šéª°` : 'æ ‡å‡†éª°';
            if (effectiveModifier !== 0) {
                addLog(`ğŸ² ${modLabel}: [${result.rolls.join(', ')}] â†’ ${result.result}`, 'roll');
            } else {
                addLog(`ğŸ² æ ‡å‡†éª°: ${result.result}`, 'roll');
            }
            addLog(`ğŸ“‹ ${selectedChar.name} ${skillName}æ£€å®š [${result.result}/${value}] ${levelLabel}${talentBonus}`, 
                successLevel > 0 ? 'success' : 'damage');
            // Toastæ˜¾ç¤ºæ£€å®šç»“æœ
            showToast && showToast(`ğŸ² ${selectedChar.name} ${skillName}: ${levelLabel}`, successLevel > 0 ? 'success' : 'error');
        },
        // å¹¸è¿æ¢å¤ (å¹¸è¿å„¿å¤©èµ‹)
        luckRecovery: () => {
            if (!selectedChar || hpMultiplier !== 2) return;
            const hasLucky = (selectedChar.talents || []).includes('lucky');
            if (!hasLucky) {
                addLog(`âŒ ${selectedChar.name} æ²¡æœ‰å¹¸è¿å„¿å¤©èµ‹`, 'system');
                showToast && showToast(`âŒ æ²¡æœ‰å¹¸è¿å„¿å¤©èµ‹`, 'error');
                return;
            }
            const recovery = rollDice('1D10');
            const newLuck = Math.min(selectedChar.maxLuck || 99, (selectedChar.luck || 0) + recovery.total);
            updateChar(selectedChar.id, { luck: newLuck });
            addLog(`ğŸ€ ${selectedChar.name} [å¹¸è¿å„¿] æ¢å¤ ${recovery.total} å¹¸è¿ (${selectedChar.luck}â†’${newLuck})`, 'success');
            showToast && showToast(`ğŸ€ ${selectedChar.name} +${recovery.total} å¹¸è¿`, 'success');
        },
    };

    return (
        <div className={`kp-panel ${isOpen ? 'open' : ''}`}>
            <div className="p-4 bg-red-600 text-white flex justify-between items-center">
                <h2 className="font-black tracking-[0.1em] text-sm">âš ï¸ ä¸» æŒ äºº æ§ åˆ¶ å°</h2>
                <button onClick={onClose} title="å…³é—­KPé¢æ¿" className="w-8 h-8 flex items-center justify-center text-xl leading-none opacity-80 hover:opacity-100 hover:bg-red-700 transition-colors">Ã—</button>
            </div>

            <div className="p-5">
                <div className="mb-6">
                    <div className="flex items-baseline gap-2 mb-2">
                        <span className="text-xs font-black text-gray-500">é€‰æ‹©æ“ä½œå¯¹è±¡</span>
                    </div>
                    <select 
                        value={selectedCharId} 
                        onChange={(e) => setSelectedCharId(e.target.value)}
                        className="w-full border-2 border-gray-300 px-3 py-3 text-sm font-bold focus:border-black focus:outline-none"
                    >
                        {characters.map(c => (
                            <option key={c.id} value={c.id}>{c.name} ({c.type === 'player' ? 'è°ƒæŸ¥å‘˜' : 'æ•Œäºº'})</option>
                        ))}
                    </select>
                </div>

                {selectedChar && (
                    <>
                        <div className="flex border-b-2 border-black mb-6">
                            {['stats', 'weapons', 'check'].map(mode => (
                                <button
                                    key={mode}
                                    onClick={() => setEditMode(mode)}
                                    className={`flex-1 py-3 text-xs font-bold tracking-wide transition-colors ${editMode === mode ? 'bg-black text-white' : 'bg-gray-100 text-gray-500 hover:bg-gray-200'}`}
                                >
                                    {mode === 'stats' ? 'å±æ€§' : mode === 'weapons' ? 'æ­¦å™¨' : 'æ£€å®š'}
                                </button>
                            ))}
                        </div>

                        {editMode === 'stats' && (
                            <div className="space-y-6">
                                <div className="grid grid-cols-4 gap-2">
                                    <button onClick={() => quickActions.heal(1)} className="p-2 border-2 border-gray-300 hover:border-black text-xs font-bold">+1</button>
                                    <button onClick={() => quickActions.heal(5)} className="p-2 border-2 border-gray-300 hover:border-black text-xs font-bold">+5</button>
                                    <button onClick={() => quickActions.damage(5)} className="p-2 border-2 border-red-300 bg-red-50 text-red-700 text-xs font-bold hover:bg-red-100">-5</button>
                                    <button onClick={() => quickActions.damage(10)} className="p-2 border-2 border-red-300 bg-red-50 text-red-700 text-xs font-bold hover:bg-red-100">-10</button>
                                </div>
                                
                                {/* è‡ªç„¶æ¢å¤æŒ‰é’® */}
                                <button 
                                    onClick={quickActions.naturalRecovery}
                                    className={`w-full p-3 text-xs font-bold border-2 ${hpMultiplier === 2 ? 'bg-purple-50 border-purple-300 text-purple-700 hover:bg-purple-100' : 'bg-blue-50 border-blue-300 text-blue-700 hover:bg-blue-100'}`}
                                >
                                    ğŸŒ™ è‡ªç„¶æ¢å¤ (+{hpMultiplier === 2 ? '2' : '1'} HP/å¤©)
                                    {hpMultiplier === 2 && <span className="ml-1 text-purple-500">[è¿…é€Ÿæ¢å¤]</span>}
                                </button>
                                
                                <div>
                                    <div className="flex items-baseline gap-2 mb-2">
                                        <span className="text-xs font-black text-gray-500">çŠ¶æ€</span>
                                    </div>
                                    <StatusGrid status={selectedChar.status} onChange={(status) => updateChar(selectedChar.id, { status })} />
                                </div>

                                <div className="grid grid-cols-2 gap-3">
                                    <SmartInput label="å½“å‰ç”Ÿå‘½" sublabel="HP" value={selectedChar.hp} onChange={(val) => updateChar(selectedChar.id, { hp: val })} />
                                    <SmartInput label="æœ€å¤§ç”Ÿå‘½" sublabel="MAX" value={selectedChar.maxHp} onChange={(val) => updateChar(selectedChar.id, { maxHp: val })} />
                                </div>
                                
                                <div className="grid grid-cols-3 gap-3">
                                    <SmartInput label="åŠ›é‡" sublabel="STR" value={selectedChar.str} onChange={(val) => updateChar(selectedChar.id, { str: val })} />
                                    <SmartInput label="ä½“è´¨" sublabel="CON" value={selectedChar.con} onChange={(val) => updateChar(selectedChar.id, { con: val })} />
                                    <SmartInput label="ä½“å‹" sublabel="SIZ" value={selectedChar.siz} onChange={(val) => updateChar(selectedChar.id, { siz: val })} />
                                    <SmartInput label="æ•æ·" sublabel="DEX" value={selectedChar.dex} onChange={(val) => updateChar(selectedChar.id, { dex: val })} />
                                    <SmartInput label="å¤–è²Œ" sublabel="APP" value={selectedChar.app || 50} onChange={(val) => updateChar(selectedChar.id, { app: val })} />
                                    <SmartInput label="æ„å¿—" sublabel="POW" value={selectedChar.pow || 50} onChange={(val) => updateChar(selectedChar.id, { pow: val })} />
                                </div>
                                
                                <div className="grid grid-cols-4 gap-3 border-t-2 border-dashed border-gray-300 pt-4">
                                    <SmartInput label="æ–—æ®´" sublabel="FIGHT" value={selectedChar.fight} onChange={(val) => updateChar(selectedChar.id, { fight: val })} />
                                    <SmartInput label="é—ªé¿" sublabel="DODGE" value={selectedChar.dodge} onChange={(val) => updateChar(selectedChar.id, { dodge: val })} />
                                    <SmartInput label="å°„å‡»" sublabel="FIREARMS" value={selectedChar.firearms} onChange={(val) => updateChar(selectedChar.id, { firearms: val })} />
                                    <SmartInput label="æŠ¤ç”²" sublabel="ARMOR" value={selectedChar.armorValue || 0} onChange={(val) => updateChar(selectedChar.id, { armorValue: val })} />
                                </div>
                                
                                <div className="grid grid-cols-2 gap-3 border-t-2 border-dashed border-gray-300 pt-4">
                                    <SmartInput label="æ€¥æ•‘" sublabel="FIRST AID" value={selectedChar.firstAid || 30} onChange={(val) => updateChar(selectedChar.id, { firstAid: val })} />
                                    <SmartInput label="åŒ»å­¦" sublabel="MEDICINE" value={selectedChar.medicine || 5} onChange={(val) => updateChar(selectedChar.id, { medicine: val })} />
                                </div>
                                
                                <div className="grid grid-cols-2 gap-3 border-t-2 border-dashed border-gray-300 pt-4">
                                    <SmartInput 
                                        label="ğŸ‘¹ å¤šé‡æ”»å‡»" 
                                        sublabel="ATK/RND"
                                        value={selectedChar.attacksPerRound || 1} 
                                        onChange={(val) => updateChar(selectedChar.id, { 
                                            attacksPerRound: Math.max(1, val), 
                                            attacksLeft: Math.max(1, val) 
                                        })} 
                                    />
                                    <div className="flex flex-col justify-end">
                                        <div className="text-[10px] text-gray-500 mb-1">å‰©ä½™æ”»å‡» Left</div>
                                        <div className="font-mono font-bold text-lg">{selectedChar.attacksLeft || 1} / {selectedChar.attacksPerRound || 1}</div>
                                    </div>
                                </div>
                            </div>
                        )}

                        {editMode === 'weapons' && (
                           // ... Simplified Weapon View ...
                           <div className="space-y-6">
                                {/* Presets */}
                                <div>
                                    <div className="label mb-2">é¢„è®¾æ­¦å™¨ Weapon Presets</div>
                                    <select 
                                        onChange={(e) => {
                                            const w = WEAPON_PRESETS.find(w => w.name === e.target.value);
                                            if (w) {
                                                if (w.type === 'melee') updateChar(selectedChar.id, { meleeWeapon: {...w} });
                                                else updateChar(selectedChar.id, { rangedWeapon: {...w} });
                                                addLog(`ğŸ‘‘ ${selectedChar.name} â†’ ${w.name}`, 'system');
                                                e.target.value = '';
                                            }
                                        }}
                                        className="w-full border border-gray-300 p-2 text-sm"
                                    >
                                        <option value="">-- é€‰æ‹©é¢„è®¾ --</option>
                                        <optgroup label="è¿‘æˆ˜ MELEE">{MELEE_WEAPONS.map(w => <option key={w.name} value={w.name}>{w.name}</option>)}</optgroup>
                                        <optgroup label="å°„å‡» RANGED">{RANGED_WEAPONS.map(w => <option key={w.name} value={w.name}>{w.name}</option>)}</optgroup>
                                    </select>
                                </div>
                                {/* Custom Weapon Form simplified */}
                                <div className="border-t border-dashed border-gray-300 pt-4">
                                     <div className="label mb-2">æ·»åŠ è‡ªå®šä¹‰æ­¦å™¨ Custom Weapon</div>
                                     <div className="space-y-2">
                                        <input type="text" placeholder="åç§° Name" value={customWeaponName} onChange={e => setCustomWeaponName(e.target.value)} className="w-full border border-gray-300 p-2 text-sm" />
                                        <input type="text" placeholder="ä¼¤å®³ Damage (e.g. 1D6)" value={customWeaponDamage} onChange={e => setCustomWeaponDamage(e.target.value)} className="w-full border border-gray-300 p-2 text-sm font-mono" />
                                        <div className="flex gap-2">
                                            <select value={customWeaponType} onChange={e => setCustomWeaponType(e.target.value)} className="flex-1 border border-gray-300 p-2 text-sm">
                                                <option value="melee">è¿‘æˆ˜ Melee</option>
                                                <option value="ranged">å°„å‡» Ranged</option>
                                            </select>
                                            <label className="flex items-center gap-1 text-xs">
                                                <input type="checkbox" checked={customWeaponImpale} onChange={e => setCustomWeaponImpale(e.target.checked)} />
                                                è´¯ç©¿
                                            </label>
                                        </div>
                                        {customWeaponType === 'ranged' && (
                                            <div className="grid grid-cols-3 gap-2 p-2 bg-gray-50 border border-gray-200">
                                                <div>
                                                    <div className="text-[10px] text-gray-500 mb-1">å¼¹è¯ Ammo</div>
                                                    <input type="number" value={customWeaponAmmo} 
                                                        onChange={e => setCustomWeaponAmmo(parseInt(e.target.value) || 6)}
                                                        className="w-full border border-gray-300 p-1.5 text-sm font-mono" />
                                                </div>
                                                <div>
                                                    <div className="text-[10px] text-gray-500 mb-1">å°„ç¨‹ Range</div>
                                                    <input type="number" value={customWeaponRange} 
                                                        onChange={e => setCustomWeaponRange(parseInt(e.target.value) || 10)}
                                                        className="w-full border border-gray-300 p-1.5 text-sm font-mono" />
                                                </div>
                                                <div>
                                                    <div className="text-[10px] text-gray-500 mb-1">æ•…éšœ Malf</div>
                                                    <input type="number" value={customWeaponMalfunction} 
                                                        onChange={e => setCustomWeaponMalfunction(parseInt(e.target.value) || 100)}
                                                        className="w-full border border-gray-300 p-1.5 text-sm font-mono" />
                                                </div>
                                            </div>
                                        )}
                                        <button onClick={addCustomWeapon} className="w-full bg-black text-white py-2 text-xs font-bold uppercase">æ·»åŠ æ­¦å™¨ ADD WEAPON</button>
                                     </div>
                                </div>
                           </div>
                        )}
                        
                        {editMode === 'check' && (
                            <div className="space-y-6">
                                <div className="text-xs font-black text-gray-500 mb-2">ğŸ² é€šç”¨æŠ€èƒ½æ£€å®š</div>
                                
                                {/* æŠ€èƒ½é€‰æ‹© */}
                                <div>
                                    <div className="label mb-2">é€‰æ‹©æŠ€èƒ½ Select Skill</div>
                                    <select 
                                        value={selectedSkill}
                                        onChange={(e) => {
                                            setSelectedSkill(e.target.value);
                                            const skill = SKILL_CHECKS.find(s => s.id === e.target.value);
                                            if (skill) {
                                                // æ ¹æ®æŠ€èƒ½ç±»å‹è®¾ç½®é»˜è®¤å€¼
                                                if (skill.id === 'con' || skill.id === 'con_poison' || skill.id === 'con_alcohol') {
                                                    setSkillValue(selectedChar?.con || 50);
                                                } else if (skill.id === 'pow_resist') {
                                                    setSkillValue(selectedChar?.pow || 50);
                                                } else if (skill.id === 'sanity') {
                                                    setSkillValue(selectedChar?.san || 50);
                                                } else {
                                                    setSkillValue(skill.base);
                                                }
                                            }
                                        }}
                                        className="w-full border-2 border-gray-300 px-3 py-2 text-sm focus:border-black focus:outline-none"
                                    >
                                        <option value="">-- é€‰æ‹©æŠ€èƒ½ --</option>
                                        <optgroup label="å±æ€§æ£€å®š">
                                            <option value="con">ä½“è´¨ CON</option>
                                            <option value="con_poison">æŠµæŠ—æ¯’ç´ </option>
                                            <option value="con_alcohol">æŠµæŠ—é…’ç²¾</option>
                                            <option value="pow_resist">POWå¯¹æŠ—</option>
                                            <option value="sanity">ç†æ™º SAN</option>
                                        </optgroup>
                                        <optgroup label="æ„ŸçŸ¥æŠ€èƒ½">
                                            <option value="spot_hidden">ä¾¦æŸ¥</option>
                                            <option value="listen">è†å¬</option>
                                        </optgroup>
                                        <optgroup label="ç¤¾äº¤æŠ€èƒ½">
                                            <option value="fast_talk">è¯æœ¯</option>
                                            <option value="persuade">è¯´æœ</option>
                                        </optgroup>
                                        <optgroup label="ä½“èƒ½æŠ€èƒ½">
                                            <option value="climb">æ”€çˆ¬</option>
                                            <option value="swim">æ¸¸æ³³</option>
                                            <option value="jump">è·³è·ƒ</option>
                                            <option value="stealth">æ½œè¡Œ</option>
                                        </optgroup>
                                        <optgroup label="ä¸“ä¸šæŠ€èƒ½">
                                            <option value="mechanical_repair">æœºæ¢°ç»´ä¿®</option>
                                            <option value="electrical_repair">ç”µæ°”ç»´ä¿®</option>
                                            <option value="locksmith">é”åŒ </option>
                                            <option value="drive">é©¾é©¶</option>
                                        </optgroup>
                                    </select>
                                </div>
                                
                                {/* æŠ€èƒ½å€¼è¾“å…¥ */}
                                <div className="grid grid-cols-2 gap-3">
                                    <div>
                                        <div className="label mb-1">æŠ€èƒ½å€¼</div>
                                        <input 
                                            type="number" 
                                            value={skillValue}
                                            onChange={(e) => setSkillValue(parseInt(e.target.value) || 0)}
                                            className="w-full border-2 border-gray-300 px-3 py-2 text-lg font-mono font-bold text-center focus:border-black focus:outline-none"
                                        />
                                    </div>
                                    <div>
                                        <div className="label mb-1">å›°éš¾/æéš¾</div>
                                        <div className="flex gap-2 text-center">
                                            <div className="flex-1 p-2 bg-gray-100 text-xs">
                                                <div className="font-bold">å›°éš¾</div>
                                                <div className="font-mono">{Math.floor(skillValue / 2)}</div>
                                            </div>
                                            <div className="flex-1 p-2 bg-gray-100 text-xs">
                                                <div className="font-bold">æéš¾</div>
                                                <div className="font-mono">{Math.floor(skillValue / 5)}</div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                
                                {/* éª°å­ä¿®æ­£ */}
                                <DiceModifierSelector value={skillModifier} onChange={setSkillModifier} />
                                
                                {/* å¤©èµ‹åŠ æˆæç¤º */}
                                {hpMultiplier === 2 && selectedSkill && (() => {
                                    const matchingTalent = PULP_TALENTS.find(t => 
                                        t.effect === 'skill_bonus' && 
                                        t.skills && 
                                        t.skills.includes(selectedSkill) &&
                                        (selectedChar?.talents || []).includes(t.id)
                                    );
                                    return matchingTalent ? (
                                        <div className="p-3 bg-yellow-50 border border-yellow-300 text-yellow-800 text-xs">
                                            <span className="font-bold">ğŸ­ å¤©èµ‹åŠ æˆ:</span> {matchingTalent.name} â†’ +1å¥–åŠ±éª°
                                            <span className="ml-1 text-yellow-600">
                                                (å®é™…: {skillModifier + 1 > 0 ? `+${skillModifier + 1}` : skillModifier + 1 === 0 ? 'æ ‡å‡†' : skillModifier + 1})
                                            </span>
                                        </div>
                                    ) : null;
                                })()}
                                
                                {/* æ‰§è¡Œæ£€å®šæŒ‰é’® */}
                                <button 
                                    onClick={() => quickActions.skillCheck(selectedSkill, skillValue, skillModifier)}
                                    disabled={!selectedSkill}
                                    className={`w-full p-4 text-sm font-bold uppercase tracking-wide transition-colors ${
                                        selectedSkill 
                                            ? 'bg-black text-white hover:bg-gray-800' 
                                            : 'bg-gray-200 text-gray-400 cursor-not-allowed'
                                    }`}
                                >
                                    ğŸ² æ‰§è¡Œæ£€å®š ROLL CHECK
                                </button>
                                
                                {/* å¹¸è¿æ¢å¤ (å¹¸è¿å„¿å¤©èµ‹) */}
                                {hpMultiplier === 2 && (selectedChar?.talents || []).includes('lucky') && (
                                    <div className="border-t-2 border-dashed border-gray-300 pt-4">
                                        <button 
                                            onClick={quickActions.luckRecovery}
                                            className="w-full p-3 bg-purple-50 border-2 border-purple-300 text-purple-700 text-xs font-bold hover:bg-purple-100"
                                        >
                                            ğŸ€ å¹¸è¿æ¢å¤ +1D10 [å¹¸è¿å„¿å¤©èµ‹]
                                        </button>
                                        <div className="text-[10px] text-gray-500 mt-1 text-center">æ¯åœºæ™¯å¯ä½¿ç”¨ä¸€æ¬¡</div>
                                    </div>
                                )}
                            </div>
                        )}
                    </>
                )}
            </div>
        </div>
    );
}

// =====================================================
// OnboardingTutorial Component - æ–°æ‰‹å¼•å¯¼ç»„ä»¶
// =====================================================
function OnboardingTutorial({ forceOpen, onCloseForce }) {
    const [step, setStep] = useState(0);
    const [show, setShow] = useState(false);

    const STORAGE_KEY = 'coc7_combat_console_tutorial_viewed_v3';

    useEffect(() => {
        const viewed = localStorage.getItem(STORAGE_KEY);
        if (!viewed || forceOpen) {
            setTimeout(() => setShow(true), 100);
            setStep(0);
        }
    }, [forceOpen]);

    const finishTutorial = () => {
        setShow(false);
        localStorage.setItem(STORAGE_KEY, 'true');
        setTimeout(() => {
            if (onCloseForce) onCloseForce();
        }, 300);
    };

    const nextStep = () => {
        if (step < 3) setStep(step + 1);
    };

    const slides = [
        {
            icon: "ğŸ“‹",
            title: "æé€Ÿä¸Šæ‰‹ Quick Start",
            content: (
                <ul>
                    <li><strong>1. å»ºå¡</strong> ç‚¹è®¾ç½®é¡µ <span className="tut-highlight">ğŸ“¥ å¯¼å…¥æ–‡æœ¬</span>ï¼Œç²˜è´´è§’è‰²å±æ€§(å¦‚åŠ›é‡60 æ•æ·70...)ï¼Œä¸€é”®ç”Ÿæˆã€‚</li>
                    <li><strong>2. å¼€æ‰“</strong> ç‚¹å³ä¸Šè§’ <span className="tut-highlight">âš”ï¸ å¼€å§‹æˆ˜æ–—</span>ã€‚</li>
                    <li style={{paddingLeft: '1em'}}>â€¢ è°åŠ¨ï¼Ÿå·¦ä¾§åˆ—è¡¨<span className="tut-highlight">é«˜äº®</span>çš„äººã€‚</li>
                    <li style={{paddingLeft: '1em'}}>â€¢ æ‰“è°ï¼Ÿç‚¹å‡»åˆ—è¡¨é‡Œçš„<span className="tut-highlight">æ•Œäººåå­—</span>ã€‚</li>
                    <li style={{paddingLeft: '1em'}}>â€¢ æ€ä¹ˆæ‰“ï¼Ÿç‚¹å‡»å¤§æŒ‰é’® <span className="tut-highlight">âš”ï¸ è¿‘æˆ˜æ”»å‡»</span>ã€‚</li>
                    <li><strong>3. ç»“ç®—</strong> è¾“æ•°å­—ï¼šå¡«å…¥ç©å®¶éª°ç‚¹(å¦‚45)ï¼Œè‡ªåŠ¨åˆ¤æˆåŠŸ/å¤±è´¥ã€‚è¾“ä¼¤å®³ï¼šå¡«å…¥ä¼¤å®³å€¼ï¼Œè‡ªåŠ¨æ‰£HPã€‚</li>
                    <li style={{marginTop: '0.5em', color: '#9333ea'}}>ğŸ’¡ å£è¯€ï¼š<strong>ç‚¹äºº â†’ ç‚¹æŠ€èƒ½ â†’ è¾“æ•°å­—</strong></li>
                </ul>
            )
        },
        {
            icon: "ğŸ”«",
            title: "å°„å‡» Shooting",
            content: (
                <ul>
                    <li><strong>ğŸ”« åŸºç¡€å°„å‡»</strong> ç‚¹å‡» <span className="tut-highlight">ğŸ”« å°„å‡»</span>ã€‚</li>
                    <li style={{paddingLeft: '1em'}}>â€¢ è·ç¦»ï¼šå¡«å…¥æ•°å­—ï¼Œè‡ªåŠ¨ç®—éš¾åº¦(å¸¸è§„/å›°éš¾/æéš¾)ã€‚</li>
                    <li style={{paddingLeft: '1em'}}>â€¢ è´´è„¸ï¼š3ç±³å†…å‹¾é€‰ <span className="tut-highlight">æŠµè¿‘å°„å‡»</span>(å¥–åŠ±éª°)ã€‚</li>
                    <li style={{marginTop: '0.5em'}}><strong>ğŸ”¥ è¿å°„/æ‰«å°„</strong></li>
                    <li style={{paddingLeft: '1em'}}>â€¢ è¿å°„ï¼šå‹¾é€‰ <span className="tut-highlight">Ã—3</span>ï¼Œè‡ªåŠ¨åŠ æƒ©ç½šéª°ã€‚</li>
                    <li style={{paddingLeft: '1em'}}>â€¢ æ‰«å°„ï¼šå‹¾é€‰ <span className="tut-highlight">å…¨è‡ªåŠ¨</span>ï¼Œè¾“å…¥å­å¼¹æ•°ï¼Œè‡ªåŠ¨åˆ†ç»„ç»“ç®—ã€‚</li>
                </ul>
            )
        },
        {
            icon: "ğŸ­",
            title: "é€šä¿—æ¨¡å¼ Pulp Cthulhu",
            content: (
                <ul>
                    <li><strong>ğŸ­ å¼€å¯çˆ½å±€</strong> è®¾ç½®é¡µå‹¾é€‰ <span className="tut-highlight">é€šä¿—æ¨¡å¼</span>ã€‚</li>
                    <li style={{marginTop: '0.5em'}}><strong>âœ¨ æ ¸å¿ƒå˜åŒ–</strong></li>
                    <li style={{paddingLeft: '1em'}}>â€¢ è¡€æ¡ç¿»å€ï¼šHPä¸Šé™è‡ªåŠ¨Ã—2ã€‚</li>
                    <li style={{paddingLeft: '1em'}}>â€¢ å¹¸è¿ç³»ç»Ÿï¼šç‚¹ <span className="tut-highlight">ğŸ€</span> èŠ±å¹¸è¿å›è¡€(æ“¦ä¼¤)ï¼›å¿«æ­»æ—¶èŠ±å¹¸è¿é”è¡€(å‘½æ‚¬ä¸€çº¿)ã€‚</li>
                    <li style={{paddingLeft: '1em'}}>â€¢ ç‰¹æŠ€ï¼šæ–°å¢ <span className="tut-highlight">ğŸ’« å‡»æ™•</span> æŒ‰é’®ã€‚</li>
                </ul>
            )
        },
        {
            icon: "ğŸ‘‘",
            title: "KPå¤–æŒ‚ KP Tools",
            content: (
                <ul>
                    <li><strong>ğŸ‘‘ ä¸Šå¸æ§åˆ¶å°</strong> æˆ˜æ–—ä¸­ç‚¹å³ä¸Šè§’ <span className="tut-highlight">ğŸ‘‘ KP</span>ã€‚</li>
                    <li style={{paddingLeft: '1em'}}>â€¢ æ•‘åœºï¼šå¼ºè¡Œæ”¹HP/Sanå€¼ã€‚</li>
                    <li style={{paddingLeft: '1em'}}>â€¢ æ§åœºï¼šå¼ºè¡Œè®©æŸäººæ˜è¿·/å€’åœ°ã€‚</li>
                    <li style={{paddingLeft: '1em'}}>â€¢ ä¸´æ—¶æ£€å®šï¼šè®©æŸäººè¿‡ä¸ªä¾¦æŸ¥/è†å¬ã€‚</li>
                    <li style={{marginTop: '0.5em'}}><strong>ğŸ² éª°å­ä¿®æ­£</strong> å¥–åŠ±éª°/æƒ©ç½šéª°æŒ‰é’®<span className="tut-highlight">å¯å¤šæ¬¡ç‚¹å‡»</span>å åŠ (å¦‚+2/+3)ã€‚</li>
                    <li style={{marginTop: '0.5em'}}><strong>â†©ï¸ åæ‚”è¯</strong> ç‚¹é”™äº†ï¼Ÿç‚¹å·¦ä¸Šè§’ <span className="tut-highlight">â†©</span> æ’¤é”€ã€‚</li>
                    <li><strong>ğŸ’¾ å­˜è¯»æ¡£</strong> è®¾ç½®é¡µ <span className="tut-highlight">å¯¼å‡º/å¯¼å…¥</span>ï¼Œæ”¯æŒå¤šå›¢åˆ‡æ¢ã€‚</li>
                </ul>
            )
        }
    ];

    return (
        <div className={`tutorial-overlay ${show ? 'active' : ''}`}>
            <div className="tutorial-card-container">
                <div 
                    className="tutorial-slides-wrapper" 
                    style={{ transform: `translateX(-${step * 25}%)` }}
                >
                    {slides.map((slide, index) => (
                        <div className="tutorial-slide" key={index}>
                            <div className="tut-header">
                                <div className="tut-icon">{slide.icon}</div>
                                <div className="tut-title">{slide.title}</div>
                            </div>
                            <div className="tut-body">
                                {slide.content}
                            </div>
                        </div>
                    ))}
                </div>

                <div className="tut-footer">
                    <div className="tut-dots">
                        {[0, 1, 2, 3].map(i => (
                            <div 
                                key={i} 
                                className={`tut-dot ${step === i ? 'active' : ''}`}
                                onClick={() => setStep(i)}
                            />
                        ))}
                    </div>
                    <div className="tut-actions">
                        {step < 3 ? (
                            <>
                                <button className="tut-btn skip" onClick={finishTutorial}>è·³è¿‡ SKIP</button>
                                <button className="tut-btn" onClick={nextStep}>ä¸‹ä¸€æ­¥ NEXT â†’</button>
                            </>
                        ) : (
                            <button className="tut-btn start" onClick={finishTutorial}>å¼€å§‹ä½¿ç”¨ START</button>
                        )}
                    </div>
                </div>
            </div>
        </div>
    );
}

// =====================================================
// SetupModule (UI Update: Bilingual)
// =====================================================
function SetupModule({ characters, setCharacters, updateChar, openTutorial, exportSave, importSave, exportLogsToTxt, logs, hpMultiplier, setHpMultiplier, resetAll }) {
    const [selectedId, setSelectedId] = useState(null);
    const [isImporting, setIsImporting] = useState(false);
    const [importText, setImportText] = useState('');
    
    const activeChar = characters.find(c => c.id === selectedId);

    const addCharacter = (type) => {
        const newChar = { 
            ...JSON.parse(JSON.stringify(BASE_CHARACTER)), 
            id: generateId(), 
            type, 
            name: type === 'player' ? 'æ–°è°ƒæŸ¥å‘˜' : 'æ–°æ•Œäºº',
        };
        const derived = calcDerived(newChar, hpMultiplier);
        setCharacters(p => [...p, { ...newChar, ...derived, hp: derived.maxHp }]);
        setSelectedId(newChar.id);
    };

    const handleImport = () => {
        if (!importText) return;
        const lines = importText.split('\n');
        const newChar = { ...JSON.parse(JSON.stringify(BASE_CHARACTER)), id: generateId(), type: 'player', name: 'å¯¼å…¥è§’è‰²' };
        lines.forEach(line => {
            if (line.includes('åŠ›é‡')) newChar.str = parseInt(line.match(/\d+/)?.[0] || 50);
            if (line.includes('ä½“è´¨')) newChar.con = parseInt(line.match(/\d+/)?.[0] || 50);
            if (line.includes('ä½“å‹')) newChar.siz = parseInt(line.match(/\d+/)?.[0] || 60);
            if (line.includes('æ•æ·')) newChar.dex = parseInt(line.match(/\d+/)?.[0] || 50);
            if (line.includes('æ–—æ®´') || line.includes('æ ¼æ–—')) newChar.fight = parseInt(line.match(/\d+/)?.[0] || 50);
            if (line.includes('å°„å‡»')) newChar.firearms = parseInt(line.match(/\d+/)?.[0] || 20);
            if (line.includes('é—ªé¿')) newChar.dodge = parseInt(line.match(/\d+/)?.[0] || 25);
        });
        const derived = calcDerived(newChar, hpMultiplier);
        setCharacters(p => [...p, { ...newChar, ...derived, hp: derived.maxHp }]);
        setSelectedId(newChar.id);
        setImportText('');
        setIsImporting(false);
    };

    return (
        <div className="setup-grid h-full">
            <div className="setup-sidebar panel-scroll bg-white">
                <div className="p-5 space-y-6 flex flex-col min-h-full">
                    <div>
                        <div className="text-2xl font-black tracking-[0.1em] mb-1">è§’ è‰² ç®¡ ç†</div>
                        <div className="text-[9px] text-gray-300 uppercase tracking-[0.2em] font-mono">CHARACTER SETUP</div>
                    </div>
                    
                    {/* é€šä¿—æ¨¡å¼å¼€å…³ */}
                    <div className={`p-4 border-2 ${hpMultiplier === 2 ? 'bg-purple-50 border-purple-500' : 'bg-gray-50 border-gray-300'} transition-colors`}>
                        <label className="flex items-center gap-3 cursor-pointer">
                            <input 
                                type="checkbox" 
                                checked={hpMultiplier === 2}
                                onChange={e => {
                                    const newMultiplier = e.target.checked ? 2 : 1;
                                    setHpMultiplier(newMultiplier);
                                    // é‡æ–°è®¡ç®—æ‰€æœ‰è§’è‰²çš„HP
                                    setCharacters(prev => prev.map(c => {
                                        const derived = calcDerived(c, newMultiplier);
                                        return { ...c, ...derived, hp: Math.min(c.hp, derived.maxHp) };
                                    }));
                                }}
                                className="w-5 h-5 accent-purple-600"
                            />
                            <div>
                                <div className="text-sm font-black tracking-wide">ğŸ­ é€šä¿—æ¨¡å¼ Pulp</div>
                                <div className="text-[10px] text-gray-400">åŒå€HP Â· å¤©èµ‹ Â· å¹¸è¿ Â· å–½å•° Â· æŠ€èƒ½æ£€å®š</div>
                            </div>
                        </label>
                        {hpMultiplier === 2 && (
                            <div className="mt-3 pt-3 border-t border-purple-200 text-[10px] text-purple-600 space-y-1">
                                <div>âœ“ HP = (CON+SIZ)Ã·5 Â· æ— é‡ä¼¤è§„åˆ™</div>
                                <div>âœ“ æ€¥æ•‘ +1D4 Â· åŒ»å­¦ +1D6 Â· è¿…é€Ÿæ¢å¤</div>
                                <div>âœ“ æ“¦ä¼¤è€Œå·² Â· èº²è¿‡ä¸€åŠ« Â· å‘½æ‚¬ä¸€çº¿</div>
                                <div>âœ“ åŒæªå°„å‡» Â· å‡»æ™• Â· ç–¯ç‹‚å†²é”‹</div>
                                <div>âœ“ 15ç§å¤©èµ‹ Â· å–½å•°è§„åˆ™ Â· å¿«æ‹”å…ˆæ”»</div>
                                <div>âœ“ å¤©èµ‹æŠ€èƒ½å¥–åŠ±éª° Â· é€šç”¨æŠ€èƒ½æ£€å®š</div>
                            </div>
                        )}
                    </div>
                    
                    {isImporting ? (
                        <div className="p-4 bg-white border-2 border-black shadow-hard-sm">
                            <textarea className="w-full h-24 text-sm font-mono border-2 border-gray-300 p-2 mb-3 focus:border-black focus:outline-none" placeholder="ç²˜è´´ .st æ–‡æœ¬ (ä¾‹å¦‚: åŠ›é‡50 ä½“è´¨60...)" value={importText} onChange={e => setImportText(e.target.value)} />
                            <div className="flex gap-2">
                                <button onClick={handleImport} className="flex-1 bg-black text-white text-xs py-3 font-black tracking-[0.1em] hover:bg-gray-800 transition-colors">ç¡® è®¤ å¯¼ å…¥</button>
                                <button onClick={() => setIsImporting(false)} className="flex-1 border-2 border-black text-xs py-3 font-bold hover:bg-gray-100 transition-colors">å–æ¶ˆ</button>
                            </div>
                        </div>
                    ) : (
                        <button onClick={() => setIsImporting(true)} className="w-full py-3 border-2 border-dashed border-gray-300 text-xs font-bold text-gray-400 tracking-wide hover:border-black hover:text-black transition-colors">ğŸ“¥ å¯¼å…¥æ–‡æœ¬</button>
                    )}
                    
                    <div>
                        <div className="flex justify-between items-center mb-3">
                            <div className="flex items-baseline gap-2">
                                <span className="text-xs font-black text-blue-600 tracking-wide">è°ƒæŸ¥å‘˜</span>
                                <span className="text-[9px] font-mono text-blue-300">PC</span>
                            </div>
                            <button onClick={() => addCharacter('player')} title="æ·»åŠ è°ƒæŸ¥å‘˜" className="text-xs font-bold w-7 h-7 border-2 border-black flex items-center justify-center hover:bg-black hover:text-white transition-colors">+</button>
                        </div>
                        <div className="space-y-1">
                            {characters.filter(c => c.type === 'player').map(c => (
                                <div 
                                    key={c.id} 
                                    onClick={() => setSelectedId(c.id)} 
                                    className={`char-card faction-strip-player flex items-center justify-between px-3 py-3 text-sm ${selectedId === c.id ? 'selected' : ''}`}
                                >
                                    <span className="font-bold truncate">{c.name}</span>
                                    <button onClick={(e) => { e.stopPropagation(); if(confirm('ç¡®è®¤åˆ é™¤?')) setCharacters(p => p.filter(x => x.id !== c.id)); if(selectedId === c.id) setSelectedId(null); }} title="åˆ é™¤è§’è‰²" className="text-gray-400 hover:text-red-600 px-2 text-lg">Ã—</button>
                                </div>
                            ))}
                        </div>
                    </div>
                    
                    <div>
                        <div className="flex justify-between items-center mb-3">
                            <div className="flex items-baseline gap-2">
                                <span className="text-xs font-black text-red-600 tracking-wide">æ•Œäºº</span>
                                <span className="text-[9px] font-mono text-red-300">NPC</span>
                            </div>
                            <button onClick={() => addCharacter('enemy')} title="æ·»åŠ æ•Œäºº" className="text-xs font-bold w-7 h-7 border-2 border-black flex items-center justify-center hover:bg-black hover:text-white transition-colors">+</button>
                        </div>
                        <div className="space-y-1">
                            {characters.filter(c => c.type === 'enemy').map(c => (
                                <div 
                                    key={c.id} 
                                    onClick={() => setSelectedId(c.id)} 
                                    className={`char-card faction-strip-enemy flex items-center justify-between px-3 py-3 text-sm ${selectedId === c.id ? 'selected' : ''}`}
                                >
                                    <span className="font-bold truncate">{c.name}</span>
                                    <button onClick={(e) => { e.stopPropagation(); if(confirm('ç¡®è®¤åˆ é™¤?')) setCharacters(p => p.filter(x => x.id !== c.id)); if(selectedId === c.id) setSelectedId(null); }} title="åˆ é™¤è§’è‰²" className="text-gray-400 hover:text-red-600 px-2 text-lg">Ã—</button>
                                </div>
                            ))}
                        </div>
                    </div>

                    {/* æ–°æ‰‹å¼•å¯¼æŒ‰é’® */}
                    <div className="pt-4 border-t-2 border-gray-100">
                        <button 
                            onClick={openTutorial} 
                            className="w-full py-3 border-2 border-black text-xs font-black tracking-[0.1em] hover:bg-black hover:text-white transition-colors flex items-center justify-center gap-2"
                        >
                            <span>ğŸ’¡</span> æ–° æ‰‹ æ•™ ç¨‹
                        </button>
                    </div>

                    {/* å­˜æ¡£ç®¡ç† */}
                    <div className="pt-4 border-t-2 border-gray-100 mt-4">
                        <div className="flex items-baseline gap-2 mb-3">
                            <span className="text-[10px] font-black text-gray-500 tracking-wide">ğŸ“‚ å­˜æ¡£ç®¡ç†</span>
                        </div>
                        
                        <div className="grid grid-cols-2 gap-2 mb-2">
                            <button 
                                onClick={() => {
                                    const name = prompt('è¾“å…¥å­˜æ¡£åç§°:', 'æˆ‘çš„æˆ˜æ–—');
                                    if (name) exportSave(name);
                                }} 
                                title="å¯¼å‡ºå­˜æ¡£"
                                className="p-3 border-2 border-black text-[10px] font-bold tracking-wide hover:bg-black hover:text-white transition-colors"
                            >
                                ğŸ’¾ å¯¼å‡º
                            </button>
                            
                            <label className="p-3 border-2 border-black text-[10px] font-bold tracking-wide text-center cursor-pointer hover:bg-black hover:text-white transition-colors">
                                ğŸ“‚ å¯¼å…¥
                                <input 
                                    type="file" 
                                    accept=".txt,.json" 
                                    className="hidden" 
                                    onChange={(e) => e.target.files[0] && importSave(e.target.files[0])} 
                                />
                            </label>
                        </div>
                        
                        <button 
                            onClick={exportLogsToTxt} 
                            disabled={!logs || logs.length === 0}
                            title="å¯¼å‡ºæˆ˜æ–—æ—¥å¿—"
                            className="w-full p-3 border-2 border-gray-200 text-[10px] font-bold tracking-wide text-gray-400 hover:border-black hover:text-black disabled:opacity-40 disabled:cursor-not-allowed transition-colors mb-2"
                        >
                            ğŸ“œ å¯¼å‡ºæ—¥å¿— (æ´»å­—å¼•æ“)
                        </button>
                        
                        <button 
                            onClick={resetAll}
                            title="æ¸…ç©ºæ‰€æœ‰æ•°æ®é‡æ–°å¼€å§‹"
                            className="w-full p-3 border-2 border-red-200 text-[10px] font-bold tracking-wide text-red-400 hover:border-red-500 hover:text-red-500 hover:bg-red-50 transition-colors"
                        >
                            ğŸ—‘ï¸ æ¸…ç©ºæ•°æ®
                        </button>
                    </div>
                    
                    {/* å¼€å‘è€…ä¿¡æ¯ */}
                    <div className="mt-auto pt-4 border-t border-dashed border-gray-200">
                        <div className="text-[9px] text-gray-400 space-y-3">
                            {/* å¼€å‘è€… */}
                            <div>
                                <div className="font-mono text-gray-300 tracking-widest mb-1">DEVELOPER</div>
                                <a 
                                    href="https://space.bilibili.com/1613208731" 
                                    target="_blank" 
                                    rel="noopener noreferrer"
                                    className="inline-flex items-center gap-1 hover:text-gray-600 transition-colors"
                                >
                                    <span>ğŸ“º</span>
                                    <span className="font-bold">è±†èŠéº»mamemo</span>
                                    <span className="text-[8px]">â†—</span>
                                </a>
                            </div>
                            {/* åé¦ˆç¾¤ä¿¡æ¯ */}
                            <div>
                                <div className="font-mono text-gray-300 tracking-widest mb-1">FEEDBACK</div>
                                <div className="flex items-center gap-1.5">
                                    <span>ğŸ’¬</span>
                                    <span>QQç¾¤</span>
                                    <span className="font-mono font-bold">138652536</span>
                                </div>
                                <div className="text-[8px] text-gray-300 mt-1">
                                    æ›´æ–°æ—¥å¿— Â· Bugåé¦ˆ Â· åŠŸèƒ½è®¸æ„¿
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div className="setup-content panel-scroll p-6">
                {activeChar ? <CharacterSheet char={activeChar} updateChar={updateChar} hpMultiplier={hpMultiplier} /> : (
                    <div className="h-full flex items-center justify-center text-gray-300">
                        <div className="text-center">
                            <div className="text-6xl mb-4">ğŸ“‹</div>
                            <p className="text-sm font-black tracking-[0.1em]">è¯· é€‰ æ‹© è§’ è‰²</p>
                            <p className="text-[10px] text-gray-300 mt-1">ç‚¹å‡»å·¦ä¾§åˆ—è¡¨é€‰æ‹©</p>
                        </div>
                    </div>
                )}
            </div>
        </div>
    );
}

// =====================================================
// CharacterSheet (UI Update: Bilingual & Grouping)
// =====================================================
function CharacterSheet({ char, updateChar, hpMultiplier }) {
    // è‡ªå®šä¹‰æ­¦å™¨è¡¨å•çŠ¶æ€
    const [customWeapon, setCustomWeapon] = useState({ name: '', damage: '1D6', type: 'melee', impale: false, range: 30, ammo: 6, malfunction: 100 });
    
    const addCustomWeapon = () => {
        if (!customWeapon.name || !customWeapon.damage) return alert('è¯·è¾“å…¥æ­¦å™¨åç§°å’Œä¼¤å®³');
        const newWeapon = {
            name: customWeapon.name,
            damage: customWeapon.damage,
            type: customWeapon.type,
            impale: customWeapon.impale,
            ...(customWeapon.type === 'ranged' && {
                range: customWeapon.range,
                ammo: customWeapon.ammo,
                maxAmmo: customWeapon.ammo,
                malfunction: customWeapon.malfunction
            })
        };
        if (customWeapon.type === 'melee') {
            updateChar(char.id, { meleeWeapon: newWeapon });
        } else {
            updateChar(char.id, { rangedWeapon: newWeapon });
        }
        setCustomWeapon({ name: '', damage: '1D6', type: 'melee', impale: false, range: 30, ammo: 6, malfunction: 100 });
    };

    return (
        <div className="max-w-3xl mx-auto p-8 bg-white">
            <div className="mb-8 flex gap-6 items-end">
                <div className="flex-1">
                    <SmartInput 
                        type="text" 
                        label="è§’è‰²å§“å" 
                        value={char.name} 
                        onChange={(val) => updateChar(char.id, { name: val })} 
                    />
                </div>
                <div className="w-32">
                    <div className="flex items-baseline gap-1 mb-1">
                        <span className="text-[10px] font-bold text-gray-500">ç±»å‹</span>
                        <span className="text-[9px] font-mono text-gray-300">TYPE</span>
                    </div>
                    <select value={char.type} onChange={e => updateChar(char.id, { type: e.target.value })} className="w-full py-2 border-b-2 border-gray-300 text-sm font-bold focus:border-black bg-transparent focus:outline-none">
                        <option value="player">è°ƒæŸ¥å‘˜ PC</option>
                        <option value="enemy">æ•Œäºº NPC</option>
                    </select>
                </div>
            </div>
            
            <div className="grid grid-cols-2 sm:grid-cols-4 gap-4 mb-8">
                <SmartInput label="åŠ›é‡" sublabel="STR" value={char.str} onChange={(val) => updateChar(char.id, { str: val })} />
                <SmartInput label="ä½“è´¨" sublabel="CON" value={char.con} onChange={(val) => updateChar(char.id, { con: val })} />
                <SmartInput label="ä½“å‹" sublabel="SIZ" value={char.siz} onChange={(val) => updateChar(char.id, { siz: val })} />
                <SmartInput label="æ•æ·" sublabel="DEX" value={char.dex} onChange={(val) => updateChar(char.id, { dex: val })} />
            </div>

            <div className="bg-black text-white p-5 mb-8 shadow-hard-sm">
                <div className="grid grid-cols-2 sm:grid-cols-4 gap-4">
                    <div className="text-center">
                        <div className="flex items-baseline justify-center gap-1 mb-1">
                            <span className="text-[10px] text-gray-300">æœ€å¤§ç”Ÿå‘½</span>
                            <span className="text-[9px] font-mono text-gray-500">HP</span>
                        </div>
                        <div className="text-3xl font-mono font-black">{char.maxHp}</div>
                    </div>
                    <div className="text-center">
                        <div className="flex items-baseline justify-center gap-1 mb-1">
                            <span className="text-[10px] text-gray-300">ä¼¤å®³åŠ å€¼</span>
                            <span className="text-[9px] font-mono text-gray-500">DB</span>
                        </div>
                        <div className="text-3xl font-mono font-black">{char.db}</div>
                    </div>
                    <div className="text-center">
                        <div className="flex items-baseline justify-center gap-1 mb-1">
                            <span className="text-[10px] text-gray-300">ä½“æ ¼</span>
                            <span className="text-[9px] font-mono text-gray-500">BUILD</span>
                        </div>
                        <div className="text-3xl font-mono font-black">{char.build}</div>
                    </div>
                    <div className="text-center">
                        <div className="flex items-baseline justify-center gap-1 mb-1">
                            <span className="text-[10px] text-gray-300">ç§»åŠ¨</span>
                            <span className="text-[9px] font-mono text-gray-500">MOV</span>
                        </div>
                        <div className="text-3xl font-mono font-black">{char.mov}</div>
                    </div>
                </div>
            </div>

            <div className="grid grid-cols-1 md:grid-cols-2 gap-8 mb-8">
                <div>
                    <div className="flex items-baseline gap-2 mb-3 border-b-2 border-black pb-2">
                        <span className="text-xs font-black tracking-wide">æˆ˜æ–—æŠ€èƒ½</span>
                        <span className="text-[9px] font-mono text-gray-300">COMBAT</span>
                    </div>
                    <div className="grid grid-cols-2 gap-3">
                        <SmartInput label="æ–—æ®´" sublabel="BRAWL" value={char.fight} onChange={(val) => updateChar(char.id, { fight: val })} />
                        <SmartInput label="é—ªé¿" sublabel="DODGE" value={char.dodge} onChange={(val) => updateChar(char.id, { dodge: val })} />
                        <SmartInput label="å°„å‡»" sublabel="FIREARMS" value={char.firearms} onChange={(val) => updateChar(char.id, { firearms: val })} />
                        <SmartInput label="æŠ¤ç”²" sublabel="ARMOR" value={char.armorValue || 0} onChange={(val) => updateChar(char.id, { armorValue: val })} />
                    </div>
                </div>
                <div>
                    <div className="flex items-baseline gap-2 mb-3 border-b-2 border-black pb-2">
                        <span className="text-xs font-black tracking-wide">åŒ»ç–—æŠ€èƒ½</span>
                        <span className="text-[9px] font-mono text-gray-300">MEDICAL</span>
                    </div>
                    <div className="grid grid-cols-2 gap-3">
                        <SmartInput label="æ€¥æ•‘" sublabel="FIRST AID" value={char.firstAid || 30} onChange={(val) => updateChar(char.id, { firstAid: val })} />
                        <SmartInput label="åŒ»å­¦" sublabel="MEDICINE" value={char.medicine || 5} onChange={(val) => updateChar(char.id, { medicine: val })} />
                    </div>
                </div>
            </div>
            
            {/* å¹¸è¿å€¼ - ä»…é€šä¿—æ¨¡å¼æ˜¾ç¤º */}
            {hpMultiplier === 2 && (
                <div className="mb-8 p-5 bg-purple-50 border-2 border-purple-300">
                    <div className="flex items-baseline gap-2 mb-3 border-b-2 border-purple-400 pb-2">
                        <span className="text-xs font-black tracking-wide text-purple-700">ğŸ€ å¹¸è¿å€¼</span>
                        <span className="text-[9px] font-mono text-purple-400">LUCK (PULP)</span>
                    </div>
                    <div className="grid grid-cols-2 gap-4">
                        <SmartInput 
                            label="å½“å‰" 
                            sublabel="CURRENT" 
                            value={char.luck || 50} 
                            onChange={(val) => updateChar(char.id, { luck: val })} 
                        />
                        <SmartInput 
                            label="æœ€å¤§" 
                            sublabel="MAX" 
                            value={char.maxLuck || 50} 
                            onChange={(val) => updateChar(char.id, { maxLuck: val })} 
                        />
                    </div>
                    <div className="mt-3 text-[10px] text-purple-600 space-y-1">
                        <div>â€¢ æ“¦ä¼¤è€Œå·²: æ¶ˆè€—20ç‚¹ â†’ æ¢å¤1D6 HP</div>
                        <div>â€¢ èº²è¿‡ä¸€åŠ«: æ¶ˆè€—10ç‚¹ â†’ ä¼¤å®³-5</div>
                        <div>â€¢ å‘½æ‚¬ä¸€çº¿: æ¶ˆè€—30+ â†’ é¿å…æ­»äº¡</div>
                    </div>
                </div>
            )}
            
            {/* å¤©èµ‹ & å–½å•° - ä»…é€šä¿—æ¨¡å¼æ˜¾ç¤º */}
            {hpMultiplier === 2 && (
                <div className="mb-8 p-5 bg-yellow-50 border-2 border-yellow-300">
                    <div className="flex items-baseline gap-2 mb-3 border-b-2 border-yellow-400 pb-2">
                        <span className="text-xs font-black tracking-wide text-yellow-700">ğŸ­ é€šä¿—ç‰¹æ€§</span>
                        <span className="text-[9px] font-mono text-yellow-400">PULP FEATURES</span>
                    </div>
                    
                    {/* å–½å•°æ ‡è®° */}
                    <label className="flex items-center gap-3 cursor-pointer p-3 border border-red-200 bg-red-50 mb-4">
                        <input 
                            type="checkbox" 
                            checked={char.isMook || false} 
                            onChange={e => updateChar(char.id, { isMook: e.target.checked })} 
                            className="w-5 h-5 accent-red-600" 
                        />
                        <div>
                            <span className="text-sm font-bold text-red-700">ğŸ‘¤ å–½å•° Mook</span>
                            <div className="text-[9px] text-red-500">è¢«å‘½ä¸­å³å€’ï¼Œæ— éœ€è®¡ç®—ä¼¤å®³</div>
                        </div>
                    </label>
                    
                    {/* å¤©èµ‹é€‰æ‹© */}
                    <div className="text-[10px] font-bold text-yellow-700 mb-2">å¤©èµ‹ Talents (å¯å¤šé€‰ï¼Œæœ€å¤š2ä¸ª)</div>
                    <div className="grid grid-cols-2 gap-2 max-h-60 overflow-y-auto">
                        {PULP_TALENTS.map(talent => (
                            <label key={talent.id} className={`flex items-start gap-2 p-2 border cursor-pointer text-[10px] ${(char.talents || []).includes(talent.id) ? 'bg-yellow-100 border-yellow-400' : 'bg-white border-gray-200'} ${talent.effect === 'hp_bonus' || talent.effect === 'mov_bonus' || talent.effect === 'unarmed_bonus' || talent.effect === 'initiative_bonus' || talent.effect === 'heal_bonus' ? 'ring-1 ring-green-300' : ''}`}>
                                <input 
                                    type="checkbox" 
                                    checked={(char.talents || []).includes(talent.id)} 
                                    onChange={e => {
                                        const currentTalents = char.talents || [];
                                        const newTalents = e.target.checked 
                                            ? [...currentTalents, talent.id]
                                            : currentTalents.filter(t => t !== talent.id);
                                        updateChar(char.id, { talents: newTalents });
                                    }} 
                                    className="w-3 h-3 mt-0.5 accent-yellow-600" 
                                />
                                <div>
                                    <div className="font-bold">{talent.name}</div>
                                    <div className="text-gray-500">{talent.desc}</div>
                                </div>
                            </label>
                        ))}
                    </div>
                    {(char.talents || []).length > 0 && (
                        <div className="mt-2 text-[9px] text-yellow-600">
                            å·²é€‰: {(char.talents || []).map(id => PULP_TALENTS.find(t => t.id === id)?.name).filter(Boolean).join(', ')}
                        </div>
                    )}
                </div>
            )}
            
            <div className="mb-8">
                 <div className="flex items-baseline gap-2 mb-3 border-b-2 border-black pb-2">
                    <span className="text-xs font-black tracking-wide">æˆ˜æ–—é…ç½®</span>
                    <span className="text-[9px] font-mono text-gray-300">CONFIG</span>
                </div>
                 <div className="space-y-3">
                    <label className="flex items-center gap-3 cursor-pointer p-4 border-2 border-gray-200 hover:border-black transition-colors">
                        <input type="checkbox" checked={char.hasGunReady || false} onChange={e => updateChar(char.id, { hasGunReady: e.target.checked })} className="w-5 h-5 accent-black" />
                        <span className="text-sm font-bold">ğŸ”« å·²æ¶æª <span className="text-xs text-gray-400 font-normal">(æ•æ·+50)</span></span>
                    </label>
                    <div className="p-4 border-2 border-gray-200">
                        <div className="flex items-center gap-4">
                            <span className="text-sm font-bold">ğŸ‘¹ æ€ªç‰©å¤šé‡æ”»å‡»</span>
                            <div className="w-20">
                                <SmartInput 
                                    value={char.attacksPerRound || 1} 
                                    onChange={(val) => updateChar(char.id, { attacksPerRound: Math.max(1, val), attacksLeft: Math.max(1, val) })} 
                                />
                            </div>
                            <span className="text-xs text-gray-400">(ä»…é™æ€ªç‰©/boss)</span>
                        </div>
                    </div>
                </div>
            </div>

            <div className="mb-8">
                <div className="flex items-baseline gap-2 mb-3 border-b-2 border-black pb-2">
                    <span className="text-xs font-black tracking-wide">å½“å‰çŠ¶æ€</span>
                    <span className="text-[9px] font-mono text-gray-300">STATUS</span>
                </div>
                <StatusGrid status={char.status} onChange={(status) => updateChar(char.id, { status })} />
            </div>
            
            <div className="bg-gray-100 p-5 border-2 border-gray-200">
                <div className="label mb-4 tracking-widest">WEAPONS è£…å¤‡æ­¦å™¨</div>
                
                {/* å½“å‰è£…å¤‡æ˜¾ç¤º */}
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4 p-4 bg-white border-2 border-black">
                    <div className="flex items-center gap-2">
                        <span className="text-blue-600 text-lg">âš”ï¸</span>
                        <span className="text-[10px] text-gray-400 uppercase tracking-wider">MELEE:</span>
                        <span className="text-sm font-bold">{char.meleeWeapon?.name || 'æ‹³å¤´'}</span>
                        <span className="text-xs font-mono text-gray-500">({char.meleeWeapon?.damage || '1D3'}{char.meleeWeapon?.impale ? ' è´¯ç©¿' : ''})</span>
                    </div>
                    <div className="flex items-center gap-2">
                        <span className="text-orange-600 text-lg">ğŸ”«</span>
                        <span className="text-[10px] text-gray-400 uppercase tracking-wider">RANGED:</span>
                        {char.rangedWeapon ? (
                            <>
                                <span className="text-sm font-bold">{char.rangedWeapon.name}</span>
                                <span className="text-xs font-mono text-gray-500">({char.rangedWeapon.damage})</span>
                            </>
                        ) : (
                            <span className="text-sm text-gray-400">æ— </span>
                        )}
                    </div>
                </div>
                
                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div>
                        <div className="text-xs font-bold text-blue-700 mb-2">âš”ï¸ è¿‘æˆ˜æ­¦å™¨ Melee</div>
                        <select 
                            className="w-full border border-gray-300 p-2 text-sm bg-white" 
                            value={char.meleeWeapon?.name || 'æ‹³å¤´'} 
                            onChange={(e) => { 
                                // å…ˆåœ¨é¢„è®¾åˆ—è¡¨ä¸­æŸ¥æ‰¾
                                const w = MELEE_WEAPONS.find(w => w.name === e.target.value);
                                if (w) {
                                    updateChar(char.id, { meleeWeapon: { ...w } });
                                } else if (e.target.value === char.meleeWeapon?.name) {
                                    // ä¿æŒå½“å‰è‡ªå®šä¹‰æ­¦å™¨
                                }
                            }}
                        >
                            {MELEE_WEAPONS.map(w => <option key={w.name} value={w.name}>{w.name} ({w.damage})</option>)}
                            {/* å¦‚æœå½“å‰æ­¦å™¨æ˜¯è‡ªå®šä¹‰çš„ï¼ˆä¸åœ¨é¢„è®¾åˆ—è¡¨ä¸­ï¼‰ï¼Œæ˜¾ç¤ºå®ƒ */}
                            {char.meleeWeapon && !MELEE_WEAPONS.find(w => w.name === char.meleeWeapon.name) && (
                                <option value={char.meleeWeapon.name} className="text-purple-600">â˜… {char.meleeWeapon.name} ({char.meleeWeapon.damage})</option>
                            )}
                        </select>
                    </div>

                    <div>
                        <div className="text-xs font-bold text-orange-700 mb-2">ğŸ”« è¿œç¨‹æ­¦å™¨ Ranged</div>
                        <select 
                            className="w-full border border-gray-300 p-2 text-sm bg-white" 
                            value={char.rangedWeapon?.name || ''} 
                            onChange={(e) => { 
                                if (!e.target.value) {
                                    updateChar(char.id, { rangedWeapon: null });
                                } else {
                                    const w = RANGED_WEAPONS.find(w => w.name === e.target.value); 
                                    if (w) {
                                        updateChar(char.id, { rangedWeapon: { ...w } });
                                    }
                                    // å¦‚æœæ˜¯è‡ªå®šä¹‰æ­¦å™¨ï¼Œä¿æŒä¸å˜
                                }
                            }}
                        >
                            <option value="">æ—  None</option>
                            {RANGED_WEAPONS.map(w => <option key={w.name} value={w.name}>{w.name} ({w.damage})</option>)}
                            {/* å¦‚æœå½“å‰æ­¦å™¨æ˜¯è‡ªå®šä¹‰çš„ï¼ˆä¸åœ¨é¢„è®¾åˆ—è¡¨ä¸­ï¼‰ï¼Œæ˜¾ç¤ºå®ƒ */}
                            {char.rangedWeapon && !RANGED_WEAPONS.find(w => w.name === char.rangedWeapon.name) && (
                                <option value={char.rangedWeapon.name} className="text-purple-600">â˜… {char.rangedWeapon.name} ({char.rangedWeapon.damage})</option>
                            )}
                        </select>
                         {char.rangedWeapon && (
                            <div className="mt-2 text-xs text-gray-500 font-mono flex items-center justify-between">
                                <span>
                                    å¼¹è¯: {char.rangedWeapon.ammo}/{char.rangedWeapon.maxAmmo} | å°„ç¨‹: {char.rangedWeapon.range}yd {char.rangedWeapon.malfunction < 100 ? `| æ•…éšœ: ${char.rangedWeapon.malfunction}` : ''}
                                </span>
                                {/* v4.3.6 è£…å¼¹æŒ‰é’® */}
                                <button
                                    onClick={() => updateChar(char.id, { 
                                        rangedWeapon: { ...char.rangedWeapon, ammo: char.rangedWeapon.maxAmmo } 
                                    })}
                                    disabled={char.rangedWeapon.ammo === char.rangedWeapon.maxAmmo}
                                    className={`px-2 py-1 text-[10px] font-bold border transition-all ${
                                        char.rangedWeapon.ammo === 0
                                            ? 'bg-red-600 text-white border-red-600 animate-pulse'
                                            : char.rangedWeapon.ammo === char.rangedWeapon.maxAmmo
                                                ? 'bg-gray-100 text-gray-400 border-gray-200 cursor-not-allowed'
                                                : 'bg-orange-100 text-orange-700 border-orange-300 hover:bg-orange-200'
                                    }`}
                                >
                                    {char.rangedWeapon.ammo === 0 ? 'âš ï¸ RELOAD NOW' : 'ğŸ”„ è£…å¼¹'}
                                </button>
                            </div>
                        )}
                    </div>
                </div>
                
                {/* è‡ªå®šä¹‰æ­¦å™¨ */}
                <div className="mt-6 pt-4 border-t border-dashed border-gray-300">
                    <div className="text-xs font-bold text-purple-700 mb-3">âœ¨ æ·»åŠ è‡ªå®šä¹‰æ­¦å™¨ Custom Weapon</div>
                    <div className="grid grid-cols-2 gap-3 mb-3">
                        <input 
                            type="text" 
                            placeholder="æ­¦å™¨åç§° Name" 
                            value={customWeapon.name} 
                            onChange={e => setCustomWeapon({...customWeapon, name: e.target.value})} 
                            className="border border-gray-300 p-2 text-sm"
                        />
                        <input 
                            type="text" 
                            placeholder="ä¼¤å®³ Damage (å¦‚ 1D6+2)" 
                            value={customWeapon.damage} 
                            onChange={e => setCustomWeapon({...customWeapon, damage: e.target.value})} 
                            className="border border-gray-300 p-2 text-sm font-mono"
                        />
                    </div>
                    <div className="flex gap-3 mb-3">
                        <select 
                            value={customWeapon.type} 
                            onChange={e => setCustomWeapon({...customWeapon, type: e.target.value})} 
                            className="flex-1 border border-gray-300 p-2 text-sm"
                        >
                            <option value="melee">è¿‘æˆ˜ Melee</option>
                            <option value="ranged">å°„å‡» Ranged</option>
                        </select>
                        <label className="flex items-center gap-2 text-sm">
                            <input 
                                type="checkbox" 
                                checked={customWeapon.impale} 
                                onChange={e => setCustomWeapon({...customWeapon, impale: e.target.checked})} 
                            />
                            è´¯ç©¿ Impale
                        </label>
                    </div>
                    {customWeapon.type === 'ranged' && (
                        <div className="grid grid-cols-3 gap-2 mb-3 p-2 bg-orange-50 border border-orange-200">
                            <div>
                                <div className="text-[10px] text-gray-500 mb-1">å¼¹è¯ Ammo</div>
                                <input type="number" value={customWeapon.ammo} onChange={e => setCustomWeapon({...customWeapon, ammo: parseInt(e.target.value) || 6})} className="w-full border p-1 text-sm" />
                            </div>
                            <div>
                                <div className="text-[10px] text-gray-500 mb-1">å°„ç¨‹ Range</div>
                                <input type="number" value={customWeapon.range} onChange={e => setCustomWeapon({...customWeapon, range: parseInt(e.target.value) || 30})} className="w-full border p-1 text-sm" />
                            </div>
                            <div>
                                <div className="text-[10px] text-gray-500 mb-1">æ•…éšœå€¼ Mal</div>
                                <input type="number" value={customWeapon.malfunction} onChange={e => setCustomWeapon({...customWeapon, malfunction: parseInt(e.target.value) || 100})} className="w-full border p-1 text-sm" />
                            </div>
                        </div>
                    )}
                    <button 
                        onClick={addCustomWeapon}
                        className="w-full py-2 bg-purple-600 text-white text-sm font-bold hover:bg-purple-700 transition-colors"
                    >
                        â• æ·»åŠ æ­¦å™¨ Add Weapon
                    </button>
                </div>
            </div>
        </div>
    );
}

// =====================================================
// InputModeToggle - è¾“å…¥æ¨¡å¼åˆ‡æ¢ (v4.3.0 æ–°å¢)
// =====================================================
function InputModeToggle({ value, onChange }) {
    return (
        <div className="flex gap-1 p-1 bg-gray-100 border-2 border-gray-200">
            <button
                onClick={() => onChange('manual')}
                className={`flex-1 py-2 px-3 text-xs font-bold transition-all ${
                    value === 'manual' 
                        ? 'bg-blue-600 text-white shadow-inner' 
                        : 'bg-white text-gray-600 hover:bg-gray-50'
                }`}
            >
                âŒ¨ï¸ æ‰‹åŠ¨å½•å…¥
            </button>
            <button
                onClick={() => onChange('auto')}
                className={`flex-1 py-2 px-3 text-xs font-bold transition-all ${
                    value === 'auto' 
                        ? 'bg-green-600 text-white shadow-inner' 
                        : 'bg-white text-gray-600 hover:bg-gray-50'
                }`}
            >
                ğŸ² è‡ªåŠ¨æ·éª°
            </button>
        </div>
    );
}

// =====================================================
// ManualResolutionCard - æ‰‹åŠ¨å½•å…¥ç»“ç®—å¡ç‰‡ (v4.3.0 æ–°å¢)
// =====================================================
function ManualResolutionCard({ 
    title, targetNumber, weaponDamage, db, attacker, target, targetId,
    isPulp, onApply, onCancel, hpMultiplier, weapon
}) {
    const [rollInput, setRollInput] = useState('');
    const [damageInput, setDamageInput] = useState('');
    const [showDamage, setShowDamage] = useState(false);
    
    const rollValue = parseInt(rollInput) || 0;
    const successLevel = rollValue > 0 ? calculateSuccessLevel(rollValue, targetNumber) : null;
    const isSuccess = successLevel !== null && successLevel > 0;
    
    const levelLabels = { 4: 'å¤§æˆåŠŸ', 3: 'æéš¾æˆåŠŸ', 2: 'å›°éš¾æˆåŠŸ', 1: 'å¸¸è§„æˆåŠŸ', 0: 'å¤±è´¥', '-1': 'å¤§å¤±è´¥' };
    const levelColors = { 
        4: 'text-yellow-500 border-yellow-500', 
        3: 'text-green-600 border-green-600', 
        2: 'text-green-500 border-green-500', 
        1: 'text-blue-500 border-blue-500', 
        0: 'text-gray-500 border-gray-500', 
        '-1': 'text-red-600 border-red-600' 
    };
    
    // å½“æ£€å®šæˆåŠŸæ—¶è‡ªåŠ¨æ˜¾ç¤ºä¼¤å®³è¾“å…¥
    React.useEffect(() => {
        if (isSuccess && !showDamage) {
            setShowDamage(true);
        } else if (!isSuccess && showDamage) {
            setShowDamage(false);
            setDamageInput('');
        }
    }, [isSuccess]);
    
    // è‡ªåŠ¨è®¡ç®—ä¼¤å®³
    const autoCalcDamage = () => {
        if (!weapon) return;
        const dmgResult = calculateDamage(weapon, { db: db || '0' }, successLevel, false, hpMultiplier);
        setDamageInput(String(dmgResult.total));
    };
    
    const handleApply = () => {
        if (!rollValue || rollValue < 1 || rollValue > 100) return;
        const finalDamage = isSuccess ? (parseInt(damageInput) || 0) : 0;
        onApply({
            roll: rollValue,
            successLevel,
            damage: finalDamage,
            damageLog: weaponDamage + (db && db !== '0' ? '+' + db : '')
        });
    };

    return (
        <div className="resolution-card animate-slide-up">
            {/* æ ‡é¢˜æ  */}
            <div className="flex justify-between items-end border-b-2 border-gray-100 pb-2 mb-4">
                <span className="text-lg font-black tracking-widest">{title}</span>
                <span className="text-xs font-mono text-gray-400">ç›®æ ‡ {targetNumber}%</span>
            </div>
            
            {/* æˆ˜æ–—ä¿¡æ¯ */}
            <div className="mb-4 pb-3 border-b border-gray-100 flex justify-between text-xs text-gray-500">
                <span>æ”»å‡»è€…: <strong className="text-black">{attacker}</strong></span>
                <span>â†’</span>
                <span>ç›®æ ‡: <strong className="text-black">{target}</strong></span>
            </div>
            
            {/* æ£€å®šè¾“å…¥åŒº - å·¨å¤§çš„è¾“å…¥æ¡† */}
            <div className="flex items-center gap-6 mb-4">
                <div className="flex flex-col">
                    <label className="text-[10px] font-bold text-gray-400 mb-1 tracking-wide">D100 å‡ºç›®</label>
                    <input 
                        type="number" 
                        autoFocus
                        min="1"
                        max="100"
                        className={`w-32 bg-transparent border-b-4 ${successLevel !== null ? levelColors[successLevel]?.split(' ')[1] || 'border-black' : 'border-black'} font-mono font-black text-6xl text-center focus:outline-none transition-colors`}
                        placeholder="â€”"
                        value={rollInput}
                        onChange={e => setRollInput(e.target.value)}
                        onKeyDown={e => { if (e.key === 'Enter' && isSuccess) document.getElementById('damage-input')?.focus(); }}
                    />
                </div>
                
                {/* å®æ—¶åˆ¤å®šç»“æœ */}
                <div className="flex flex-col justify-center">
                    {successLevel !== null ? (
                        <>
                            <div className={`text-2xl font-black ${levelColors[successLevel]?.split(' ')[0] || 'text-gray-500'}`}>
                                {levelLabels[successLevel] || 'â€”'}
                            </div>
                            <div className="text-xs text-gray-400 font-mono">
                                {rollValue} / {targetNumber}
                            </div>
                        </>
                    ) : (
                        <div className="text-gray-300 text-sm">è¾“å…¥æ£€å®šç»“æœ</div>
                    )}
                </div>
            </div>
            
            {/* ä¼¤å®³è¾“å…¥åŒº - ä»…æˆåŠŸæ—¶æ˜¾ç¤º */}
            {showDamage && (
                <div className="mt-4 pt-4 border-t-2 border-dashed border-gray-200">
                    <div className="flex items-center gap-4">
                        <div className="flex flex-col">
                            <label className="text-[10px] font-bold text-red-400 mb-1 tracking-wide">é€ æˆä¼¤å®³</label>
                            <input 
                                id="damage-input"
                                type="number"
                                min="0"
                                className="w-24 bg-transparent border-b-4 border-red-300 font-mono font-black text-5xl text-red-600 text-center focus:outline-none focus:border-red-600 transition-colors"
                                placeholder="0"
                                value={damageInput}
                                onChange={e => setDamageInput(e.target.value)}
                                onKeyDown={e => { if (e.key === 'Enter') handleApply(); }}
                            />
                        </div>
                        <div className="flex flex-col gap-2">
                            <button 
                                onClick={autoCalcDamage}
                                className="text-xs border-2 border-gray-300 px-3 py-2 font-bold hover:bg-gray-100 hover:border-black transition-colors"
                            >
                                ğŸ² è‡ªåŠ¨è®¡ç®—
                            </button>
                            <div className="text-[10px] text-gray-400 font-mono">
                                {weaponDamage}{db && db !== '0' ? '+' + db : ''}
                            </div>
                        </div>
                    </div>
                </div>
            )}
            
            {/* é€šä¿—æ¨¡å¼æç¤º */}
            {isPulp && isSuccess && (
                <div className="mt-4 p-2 bg-purple-50 border border-purple-200 text-[10px] text-purple-600">
                    ğŸ’¡ ç›®æ ‡å¯ä½¿ç”¨ã€èº²è¿‡ä¸€åŠ«ã€‘(-10å¹¸è¿ï¼Œä¼¤å®³-5) æˆ–ã€æ“¦ä¼¤è€Œå·²ã€‘(-20å¹¸è¿ï¼Œ+1D6 HP)
                </div>
            )}
            
            {/* æ“ä½œæŒ‰é’® */}
            <div className="mt-5 flex gap-3">
                <button 
                    onClick={handleApply}
                    disabled={!rollValue || rollValue < 1 || rollValue > 100}
                    className={`flex-1 h-12 font-black tracking-[0.15em] shadow-hard-sm active:translate-x-1 active:translate-y-1 active:shadow-none transition-all ${
                        rollValue && rollValue >= 1 && rollValue <= 100
                            ? 'bg-black text-white hover:bg-gray-800'
                            : 'bg-gray-200 text-gray-400 cursor-not-allowed shadow-none'
                    }`}
                >
                    åº”ç”¨æ•ˆæœ
                </button>
                <button 
                    onClick={onCancel}
                    className="w-20 h-12 border-2 border-gray-300 font-bold text-gray-400 hover:text-black hover:border-black transition-colors"
                >
                    å–æ¶ˆ
                </button>
            </div>
        </div>
    );
}

// =====================================================
// AutoResolutionCard - è‡ªåŠ¨æ·éª°ç»“ç®—å¡ç‰‡ (v4.3.0 é‡æ„)
// =====================================================
function AutoResolutionCard({ 
    title, targetNumber, roll, successLevel, damage, damageLog,
    attacker, target, isPulp, onApply, onCancel, onLuckSpend, luckAvailable,
    onRollChange, onDamageChange
}) {
    const [editRoll, setEditRoll] = useState(String(roll));
    const [editDamage, setEditDamage] = useState(String(damage || 0));
    
    const isSuccess = successLevel > 0;
    const levelLabels = { 4: 'å¤§æˆåŠŸ', 3: 'æéš¾æˆåŠŸ', 2: 'å›°éš¾æˆåŠŸ', 1: 'å¸¸è§„æˆåŠŸ', 0: 'å¤±è´¥', '-1': 'å¤§å¤±è´¥' };
    const levelColors = { 4: 'text-yellow-500', 3: 'text-green-600', 2: 'text-green-500', 1: 'text-blue-500', 0: 'text-gray-500', '-1': 'text-red-600' };

    return (
        <div className={`resolution-card animate-slide-up ${isSuccess ? 'animate-success' : 'animate-fail'}`}>
            <div className="flex justify-between items-end border-b-2 border-gray-100 pb-2 mb-4">
                <span className="text-lg font-black tracking-widest">{title}</span>
                <span className="text-xs font-mono text-gray-400">ç›®æ ‡ {targetNumber}%</span>
            </div>
            <div className="flex items-start justify-between">
                <div>
                    <div className="text-[10px] font-bold text-gray-400 mb-1 tracking-wide">æ£€å®šç»“æœ <span className="text-gray-300">(å¯ä¿®æ”¹)</span></div>
                    <div className="flex items-baseline gap-3">
                        <input 
                            type="number"
                            className={`w-24 bg-transparent border-b-2 border-dashed ${levelColors[successLevel] || 'text-gray-500'} font-mono font-black text-5xl text-center focus:outline-none`}
                            value={editRoll}
                            onChange={e => { setEditRoll(e.target.value); onRollChange && onRollChange(parseInt(e.target.value)); }}
                        />
                        <span className={`text-sm font-bold ${levelColors[successLevel] || 'text-gray-500'}`}>{levelLabels[successLevel] || 'æœªçŸ¥'}</span>
                    </div>
                </div>
                {isSuccess && damage !== undefined && (
                    <div className="text-right border-l-2 border-gray-200 pl-6">
                        <div className="text-[10px] font-bold text-gray-400 mb-1 tracking-wide">ä¼¤å®³ <span className="text-gray-300">(å¯ä¿®æ”¹)</span></div>
                        <input 
                            type="number"
                            className="w-20 bg-transparent border-b-2 border-dashed border-red-300 font-mono font-black text-4xl text-red-600 text-center focus:outline-none"
                            value={editDamage}
                            onChange={e => { setEditDamage(e.target.value); onDamageChange && onDamageChange(parseInt(e.target.value)); }}
                        />
                        {damageLog && <div className="text-[10px] text-gray-400 font-mono mt-1">{damageLog}</div>}
                    </div>
                )}
            </div>
            {attacker && target && (
                <div className="mt-4 pt-3 border-t border-gray-100 flex justify-between text-xs text-gray-500">
                    <span>æ”»å‡»è€…: <strong className="text-black">{attacker}</strong></span>
                    <span>â†’</span>
                    <span>ç›®æ ‡: <strong className="text-black">{target}</strong></span>
                </div>
            )}
            {isPulp && isSuccess && luckAvailable >= 10 && (
                <div className="mt-4 pt-3 border-t border-dashed border-purple-200 flex flex-wrap gap-2">
                    <button onClick={() => onLuckSpend && onLuckSpend('dodge')} className="px-3 py-2 text-xs font-bold text-purple-600 border border-purple-200 bg-purple-50 hover:bg-purple-100">
                        ğŸ€ èº²è¿‡ä¸€åŠ« (-10å¹¸è¿ï¼Œä¼¤å®³-5)
                    </button>
                </div>
            )}
            <div className="mt-5 flex gap-3">
                <button onClick={() => onApply(parseInt(editDamage) || 0)} className="flex-1 h-12 bg-black text-white font-black tracking-[0.15em] hover:bg-gray-800 shadow-hard-sm active:translate-x-1 active:translate-y-1 active:shadow-none transition-all">
                    åº”ç”¨æ•ˆæœ
                </button>
                <button onClick={onCancel} className="w-20 h-12 border-2 border-gray-300 font-bold text-gray-400 hover:text-black hover:border-black transition-colors">
                    å–æ¶ˆ
                </button>
            </div>
        </div>
    );
}

// =====================================================
// ManualRapidResolutionCard - æ‰‹åŠ¨è¿å°„ç»“ç®—å¡ç‰‡ (v4.3.1)
// =====================================================
function ManualRapidResolutionCard({ 
    title, shots, weaponDamage, db, attacker, target, targetId, onApply, onCancel, hpMultiplier, weapon 
}) {
    const [hitsInput, setHitsInput] = useState('');
    const [damageInputs, setDamageInputs] = useState([]);
    const [phase, setPhase] = useState('hits'); // 'hits' -> 'damage'
    
    const hitsValue = parseInt(hitsInput) || 0;
    
    // å½“è¾“å…¥å‘½ä¸­æ•°åï¼Œåˆå§‹åŒ–ä¼¤å®³è¾“å…¥æ¡†
    const confirmHits = () => {
        if (hitsValue < 0 || hitsValue > shots) return;
        if (hitsValue === 0) {
            onApply({ hits: 0, totalDamage: 0 });
            return;
        }
        setDamageInputs(Array(hitsValue).fill(''));
        setPhase('damage');
    };
    
    // è‡ªåŠ¨è®¡ç®—æ‰€æœ‰ä¼¤å®³
    const autoCalcAllDamage = () => {
        const newDamages = damageInputs.map(() => {
            const dmgResult = calculateDamage(weapon, { db: db || '0' }, 1, false, hpMultiplier);
            return String(dmgResult.total);
        });
        setDamageInputs(newDamages);
    };
    
    const handleApply = () => {
        const totalDamage = damageInputs.reduce((sum, d) => sum + (parseInt(d) || 0), 0);
        onApply({ hits: hitsValue, totalDamage, damages: damageInputs.map(d => parseInt(d) || 0) });
    };
    
    return (
        <div className="resolution-card animate-slide-up">
            <div className="flex justify-between items-end border-b-2 border-orange-200 pb-2 mb-4">
                <span className="text-lg font-black tracking-widest text-orange-600">{title}</span>
                <span className="text-xs font-mono text-gray-400">æ‰‹åŠ¨ç»“ç®—</span>
            </div>
            
            <div className="mb-4 pb-3 border-b border-gray-100 flex justify-between text-xs text-gray-500">
                <span>å°„æ‰‹: <strong className="text-black">{attacker}</strong></span>
                <span>â†’</span>
                <span>ç›®æ ‡: <strong className="text-black">{target}</strong></span>
            </div>
            
            {phase === 'hits' ? (
                <div className="flex items-center gap-6">
                    <div className="flex flex-col">
                        <label className="text-[10px] font-bold text-orange-500 mb-1 tracking-wide">å‘½ä¸­å‘æ•°</label>
                        <input 
                            type="number" 
                            autoFocus
                            min="0"
                            max={shots}
                            className="w-24 bg-transparent border-b-4 border-orange-400 font-mono font-black text-5xl text-center text-orange-600 focus:outline-none"
                            placeholder="0"
                            value={hitsInput}
                            onChange={e => setHitsInput(e.target.value)}
                            onKeyDown={e => { if (e.key === 'Enter') confirmHits(); }}
                        />
                    </div>
                    <div className="flex flex-col justify-center">
                        <div className="text-sm text-gray-400">/ {shots} å‘</div>
                        <div className="text-[10px] text-gray-300 mt-1">è¾“å…¥0è¡¨ç¤ºå…¨éƒ¨è½ç©º</div>
                    </div>
                </div>
            ) : (
                <div>
                    <div className="flex items-center justify-between mb-3">
                        <label className="text-[10px] font-bold text-red-500 tracking-wide">ä¼¤å®³å½•å…¥ ({hitsValue}å‘å‘½ä¸­)</label>
                        <button onClick={autoCalcAllDamage} className="text-[10px] border border-gray-300 px-2 py-1 font-bold hover:bg-gray-100">
                            ğŸ² å…¨éƒ¨è‡ªåŠ¨
                        </button>
                    </div>
                    <div className="grid grid-cols-3 gap-2">
                        {damageInputs.map((dmg, i) => (
                            <div key={i} className="flex flex-col items-center">
                                <div className="text-[9px] text-gray-400 mb-1">ç¬¬{i+1}å‘</div>
                                <input 
                                    type="number"
                                    className="w-16 bg-transparent border-b-2 border-red-300 font-mono font-bold text-2xl text-red-600 text-center focus:outline-none"
                                    placeholder="0"
                                    value={dmg}
                                    onChange={e => {
                                        const newArr = [...damageInputs];
                                        newArr[i] = e.target.value;
                                        setDamageInputs(newArr);
                                    }}
                                />
                            </div>
                        ))}
                    </div>
                    <div className="mt-3 text-right text-sm">
                        æ€»ä¼¤å®³: <span className="font-mono font-black text-red-600 text-xl">{damageInputs.reduce((s, d) => s + (parseInt(d) || 0), 0)}</span>
                    </div>
                </div>
            )}
            
            <div className="mt-5 flex gap-3">
                {phase === 'hits' ? (
                    <button 
                        onClick={confirmHits}
                        disabled={hitsValue < 0 || hitsValue > shots}
                        className={`flex-1 h-12 font-black tracking-[0.15em] shadow-hard-sm transition-all ${
                            hitsValue >= 0 && hitsValue <= shots
                                ? 'bg-orange-500 text-white hover:bg-orange-600'
                                : 'bg-gray-200 text-gray-400 cursor-not-allowed shadow-none'
                        }`}
                    >
                        {hitsValue === 0 ? 'ç¡®è®¤è½ç©º' : `ç¡®è®¤å‘½ä¸­ ${hitsValue} å‘`}
                    </button>
                ) : (
                    <button onClick={handleApply} className="flex-1 h-12 bg-black text-white font-black tracking-[0.15em] hover:bg-gray-800 shadow-hard-sm">
                        åº”ç”¨ä¼¤å®³
                    </button>
                )}
                <button onClick={onCancel} className="w-20 h-12 border-2 border-gray-300 font-bold text-gray-400 hover:text-black hover:border-black transition-colors">
                    å–æ¶ˆ
                </button>
            </div>
        </div>
    );
}

// =====================================================
// ManualAutoFireResolutionCard - æ‰‹åŠ¨å…¨è‡ªåŠ¨ç»“ç®—å¡ç‰‡ (v4.3.1)
// =====================================================
function ManualAutoFireResolutionCard({ 
    title, bullets, attacker, targets, onApply, onCancel 
}) {
    const [bulletsCost, setBulletsCost] = useState(String(bullets));
    const [totalDamage, setTotalDamage] = useState('');
    
    const handleApply = () => {
        onApply({
            bulletsCost: parseInt(bulletsCost) || 0,
            totalDamage: parseInt(totalDamage) || 0
        });
    };
    
    return (
        <div className="resolution-card animate-slide-up">
            <div className="flex justify-between items-end border-b-2 border-red-300 pb-2 mb-4">
                <span className="text-lg font-black tracking-widest text-red-600">{title}</span>
                <span className="text-xs font-mono text-gray-400">æ‰‹åŠ¨ç»“ç®—</span>
            </div>
            
            <div className="mb-4 pb-3 border-b border-gray-100 text-xs text-gray-500">
                <div>å°„æ‰‹: <strong className="text-black">{attacker}</strong></div>
                <div className="mt-1">ç›®æ ‡: <strong className="text-black">{targets}</strong></div>
            </div>
            
            <div className="space-y-4">
                <div className="flex items-center gap-4">
                    <div className="flex flex-col">
                        <label className="text-[10px] font-bold text-gray-500 mb-1">æ¶ˆè€—å¼¹è¯</label>
                        <input 
                            type="number"
                            className="w-20 bg-transparent border-b-2 border-gray-300 font-mono font-bold text-3xl text-center focus:outline-none"
                            value={bulletsCost}
                            onChange={e => setBulletsCost(e.target.value)}
                        />
                    </div>
                    <span className="text-gray-400">å‘</span>
                </div>
                
                <div className="flex items-center gap-4">
                    <div className="flex flex-col">
                        <label className="text-[10px] font-bold text-red-500 mb-1">é€ æˆæ€»ä¼¤å®³</label>
                        <input 
                            type="number"
                            autoFocus
                            className="w-24 bg-transparent border-b-4 border-red-400 font-mono font-black text-5xl text-red-600 text-center focus:outline-none"
                            placeholder="0"
                            value={totalDamage}
                            onChange={e => setTotalDamage(e.target.value)}
                            onKeyDown={e => { if (e.key === 'Enter') handleApply(); }}
                        />
                    </div>
                </div>
            </div>
            
            <div className="mt-5 flex gap-3">
                <button onClick={handleApply} className="flex-1 h-12 bg-red-600 text-white font-black tracking-[0.15em] hover:bg-red-700 shadow-hard-sm">
                    åº”ç”¨æ•ˆæœ
                </button>
                <button onClick={onCancel} className="w-20 h-12 border-2 border-gray-300 font-bold text-gray-400 hover:text-black hover:border-black transition-colors">
                    å–æ¶ˆ
                </button>
            </div>
        </div>
    );
}

// =====================================================
// DiceModifierToggle - éª°å­ä¿®æ­£å¼€å…³ (v4.3.6 æ•°å­—ç‰ˆ)
// =====================================================
function DiceModifierToggle({ value, onChange }) {
    return (
        <div className="modifier-toggle">
            <button onClick={() => onChange(Math.min(3, value + 1))} className={`bonus ${value > 0 ? 'active' : ''}`}>
                ğŸ {value > 0 ? `+${value}` : 'å¥–åŠ±éª°'}
            </button>
            <button onClick={() => onChange(0)} className={value === 0 ? 'active' : ''}>ğŸ² æ ‡å‡†</button>
            <button onClick={() => onChange(Math.max(-3, value - 1))} className={`penalty ${value < 0 ? 'active' : ''}`}>
                ğŸ’€ {value < 0 ? `${value}` : 'æƒ©ç½šéª°'}
            </button>
        </div>
    );
}

// =====================================================
// CombatModule v4.3.0 - æ™ºèƒ½ç»“ç®—å™¨æ¨¡å¼
// =====================================================
function CombatModule({ characters, combatOrder, updateChar, turn, setTurn, logs, addLog, currentActor, startNewRound, saveToHistory, logContainerRef, hpMultiplier }) {
    const [phase, setPhase] = useState('select_action');
    const [selectedTargetId, setSelectedTargetId] = useState(null);
    const [combatAction, setCombatAction] = useState(null);
    const [inputValue, setInputValue] = useState('');
    const [shootingDistance, setShootingDistance] = useState(10);
    const [maneuverType, setManeuverType] = useState('disarm');
    const [mobileTab, setMobileTab] = useState('action');
    const [diceModifier, setDiceModifier] = useState(0); // v4.3.6: æ”¹ä¸ºæ•°å­—è®¡æ•°å™¨
    const [showMedical, setShowMedical] = useState(false); 
    const [medicalType, setMedicalType] = useState(null);
    
    // è¿å°„ä¸å¤šç›®æ ‡çŠ¶æ€
    const [rapidFireShots, setRapidFireShots] = useState(1);
    const [targetInMelee, setTargetInMelee] = useState(false);
    const [autoFireMode, setAutoFireMode] = useState(false);
    const [autoFireBullets, setAutoFireBullets] = useState(6);
    const [multiTargets, setMultiTargets] = useState([]);
    
    // v4.3.6 å°„å‡»ç¯å¢ƒä¿®æ­£
    const [shootingModifiers, setShootingModifiers] = useState({
        targetInCover: false,      // ç›®æ ‡æœ‰æ©ä½“
        targetMoving: false,       // ç›®æ ‡ç§»åŠ¨ä¸­
        shooterMoving: false,      // å°„æ‰‹ç§»åŠ¨ä¸­
        targetSmall: false,        // ç›®æ ‡ä½“å‹å°
        lowVisibility: false,      // ä½èƒ½è§åº¦
    });
    
    const [showStepDice, setShowStepDice] = useState(false);
    const [stepDiceCallback, setStepDiceCallback] = useState(null);
    const [stepDiceTargetNumber, setStepDiceTargetNumber] = useState(null);
    
    // å¹¸è¿æ¶ˆè€—çŠ¶æ€ (é€šä¿—æ¨¡å¼)
    const [luckDamageReduction, setLuckDamageReduction] = useState(0);
    
    // å‘½æ‚¬ä¸€çº¿çŠ¶æ€ (é€šä¿—æ¨¡å¼)
    const [deathsDoorPending, setDeathsDoorPending] = useState(null);
    
    // åŒæªå°„å‡»çŠ¶æ€ (é€šä¿—æ¨¡å¼)
    const [dualWieldMode, setDualWieldMode] = useState(false);
    
    // ç–¯ç‹‚å†²é”‹çŠ¶æ€ (é€šä¿—æ¨¡å¼)
    const [madChargeMode, setMadChargeMode] = useState(false);
    
    // ========== v4.3.0 æ™ºèƒ½ç»“ç®—å™¨çŠ¶æ€ ==========
    const [resolutionCards, setResolutionCards] = useState([]);
    const [inputMode, setInputMode] = useState('manual'); // 'manual' = æ‰‹åŠ¨å½•å…¥(é»˜è®¤), 'auto' = è‡ªåŠ¨æ·éª°
    const [pendingAction, setPendingAction] = useState(null); // å¾…å¤„ç†çš„åŠ¨ä½œ(æ‰‹åŠ¨æ¨¡å¼)

    const targetActor = characters.find(c => c.id === selectedTargetId);

    const nextTurn = () => {
        saveToHistory();
        if (currentActor && (currentActor.attacksLeft || 1) > 1) {
            const newAttacksLeft = (currentActor.attacksLeft || 1) - 1;
            updateChar(currentActor.id, { attacksLeft: newAttacksLeft });
            addLog(`âš”ï¸ ${currentActor.name} ç»§ç»­è¡ŒåŠ¨ (${(currentActor.attacksPerRound || 1) - newAttacksLeft + 1}/${currentActor.attacksPerRound || 1})`, 'system');
            setPhase('select_action'); setSelectedTargetId(null); setCombatAction(null); setInputValue(''); setDiceModifier(0); setShowMedical(false); setMedicalType(null);
            setRapidFireShots(1); setTargetInMelee(false); setAutoFireMode(false); setMultiTargets([]);
            setLuckDamageReduction(0); setDualWieldMode(false); setMadChargeMode(false);
            setResolutionCards([]); setPendingAction(null);
            setShootingModifiers({ targetInCover: false, targetMoving: false, shooterMoving: false, targetSmall: false, lowVisibility: false });
            return;
        }
        const nextIndex = turn.index + 1;
        if (nextIndex >= combatOrder.length) {
            setTurn({ round: turn.round + 1, index: 0 });
            startNewRound();
            addLog(`ğŸ“… ç¬¬ ${turn.round + 1} è½®`, 'system');
        } else {
            setTurn({ ...turn, index: nextIndex });
        }
        setPhase('select_action'); setSelectedTargetId(null); setCombatAction(null); setInputValue(''); setDiceModifier(0); setShowMedical(false); setMedicalType(null);
        setRapidFireShots(1); setTargetInMelee(false); setAutoFireMode(false); setMultiTargets([]);
        setLuckDamageReduction(0); setDualWieldMode(false); setMadChargeMode(false);
        setResolutionCards([]); setPendingAction(null);
        setShootingModifiers({ targetInCover: false, targetMoving: false, shooterMoving: false, targetSmall: false, lowVisibility: false });
    };

    const doRollDirect = () => {
        const result = rollWithModifier(diceModifier);
        const modLabel = diceModifier > 0 ? `${diceModifier}ä¸ªå¥–åŠ±éª°` : diceModifier < 0 ? `${Math.abs(diceModifier)}ä¸ªæƒ©ç½šéª°` : 'æ ‡å‡†éª°';
        if (diceModifier !== 0) addLog(`ğŸ² ${modLabel}: [${result.rolls.join(', ')}] â†’ ${result.result}`, 'roll');
        return result.result;
    };
    
    // ========== v4.3.0 æ™ºèƒ½ç»“ç®—å™¨åŠ¨ä½œå¤„ç† ==========
    
    // å¼€å§‹è¿‘æˆ˜æ”»å‡» (æ ¹æ®inputModeå†³å®šæµç¨‹)
    const startMeleeAttack = () => {
        if (!targetActor || !currentActor) return;
        saveToHistory();
        const weapon = currentActor.meleeWeapon || { name: "æ‹³å¤´", damage: "1D3", type: "melee", impale: false };
        const skillValue = currentActor.fight;
        
        // ç–¯ç‹‚å†²é”‹å¤„ç†
        if (madChargeMode && hpMultiplier === 2) {
            updateChar(currentActor.id, { status: { ...currentActor.status, madChargeUsed: true } });
        }
        
        addLog(`âš”ï¸ ${currentActor.name} â†’ ${targetActor.name} [${weapon.name}]`, 'system');
        
        if (inputMode === 'manual') {
            // æ‰‹åŠ¨æ¨¡å¼ï¼šåˆ›å»ºå¾…å¤„ç†åŠ¨ä½œï¼Œç­‰å¾…KPè¾“å…¥
            setPendingAction({
                id: Date.now(),
                type: 'melee',
                title: madChargeMode ? 'ç–¯ç‹‚å†²é”‹' : 'è¿‘æˆ˜æ”»å‡»',
                targetNumber: skillValue,
                weapon,
                weaponDamage: weapon.damage,
                db: currentActor.db,
                attacker: currentActor.name,
                target: targetActor.name,
                targetId: targetActor.id
            });
        } else {
            // è‡ªåŠ¨æ¨¡å¼ï¼šç«‹å³æ·éª°
            let effectiveModifier = diceModifier;
            if (madChargeMode && hpMultiplier === 2) effectiveModifier = Math.max(effectiveModifier, 1); // ç–¯ç‹‚å†²é”‹è‡³å°‘1ä¸ªå¥–åŠ±éª°
            
            const rollResult = rollWithModifier(effectiveModifier);
            const successLevel = calculateSuccessLevel(rollResult.result, skillValue);
            const modLabel = effectiveModifier > 0 ? `${effectiveModifier}ä¸ªå¥–åŠ±éª°` : effectiveModifier < 0 ? `${Math.abs(effectiveModifier)}ä¸ªæƒ©ç½šéª°` : 'æ ‡å‡†éª°';
            if (effectiveModifier !== 0) addLog(`ğŸ² ${modLabel}: [${rollResult.rolls.join(', ')}] â†’ ${rollResult.result}`, 'roll');
            addLog(`ğŸ² æ”»å‡» [${rollResult.result}/${skillValue}] ${getSuccessLabel(successLevel)}`, 'roll');
            
            let damage = 0, damageLog = '';
            if (successLevel > 0) {
                const dmgResult = calculateDamage(weapon, currentActor, successLevel, false, hpMultiplier);
                damage = dmgResult.total; damageLog = dmgResult.damageLog;
            }
            
            setResolutionCards(prev => [{
                id: Date.now(), title: madChargeMode ? 'ç–¯ç‹‚å†²é”‹' : 'è¿‘æˆ˜æ”»å‡»', targetNumber: skillValue,
                roll: rollResult.result, successLevel, damage: successLevel > 0 ? damage : undefined,
                damageLog: successLevel > 0 ? damageLog : undefined, attacker: currentActor.name,
                target: targetActor.name, targetId: targetActor.id, weapon, type: 'melee', mode: 'auto'
            }, ...prev]);
        }
    };
    
    // å¼€å§‹å°„å‡»æ”»å‡» (æ ¹æ®inputModeå†³å®šæµç¨‹)
    const startRangedAttack = () => {
        if (!targetActor || !currentActor?.rangedWeapon) return;
        if (currentActor.rangedWeapon.ammo <= 0) { addLog(`âŒ å¼¹è¯ä¸è¶³ï¼`, 'system'); return; }
        saveToHistory();
        
        const weapon = currentActor.rangedWeapon;
        let skillValue = currentActor.firearms, difficulty = 'å¸¸è§„';
        if (shootingDistance > weapon.range * 2) { difficulty = 'æéš¾'; skillValue = Math.floor(skillValue / 5); }
        else if (shootingDistance > weapon.range) { difficulty = 'å›°éš¾'; skillValue = Math.floor(skillValue / 2); }
        
        const newAmmo = weapon.ammo - 1;
        updateChar(currentActor.id, { rangedWeapon: { ...weapon, ammo: newAmmo } });
        
        // v4.3.6 è®¡ç®—ç¯å¢ƒæƒ©ç½šéª°
        let environmentPenalty = 0;
        const activeModifiers = [];
        if (shootingModifiers.targetInCover) { environmentPenalty++; activeModifiers.push('æ©ä½“'); }
        if (shootingModifiers.targetMoving) { environmentPenalty++; activeModifiers.push('ç§»åŠ¨ç›®æ ‡'); }
        if (shootingModifiers.shooterMoving) { environmentPenalty++; activeModifiers.push('ç§»åŠ¨å°„å‡»'); }
        if (shootingModifiers.targetSmall) { environmentPenalty++; activeModifiers.push('å°ç›®æ ‡'); }
        if (shootingModifiers.lowVisibility) { environmentPenalty++; activeModifiers.push('ä½èƒ½è§åº¦'); }
        
        addLog(`ğŸ”« ${currentActor.name} â†’ ${targetActor.name} [${weapon.name}] ${difficulty}`, 'system');
        
        // è®°å½•ç¯å¢ƒä¿®æ­£
        if (environmentPenalty > 0) {
            addLog(`âš ï¸ å°„å‡»ä¿®æ­£: ${activeModifiers.join(', ')} (âˆ’${environmentPenalty}æƒ©ç½šéª°)`, 'system');
        }
        
        // åˆå¹¶éª°å­ä¿®æ­£ï¼ˆæ•°å­—ç›¸åŠ ï¼‰
        const effectiveModifier = diceModifier - environmentPenalty;
        
        if (inputMode === 'manual') {
            // æ‰‹åŠ¨æ¨¡å¼ï¼šåˆ›å»ºå¾…å¤„ç†åŠ¨ä½œ
            setPendingAction({
                id: Date.now(),
                type: 'ranged',
                title: 'å°„å‡»æ”»å‡»',
                targetNumber: skillValue,
                weapon,
                weaponDamage: weapon.damage,
                db: '0', // å°„å‡»æ— DB
                attacker: currentActor.name,
                target: targetActor.name,
                targetId: targetActor.id,
                difficulty,
                malfunction: weapon.malfunction,
                environmentPenalty, // ä¿å­˜ç¯å¢ƒæƒ©ç½šä¾›æ‰‹åŠ¨æ¨¡å¼å‚è€ƒ
                effectiveModifier
            });
        } else {
            // è‡ªåŠ¨æ¨¡å¼ï¼šç«‹å³æ·éª°ï¼ˆä½¿ç”¨åˆå¹¶åçš„ä¿®æ­£å€¼ï¼‰
            const rollResult = rollWithModifier(effectiveModifier);
            const successLevel = calculateSuccessLevel(rollResult.result, skillValue);
            
            if (rollResult.result >= weapon.malfunction) {
                addLog(`ğŸ’¥ æ­¦å™¨æ•…éšœï¼`, 'damage');
                nextTurn(); return;
            }
            
            const modLabel = effectiveModifier > 0 ? `${effectiveModifier}ä¸ªå¥–åŠ±éª°` : effectiveModifier < 0 ? `${Math.abs(effectiveModifier)}ä¸ªæƒ©ç½šéª°` : 'æ ‡å‡†éª°';
            if (effectiveModifier !== 0) addLog(`ğŸ² ${modLabel}: [${rollResult.rolls.join(', ')}] â†’ ${rollResult.result}`, 'roll');
            addLog(`ğŸ² å°„å‡» [${rollResult.result}/${skillValue}] ${getSuccessLabel(successLevel)}`, 'roll');
            
            let damage = 0, damageLog = '';
            if (successLevel > 0) {
                const dmgResult = calculateDamage(weapon, currentActor, successLevel, false, hpMultiplier);
                damage = dmgResult.total; damageLog = dmgResult.damageLog;
            }
            
            setResolutionCards(prev => [{
                id: Date.now(), title: 'å°„å‡»æ”»å‡»', targetNumber: skillValue, roll: rollResult.result, successLevel,
                damage: successLevel > 0 ? damage : undefined, damageLog: successLevel > 0 ? damageLog : undefined,
                attacker: currentActor.name, target: targetActor.name, targetId: targetActor.id, weapon, type: 'ranged', difficulty, mode: 'auto'
            }, ...prev]);
        }
    };
    
    // åº”ç”¨æ‰‹åŠ¨è¾“å…¥çš„ç»“æœ
    const applyManualResult = (result) => {
        if (!pendingAction) return;
        
        const { roll, successLevel, damage, damageLog } = result;
        
        addLog(`ğŸ² æ£€å®š [${roll}/${pendingAction.targetNumber}] ${getSuccessLabel(successLevel)}`, 'roll');
        
        if (successLevel <= 0) {
            addLog(`ğŸ’¨ æ”»å‡»æœªå‘½ä¸­`, 'system');
            setPendingAction(null);
            nextTurn();
            return;
        }
        
        // åº”ç”¨ä¼¤å®³
        const target = characters.find(c => c.id === pendingAction.targetId);
        if (!target) { setPendingAction(null); return; }
        
        const actualDamage = Math.max(0, damage - (target.armorValue || 0) - luckDamageReduction);
        const newHp = Math.max(0, target.hp - actualDamage);
        let newStatus = { ...target.status };
        
        if (hpMultiplier === 2 && target.isMook && actualDamage > 0) {
            updateChar(target.id, { hp: 0, status: { ...target.status, unconscious: true } });
            addLog(`ğŸ’€ ${target.name} [å–½å•°] è¢«å‡»å€’ï¼`, 'damage');
        } else {
            if (hpMultiplier === 2) {
                if (newHp === 0 && (target.luck || 0) >= 30) {
                    setDeathsDoorPending({ targetId: target.id, damage, actualDamage, newHp, newStatus: { ...newStatus, unconscious: true }, damageLog });
                    addLog(`âš ï¸ ${target.name} å³å°†å€’ä¸‹ï¼å¯ä½¿ç”¨ã€å‘½æ‚¬ä¸€çº¿ã€‘`, 'system');
                    setPendingAction(null);
                    return;
                }
                if (newHp === 0) newStatus.unconscious = true;
            } else {
                const isMajorWound = actualDamage >= Math.floor(target.maxHp / 2);
                if (isMajorWound) { newStatus.majorWound = true; newStatus.prone = true; addLog(`ğŸ’€ ${target.name} å—åˆ°äº†é‡ä¼¤ï¼`, 'damage'); }
                if (newHp === 0 && newStatus.majorWound) { newStatus.dying = true; addLog(`âš ï¸ ${target.name} æ¿’æ­»ï¼`, 'damage'); }
            }
            
            updateChar(target.id, { hp: newHp, status: newStatus });
            const luckDetail = luckDamageReduction > 0 ? ` ğŸ€-${luckDamageReduction}` : '';
            addLog(`ğŸ’¥ ${target.name} -${actualDamage} HP [${damageLog}]${luckDetail} (${target.hp}â†’${newHp})`, 'damage');
            
            if (hpMultiplier === 2 && newHp === 0) addLog(`ğŸ’« ${target.name} æ˜è¿·ï¼`, 'damage');
        }
        
        setPendingAction(null);
        setLuckDamageReduction(0);
        nextTurn();
    };
    
    // å–æ¶ˆæ‰‹åŠ¨è¾“å…¥
    const cancelManualAction = () => {
        setPendingAction(null);
    };
    
    // ========== v4.3.1 å°„å‡»ç»Ÿä¸€å…¥å£ ==========
    const handleShootClick = () => {
        if (!targetActor || !currentActor?.rangedWeapon) return;
        const weapon = currentActor.rangedWeapon;
        
        // 1. å¼¹è¯æ£€æŸ¥
        const cost = dualWieldMode ? 2 : (autoFireMode ? autoFireBullets : rapidFireShots);
        if (weapon.ammo < cost) {
            addLog(`âŒ å¼¹è¯ä¸è¶³ (éœ€è¦ ${cost} å‘ï¼Œå‰©ä½™ ${weapon.ammo})`, 'system');
            return;
        }
        
        // 2. æ¨¡å¼åˆ†æµ
        if (dualWieldMode) {
            handleDualWieldAttack();
        } else if (autoFireMode) {
            startAutoFire();
        } else if (rapidFireShots > 1) {
            startRapidFire();
        } else {
            startRangedAttack();
        }
    };
    
    // è¿å°„æ”»å‡»
    const startRapidFire = () => {
        if (!targetActor || !currentActor?.rangedWeapon) return;
        const weapon = currentActor.rangedWeapon;
        
        saveToHistory();
        
        // æ‰£é™¤å¼¹è¯
        updateChar(currentActor.id, { 
            rangedWeapon: { ...weapon, ammo: weapon.ammo - rapidFireShots } 
        });
        
        // è®¡ç®—éš¾åº¦
        let skillValue = currentActor.firearms, difficulty = 'å¸¸è§„';
        if (shootingDistance > weapon.range * 2) { difficulty = 'æéš¾'; skillValue = Math.floor(skillValue / 5); }
        else if (shootingDistance > weapon.range) { difficulty = 'å›°éš¾'; skillValue = Math.floor(skillValue / 2); }
        
        addLog(`ğŸ”« ${currentActor.name} è¿å°„${rapidFireShots}å‘ â†’ ${targetActor.name} [${weapon.name}]${targetInMelee ? ' âš ï¸è¿‘æˆ˜ä¸­' : ''}`, 'system');
        
        if (inputMode === 'manual') {
            // æ‰‹åŠ¨æ¨¡å¼ï¼šå¼¹å‡ºè¿å°„ç»“ç®—å¡ç‰‡
            setPendingAction({
                id: Date.now(),
                type: 'manual_rapid',
                title: `è¿å°„ Ã—${rapidFireShots}`,
                shots: rapidFireShots,
                targetNumber: skillValue,
                weapon,
                weaponDamage: weapon.damage,
                db: '0',
                attacker: currentActor.name,
                target: targetActor.name,
                targetId: targetActor.id,
                difficulty
            });
        } else {
            // è‡ªåŠ¨æ¨¡å¼ï¼šé€å‘æ£€å®š (ç®€åŒ–ä¸ºæ€»å‘½ä¸­æ•°)
            let hits = 0;
            for (let i = 0; i < rapidFireShots; i++) {
                const rollResult = rollWithModifier(-1); // v4.3.6ä¿®å¤: è¿å°„æƒ©ç½šéª°æ”¹ä¸ºæ•°å­—-1
                const successLevel = calculateSuccessLevel(rollResult.result, skillValue);
                addLog(`ğŸ² ç¬¬${i+1}å‘ [${rollResult.result}/${skillValue}] ${getSuccessLabel(successLevel)}`, 'roll');
                if (successLevel > 0) hits++;
            }
            
            if (hits === 0) {
                addLog(`ğŸ’¨ å…¨éƒ¨è½ç©ºï¼`, 'system');
                nextTurn();
                return;
            }
            
            addLog(`âœ… å‘½ä¸­ ${hits} å‘ï¼`, 'success');
            
            // è®¡ç®—æ€»ä¼¤å®³
            let totalDamage = 0;
            for (let i = 0; i < hits; i++) {
                const dmgResult = calculateDamage(weapon, currentActor, 1, false, hpMultiplier);
                totalDamage += dmgResult.total;
            }
            
            setResolutionCards(prev => [{
                id: Date.now(), title: `è¿å°„å‘½ä¸­${hits}å‘`, targetNumber: skillValue, roll: 0, successLevel: 1,
                damage: totalDamage, damageLog: `${hits}Ã—${weapon.damage}`,
                attacker: currentActor.name, target: targetActor.name, targetId: targetActor.id, weapon, type: 'rapid', mode: 'auto'
            }, ...prev]);
        }
    };
    
    // å…¨è‡ªåŠ¨æ”»å‡»
    const startAutoFire = () => {
        if (!targetActor || !currentActor?.rangedWeapon) return;
        const weapon = currentActor.rangedWeapon;
        
        saveToHistory();
        
        // æ‰£é™¤å¼¹è¯
        updateChar(currentActor.id, { 
            rangedWeapon: { ...weapon, ammo: weapon.ammo - autoFireBullets } 
        });
        
        addLog(`ğŸ”« ${currentActor.name} å…¨è‡ªåŠ¨å°„å‡» ${autoFireBullets}å‘ â†’ ${targetActor.name} [${weapon.name}]`, 'system');
        
        if (inputMode === 'manual') {
            // æ‰‹åŠ¨æ¨¡å¼ï¼šå¼¹å‡ºå…¨è‡ªåŠ¨ç»“ç®—å¡ç‰‡
            setPendingAction({
                id: Date.now(),
                type: 'manual_autofire',
                title: `å…¨è‡ªåŠ¨å°„å‡»`,
                bullets: autoFireBullets,
                attacker: currentActor.name,
                targets: targetActor.name,
                targetId: targetActor.id,
                weapon
            });
        } else {
            // è‡ªåŠ¨æ¨¡å¼ï¼šç®€åŒ–è®¡ç®—
            const volleySize = getVolleySize();
            const totalVolleys = Math.ceil(autoFireBullets / volleySize);
            let hits = 0;
            const skillValue = currentActor.firearms;
            
            for (let v = 0; v < totalVolleys; v++) {
                const rollResult = rollWithModifier(0); // v4.3.6ä¿®å¤: æ ‡å‡†éª°æ”¹ä¸ºæ•°å­—0
                const successLevel = calculateSuccessLevel(rollResult.result, skillValue);
                addLog(`ğŸ² å¼¹å¹•${v+1} [${rollResult.result}/${skillValue}] ${getSuccessLabel(successLevel)}`, 'roll');
                if (successLevel > 0) hits += volleySize;
            }
            
            if (hits === 0) {
                addLog(`ğŸ’¨ å…¨éƒ¨è½ç©ºï¼`, 'system');
                nextTurn();
                return;
            }
            
            addLog(`âœ… å‘½ä¸­çº¦ ${hits} å‘ï¼`, 'success');
            
            let totalDamage = 0;
            for (let i = 0; i < Math.min(hits, autoFireBullets); i++) {
                const dmgResult = calculateDamage(weapon, currentActor, 1, false, hpMultiplier);
                totalDamage += dmgResult.total;
            }
            
            setResolutionCards(prev => [{
                id: Date.now(), title: `å…¨è‡ªåŠ¨å‘½ä¸­`, targetNumber: skillValue, roll: 0, successLevel: 1,
                damage: totalDamage, damageLog: `${hits}Ã—${weapon.damage}`,
                attacker: currentActor.name, target: targetActor.name, targetId: targetActor.id, weapon, type: 'autofire', mode: 'auto'
            }, ...prev]);
        }
    };
    
    // åº”ç”¨è¿å°„ç»“æœ (æ‰‹åŠ¨æ¨¡å¼)
    const applyRapidResult = (result) => {
        if (!pendingAction) return;
        
        const { hits, totalDamage, damages } = result;
        
        if (hits === 0) {
            addLog(`ğŸ’¨ è¿å°„å…¨éƒ¨è½ç©ºï¼`, 'system');
            setPendingAction(null);
            nextTurn();
            return;
        }
        
        addLog(`âœ… è¿å°„å‘½ä¸­ ${hits} å‘ï¼Œé€ æˆ ${totalDamage} ç‚¹ä¼¤å®³`, 'success');
        
        const target = characters.find(c => c.id === pendingAction.targetId);
        if (!target) { setPendingAction(null); return; }
        
        const actualDamage = Math.max(0, totalDamage - (target.armorValue || 0));
        const newHp = Math.max(0, target.hp - actualDamage);
        
        if (hpMultiplier === 2 && target.isMook && actualDamage > 0) {
            updateChar(target.id, { hp: 0, status: { ...target.status, unconscious: true } });
            addLog(`ğŸ’€ ${target.name} [å–½å•°] è¢«å‡»å€’ï¼`, 'damage');
        } else {
            updateChar(target.id, { hp: newHp });
            addLog(`ğŸ’¥ ${target.name} -${actualDamage} HP (${target.hp}â†’${newHp})`, 'damage');
            if (newHp === 0) addLog(`ğŸ’« ${target.name} å€’ä¸‹äº†ï¼`, 'damage');
        }
        
        setPendingAction(null);
        nextTurn();
    };
    
    // åº”ç”¨å…¨è‡ªåŠ¨ç»“æœ (æ‰‹åŠ¨æ¨¡å¼)
    const applyAutoFireResult = (result) => {
        if (!pendingAction) return;
        
        const { bulletsCost, totalDamage } = result;
        
        if (totalDamage === 0) {
            addLog(`ğŸ’¨ å…¨è‡ªåŠ¨å°„å‡»æ— æ•ˆæœ`, 'system');
            setPendingAction(null);
            nextTurn();
            return;
        }
        
        addLog(`ğŸ”¥ å…¨è‡ªåŠ¨é€ æˆ ${totalDamage} ç‚¹ä¼¤å®³`, 'success');
        
        const target = characters.find(c => c.id === pendingAction.targetId);
        if (!target) { setPendingAction(null); return; }
        
        const actualDamage = Math.max(0, totalDamage - (target.armorValue || 0));
        const newHp = Math.max(0, target.hp - actualDamage);
        
        if (hpMultiplier === 2 && target.isMook && actualDamage > 0) {
            updateChar(target.id, { hp: 0, status: { ...target.status, unconscious: true } });
            addLog(`ğŸ’€ ${target.name} [å–½å•°] è¢«å‡»å€’ï¼`, 'damage');
        } else {
            updateChar(target.id, { hp: newHp });
            addLog(`ğŸ’¥ ${target.name} -${actualDamage} HP (${target.hp}â†’${newHp})`, 'damage');
            if (newHp === 0) addLog(`ğŸ’« ${target.name} å€’ä¸‹äº†ï¼`, 'damage');
        }
        
        setPendingAction(null);
        nextTurn();
    };
    
    // ä¿ç•™æ—§å‡½æ•°åä½œä¸ºåˆ«å(å‘åå…¼å®¹)
    const instantMeleeAttack = startMeleeAttack;
    const instantRangedAttack = startRangedAttack;
    
    const applyResolutionCard = (card, customDamage) => {
        const finalDamage = customDamage !== undefined ? customDamage : card.damage;
        if (card.successLevel <= 0) {
            addLog(`ğŸ’¨ æ”»å‡»æœªå‘½ä¸­`, 'system');
        } else {
            const target = characters.find(c => c.id === card.targetId);
            if (!target) return;
            const actualDamage = Math.max(0, finalDamage - (target.armorValue || 0) - luckDamageReduction);
            const newHp = Math.max(0, target.hp - actualDamage);
            let newStatus = { ...target.status };
            if (hpMultiplier === 2 && target.isMook && actualDamage > 0) {
                updateChar(target.id, { hp: 0, status: { ...target.status, unconscious: true } });
                addLog(`ğŸ’€ ${target.name} [å–½å•°] è¢«å‡»å€’ï¼`, 'damage');
            } else {
                if (hpMultiplier === 2) {
                    if (newHp === 0 && (target.luck || 0) >= 30) {
                        setDeathsDoorPending({ targetId: target.id, damage: finalDamage, actualDamage, newHp, newStatus: { ...newStatus, unconscious: true }, damageLog: card.damageLog });
                        addLog(`âš ï¸ ${target.name} å³å°†å€’ä¸‹ï¼å¯ä½¿ç”¨ã€å‘½æ‚¬ä¸€çº¿ã€‘`, 'system');
                        setResolutionCards(prev => prev.filter(c => c.id !== card.id));
                        return;
                    }
                    if (newHp === 0) newStatus.unconscious = true;
                } else {
                    const isMajorWound = actualDamage >= Math.floor(target.maxHp / 2);
                    if (isMajorWound) { newStatus.majorWound = true; newStatus.prone = true; addLog(`ğŸ’€ ${target.name} å—åˆ°äº†é‡ä¼¤ï¼`, 'damage'); }
                    if (newHp === 0 && newStatus.majorWound) { newStatus.dying = true; addLog(`âš ï¸ ${target.name} æ¿’æ­»ï¼`, 'damage'); }
                }
                updateChar(target.id, { hp: newHp, status: newStatus });
                const luckDetail = luckDamageReduction > 0 ? ` ğŸ€-${luckDamageReduction}` : '';
                addLog(`ğŸ’¥ ${target.name} -${actualDamage} HP [${card.damageLog}]${luckDetail} (${target.hp}â†’${newHp})`, 'damage');
                if (hpMultiplier === 2 && newHp === 0) addLog(`ğŸ’« ${target.name} æ˜è¿·ï¼`, 'damage');
            }
        }
        setResolutionCards(prev => prev.filter(c => c.id !== card.id));
        setLuckDamageReduction(0);
        nextTurn();
    };
    
    const cancelResolutionCard = (cardId) => setResolutionCards(prev => prev.filter(c => c.id !== cardId));

    const openStepDiceRoller = (targetNumber, callback) => {
        setStepDiceTargetNumber(targetNumber); setStepDiceCallback(() => callback); setShowStepDice(true);
    };

    const handleStepDiceComplete = (result) => {
        if (diceModifier === 'bonus') addLog(`ğŸ² å¥–åŠ±éª°: æœ€ç»ˆç»“æœ â†’ ${result}`, 'roll');
        else if (diceModifier === 'penalty') addLog(`ğŸ² æƒ©ç½šéª°: æœ€ç»ˆç»“æœ â†’ ${result}`, 'roll');
        else addLog(`ğŸ² æ ‡å‡†éª°: ${result}`, 'roll');
        setInputValue(String(result)); setShowStepDice(false);
        if (stepDiceCallback) stepDiceCallback(result);
    };

    const handleMeleeAttack = () => {
        if (!targetActor) return;
        saveToHistory();
        const weapon = currentActor.meleeWeapon || { name: "æ‹³å¤´", damage: "1D3", type: "melee", impale: false };
        
        // ç–¯ç‹‚å†²é”‹ (é€šä¿—æ¨¡å¼): å†²é”‹æ”»å‡»è·å¾—å¥–åŠ±éª°ï¼Œä½†æœ¬è½®æ— æ³•é—ªé¿ï¼Œä¸”é˜²å¾¡è€…åå‡»ä¹Ÿè·å¾—å¥–åŠ±éª°
        if (madChargeMode && hpMultiplier === 2) {
            // æ ‡è®°å½“å‰è§’è‰²æœ¬è½®ä½¿ç”¨äº†ç–¯ç‹‚å†²é”‹ï¼ˆæ— æ³•é—ªé¿ï¼‰
            updateChar(currentActor.id, { status: { ...currentActor.status, madChargeUsed: true } });
            setCombatAction({ type: 'melee', attacker: currentActor, target: targetActor, weapon, attackerSkill: currentActor.fight, madCharge: true });
            setDiceModifier(1); // v4.3.6ä¿®å¤: è®¾ç½®ä¸ºå¥–åŠ±éª°(æ•°å­—1)
            addLog(`ğŸƒğŸ’¨ ${currentActor.name} ç–¯ç‹‚å†²é”‹ â†’ ${targetActor.name} [${weapon.name}] (æ”»å‡»å¥–åŠ±éª°Â·æ— æ³•é—ªé¿Â·åå‡»å¥–åŠ±éª°)`, 'system');
        } else {
            setCombatAction({ type: 'melee', attacker: currentActor, target: targetActor, weapon, attackerSkill: currentActor.fight });
            addLog(`âš”ï¸ ${currentActor.name} â†’ ${targetActor.name} [${weapon.name}]`, 'system');
        }
        setPhase('waiting_defense');
    };

    const handleRangedAttack = () => {
        if (!targetActor || !currentActor.rangedWeapon) return;
        if (currentActor.rangedWeapon.ammo <= 0) { addLog(`âŒ NO AMMO!`, 'system'); return; }
        saveToHistory();
        const weapon = currentActor.rangedWeapon;
        let difficulty = 'regular';
        if (shootingDistance > weapon.range * 2) difficulty = 'extreme';
        else if (shootingDistance > weapon.range) difficulty = 'hard';
        setCombatAction({ type: 'ranged', attacker: currentActor, target: targetActor, weapon, distance: shootingDistance, difficulty });
        setPhase('input_roll');
        addLog(`ğŸ”« ${currentActor.name} â†’ ${targetActor.name} [${weapon.name}] ${difficulty.toUpperCase()}`, 'system');
    };

    const handleManeuver = () => {
        if (!targetActor) return;
        saveToHistory();
        const buildDiff = targetActor.build - currentActor.build;
        if (buildDiff >= 3) { addLog(`âŒ BUILDå·®è·è¿‡å¤§(${buildDiff})ï¼Œæˆ˜æŠ€æ— æ•ˆ`, 'system'); return; }
        setCombatAction({ type: 'maneuver', attacker: currentActor, target: targetActor, maneuverType, penaltyDice: Math.max(0, buildDiff), attackerSkill: currentActor.fight });
        setPhase('waiting_defense');
        addLog(`ğŸ¤¼ ${currentActor.name} â†’ ${targetActor.name} [${maneuverType}]`, 'system');
    };
    
    // =====================================================
    // åŒæªå°„å‡» (Dual Wield) - é€šä¿—æ¨¡å¼ä¸“å±
    // =====================================================
    const handleDualWieldAttack = () => {
        if (!targetActor || !currentActor.rangedWeapon || hpMultiplier !== 2) return;
        const weapon = currentActor.rangedWeapon;
        
        if (weapon.ammo < 2) {
            addLog(`âŒ å¼¹è¯ä¸è¶³! åŒæªéœ€è¦è‡³å°‘2å‘`, 'system');
            return;
        }
        
        saveToHistory();
        
        // æ‰£é™¤å¼¹è¯ (ä¸¤æŠŠæªå„ä¸€å‘)
        updateChar(currentActor.id, { 
            rangedWeapon: { ...weapon, ammo: weapon.ammo - 2 } 
        });
        
        // è®¡ç®—éš¾åº¦
        let difficulty = 'regular';
        if (shootingDistance > weapon.range * 2) difficulty = 'extreme';
        else if (shootingDistance > weapon.range) difficulty = 'hard';
        
        setCombatAction({
            type: 'dual_wield',
            shotsTotal: 2,
            shotsCurrent: 0,
            hits: [],
            weapon,
            target: targetActor,
            difficulty
        });
        setPhase('dual_wield_roll');
        setInputValue('');
        
        addLog(`ğŸ”«ğŸ”« ${currentActor.name} åŒæªå°„å‡» â†’ ${targetActor.name} [${weapon.name} Ã—2]`, 'system');
    };
    
    // åŒæªå•å‘æ£€å®š
    const handleDualWieldShot = () => {
        const roll = parseInt(inputValue);
        if (!roll || roll < 1 || roll > 100) return;
        
        const shotNum = combatAction.shotsCurrent + 1;
        const isOffhand = shotNum === 2; // ç¬¬äºŒå‘æ˜¯å‰¯æ‰‹
        
        // è®¡ç®—æœ‰æ•ˆæŠ€èƒ½å€¼
        let skillValue = currentActor.firearms;
        if (combatAction.difficulty === 'hard') skillValue = Math.floor(skillValue / 2);
        if (combatAction.difficulty === 'extreme') skillValue = Math.floor(skillValue / 5);
        
        const successLevel = calculateSuccessLevel(roll, skillValue);
        const handLabel = isOffhand ? 'å‰¯æ‰‹' : 'ä¸»æ‰‹';
        
        // æ£€æŸ¥æ•…éšœ
        if (roll >= combatAction.weapon.malfunction) {
            addLog(`ğŸ’¥ ${handLabel}æ­¦å™¨æ•…éšœï¼`, 'damage');
            const newHits = [...combatAction.hits, { level: 0, malfunction: true }];
            
            if (shotNum >= 2 || newHits.length >= 2) {
                // æ£€æŸ¥æ˜¯å¦æœ‰å‘½ä¸­éœ€è¦å¤„ç†ä¼¤å®³
                const validHits = newHits.filter(h => h.level > 0);
                if (validHits.length > 0) {
                    setCombatAction(prev => ({ ...prev, hits: validHits, currentHitIndex: 0 }));
                    setPhase('dual_wield_damage');
                } else {
                    nextTurn();
                }
            } else {
                setCombatAction(prev => ({ ...prev, shotsCurrent: shotNum, hits: newHits }));
                setDiceModifier(-1); // å‰¯æ‰‹æƒ©ç½šéª°
            }
            setInputValue('');
            return;
        }
        
        const newHits = [...combatAction.hits];
        if (successLevel > 0) {
            newHits.push({ level: successLevel, roll, hand: handLabel });
            addLog(`ğŸ¯ ${handLabel}å‘½ä¸­ [${roll}/${skillValue}] ${getSuccessLabel(successLevel)}`, 'roll');
        } else {
            newHits.push({ level: 0, roll, hand: handLabel });
            addLog(`ğŸ’¨ ${handLabel}æœªå‘½ä¸­ [${roll}/${skillValue}]`, 'roll');
        }
        
        if (shotNum >= 2) {
            // åŒæªæ£€å®šå®Œæˆ
            const validHits = newHits.filter(h => h.level > 0);
            if (validHits.length > 0) {
                addLog(`ğŸ“Š åŒæªå‘½ä¸­ ${validHits.length}/2 å‘`, 'system');
                setCombatAction(prev => ({ ...prev, hits: validHits, currentHitIndex: 0 }));
                setPhase('dual_wield_damage');
            } else {
                addLog(`ğŸ’¨ åŒæªå…¨éƒ¨è½ç©º`, 'system');
                nextTurn();
            }
        } else {
            // ç»§ç»­ç¬¬äºŒå‘
            setCombatAction(prev => ({ ...prev, shotsCurrent: shotNum, hits: newHits }));
            setDiceModifier(-1); // å‰¯æ‰‹æƒ©ç½šéª°
            addLog(`ğŸ”« å‡†å¤‡å‰¯æ‰‹å°„å‡»ï¼ˆæƒ©ç½šéª°ï¼‰`, 'system');
        }
        setInputValue('');
    };
    
    // åŒæªä¼¤å®³å¤„ç†
    const handleDualWieldDamage = () => {
        const damage = parseInt(inputValue) || 0;
        const target = combatAction.target;
        const actualDamage = Math.max(0, damage - (target.armorValue || 0));
        const newHp = Math.max(0, target.hp - actualDamage);
        let newStatus = { ...target.status };
        
        // é€šä¿—æ¨¡å¼ï¼šHPå½’é›¶æ—¶æ˜è¿·
        if (newHp === 0) { newStatus.unconscious = true; addLog(`ğŸ’« ${target.name} æ˜è¿· Unconscious!`, 'damage'); }
        
        updateChar(target.id, { hp: newHp, status: newStatus });
        const logDetail = combatAction.currentDamageLog ? ` [${combatAction.currentDamageLog}]` : '';
        const hitInfo = combatAction.hits[combatAction.currentHitIndex];
        addLog(`ğŸ’¥ ${target.name} -${actualDamage} HP (${hitInfo?.hand || ''}${logDetail}) (${target.hp}â†’${newHp})`, 'damage');
        
        const nextHitIndex = combatAction.currentHitIndex + 1;
        if (nextHitIndex < combatAction.hits.length) {
            setCombatAction({ ...combatAction, currentHitIndex: nextHitIndex, currentDamageLog: null });
            setInputValue('');
        } else {
            nextTurn();
        }
    };

    // =====================================================
    // è¿å°„åŠŸèƒ½ (Rapid Fire) - æ¯å‘å¸¦æƒ©ç½šéª°
    // =====================================================
    const handleRapidFire = () => {
        if (!targetActor || !currentActor.rangedWeapon) return;
        const weapon = currentActor.rangedWeapon;
        
        if (weapon.ammo < rapidFireShots) {
            addLog(`âŒ å¼¹è¯ä¸è¶³! éœ€è¦${rapidFireShots}å‘, å‰©ä½™${weapon.ammo}`, 'system');
            return;
        }
        
        saveToHistory();
        
        // æ‰£é™¤å¼¹è¯
        updateChar(currentActor.id, { 
            rangedWeapon: { ...weapon, ammo: weapon.ammo - rapidFireShots } 
        });
        
        // è®¡ç®—éš¾åº¦
        let difficulty = 'regular';
        if (shootingDistance > weapon.range * 2) difficulty = 'extreme';
        else if (shootingDistance > weapon.range) difficulty = 'hard';
        
        setCombatAction({
            type: 'rapid_fire',
            shotsTotal: rapidFireShots,
            shotsCurrent: 0,
            hits: [],
            weapon,
            target: targetActor,
            difficulty,
            targetInMelee // æ˜¯å¦å°„å‡»è¿‘æˆ˜ä¸­ç›®æ ‡
        });
        setPhase('rapid_fire_roll');
        setDiceModifier(-1); // è¿å°„é»˜è®¤æƒ©ç½šéª°
        setInputValue('');
        
        addLog(`ğŸ”« ${currentActor.name} è¿å°„${rapidFireShots}å‘ â†’ ${targetActor.name} [${weapon.name}]${targetInMelee ? ' âš ï¸è¿‘æˆ˜ä¸­' : ''}`, 'system');
    };

    // è¿å°„å•å‘æ£€å®š
    const handleRapidFireShot = () => {
        const roll = parseInt(inputValue);
        if (!roll || roll < 1 || roll > 100) return;
        
        const shotNum = combatAction.shotsCurrent + 1;
        
        // è®¡ç®—æœ‰æ•ˆæŠ€èƒ½å€¼
        let skillValue = currentActor.firearms;
        if (combatAction.difficulty === 'hard') skillValue = Math.floor(skillValue / 2);
        if (combatAction.difficulty === 'extreme') skillValue = Math.floor(skillValue / 5);
        
        const successLevel = calculateSuccessLevel(roll, skillValue);
        
        // æ£€æŸ¥å¤§å¤±è´¥ï¼ˆå°„å‡»è¿‘æˆ˜ä¸­ç›®æ ‡æ—¶å¯èƒ½è¯¯ä¼¤ï¼‰
        let fumbleHit = null;
        if (combatAction.targetInMelee && (roll >= 96 || (roll === 100))) {
            const friendlies = characters.filter(c => c.type === 'player' && c.id !== currentActor.id);
            if (friendlies.length > 0) {
                const unlucky = friendlies.reduce((min, c) => (c.luck || 50) < (min.luck || 50) ? c : min);
                fumbleHit = unlucky;
                addLog(`ğŸ’€ å¤§å¤±è´¥! ${unlucky.name} è¢«è¯¯ä¼¤!`, 'damage');
            }
        }
        
        const modifierLabel = diceModifier === 'penalty' ? 'æƒ©ç½šéª°' : diceModifier === 'bonus' ? 'å¥–åŠ±éª°' : 'æ ‡å‡†éª°';
        addLog(`ğŸ² ç¬¬${shotNum}å‘ [${roll}/${skillValue}] (${modifierLabel}) â†’ ${getSuccessLabel(successLevel)}`, 'roll');
        
        const newHits = successLevel > 0 ? [...combatAction.hits, { roll, level: successLevel }] : combatAction.hits;
        const newAction = {
            ...combatAction,
            shotsCurrent: shotNum,
            hits: newHits,
            fumbleHit
        };
        
        if (shotNum >= combatAction.shotsTotal) {
            // æ‰€æœ‰å°„å‡»å®Œæˆ
            if (newHits.length > 0) {
                addLog(`âœ… å‘½ä¸­${newHits.length}å‘!`, 'success');
                setCombatAction({ ...newAction, hitsRemaining: newHits.length, currentHitIndex: 0 });
                setPhase('rapid_fire_damage');
            } else {
                addLog(`ğŸ’¨ å…¨éƒ¨è½ç©º!`, 'roll');
                nextTurn();
            }
        } else {
            setCombatAction(newAction);
            setInputValue('');
        }
    };

    // è¿å°„ä¼¤å®³å¤„ç†
    const handleRapidFireDamage = () => {
        const damage = parseInt(inputValue) || 0;
        const target = combatAction.target;
        const actualDamage = Math.max(0, damage - (target.armorValue || 0));
        const newHp = Math.max(0, target.hp - actualDamage);
        let newStatus = { ...target.status };
        
        // é€šä¿—æ¨¡å¼ä¸‹ç¦ç”¨é‡ä¼¤è§„åˆ™
        if (hpMultiplier === 1) {
            // æ ‡å‡†æ¨¡å¼ï¼šæ£€æŸ¥é‡ä¼¤
            const isMajorWound = actualDamage >= Math.floor(target.maxHp / 2);
            if (isMajorWound) {
                newStatus.majorWound = true;
                newStatus.prone = true;
                addLog(`ğŸ’€ ${target.name} é‡ä¼¤ Major Wound!`, 'damage');
            }
            if (newHp === 0 && newStatus.majorWound) {
                newStatus.dying = true;
                addLog(`âš ï¸ ${target.name} æ¿’æ­» Dying!`, 'damage');
            }
        } else {
            // é€šä¿—æ¨¡å¼ï¼šHPå½’é›¶æ—¶æ˜è¿·
            if (newHp === 0) { newStatus.unconscious = true; addLog(`ğŸ’« ${target.name} æ˜è¿· Unconscious!`, 'damage'); }
        }
        
        updateChar(target.id, { hp: newHp, status: newStatus });
        const logDetail = combatAction.currentDamageLog ? ` [${combatAction.currentDamageLog}]` : '';
        addLog(`ğŸ’¥ ${target.name} -${actualDamage} HP${logDetail} (${target.hp}â†’${newHp})`, 'damage');
        
        const nextHitIndex = combatAction.currentHitIndex + 1;
        if (nextHitIndex < combatAction.hits.length) {
            setCombatAction({ ...combatAction, currentHitIndex: nextHitIndex, currentDamageLog: null });
            setInputValue('');
        } else {
            nextTurn();
        }
    };

    // =====================================================
    // è‡ªåŠ¨å°„å‡» (Auto Fire) - å¼¹å¹•ç³»ç»Ÿ
    // =====================================================
    const getVolleySize = () => Math.max(3, Math.floor(currentActor.firearms / 10));
    
    const handleAutoFire = () => {
        if (!currentActor.rangedWeapon?.autoFire) return;
        const weapon = currentActor.rangedWeapon;
        
        // è®¡ç®—å¤šç›®æ ‡æµªè´¹çš„å¼¹è¯
        let wastedAmmo = 0;
        if (multiTargets.length > 1) {
            for (let i = 1; i < multiTargets.length; i++) {
                wastedAmmo += Math.abs(multiTargets[i].distance || 0);
            }
        }
        
        const totalBullets = autoFireBullets + wastedAmmo;
        if (weapon.ammo < totalBullets) {
            addLog(`âŒ å¼¹è¯ä¸è¶³! éœ€è¦${totalBullets}å‘(å«åˆ‡æ¢æµªè´¹${wastedAmmo}å‘), å‰©ä½™${weapon.ammo}`, 'system');
            return;
        }
        
        saveToHistory();
        
        const volleySize = getVolleySize();
        const totalVolleys = Math.ceil(autoFireBullets / volleySize);
        const targets = multiTargets.length > 0 ? multiTargets : [{ id: targetActor?.id, name: targetActor?.name }];
        
        // æ‰£é™¤å¼¹è¯
        updateChar(currentActor.id, { 
            rangedWeapon: { ...weapon, ammo: weapon.ammo - totalBullets } 
        });
        
        setCombatAction({
            type: 'auto_fire',
            volleySize,
            totalVolleys,
            currentVolley: 0,
            bulletsPerVolley: volleySize,
            weapon,
            targets,
            currentTargetIndex: 0,
            results: [],
            wastedAmmo
        });
        setPhase('auto_fire_roll');
        setInputValue('');
        
        addLog(`ğŸ”« ${currentActor.name} å…¨è‡ªåŠ¨å°„å‡» ${autoFireBullets}å‘ â†’ ${targets.map(t => t.name).join(', ')} [${totalVolleys}ç»„å¼¹å¹•, æ¯ç»„${volleySize}å‘]${wastedAmmo > 0 ? ` (åˆ‡æ¢æµªè´¹${wastedAmmo}å‘)` : ''}`, 'system');
    };

    // å¼¹å¹•æ£€å®š
    const handleVolleyRoll = () => {
        const roll = parseInt(inputValue);
        if (!roll || roll < 1 || roll > 100) return;
        
        const volleyNum = combatAction.currentVolley;
        
        // è®¡ç®—æƒ©ç½šéª°æ•°é‡ï¼šç¬¬1ç»„=0, ç¬¬2ç»„=1, ç¬¬3ç»„+=2(æœ€å¤š)
        let penaltyCount = Math.min(volleyNum, 2);
        let difficultyBoost = volleyNum > 2 ? volleyNum - 2 : 0;
        
        // è®¡ç®—æœ‰æ•ˆæŠ€èƒ½å€¼
        let effectiveSkill = currentActor.firearms;
        for (let i = 0; i < difficultyBoost; i++) {
            effectiveSkill = Math.floor(effectiveSkill / 2);
        }
        
        const successLevel = calculateSuccessLevel(roll, effectiveSkill);
        const bulletsInVolley = Math.min(combatAction.volleySize, autoFireBullets - volleyNum * combatAction.volleySize);
        
        // è®¡ç®—å‘½ä¸­æ•°
        let hitsCount = 0;
        if (successLevel > 0) {
            hitsCount = Math.floor(bulletsInVolley / 2);
            if (successLevel >= 3) {
                hitsCount = bulletsInVolley; // æéš¾æˆåŠŸå…¨éƒ¨å‘½ä¸­
            }
        }
        
        const penaltyNote = penaltyCount > 0 ? ` (${penaltyCount}æƒ©ç½šéª°)` : '';
        const diffNote = difficultyBoost > 0 ? ` [éš¾åº¦+${difficultyBoost}]` : '';
        addLog(`ğŸ² å¼¹å¹•${volleyNum + 1} [${roll}/${effectiveSkill}]${penaltyNote}${diffNote} â†’ ${getSuccessLabel(successLevel)} (å‘½ä¸­${hitsCount}å‘)`, 'roll');
        
        const newAction = {
            ...combatAction,
            currentVolley: volleyNum + 1,
            results: [...combatAction.results, { volleyNum, roll, successLevel, hits: hitsCount, bulletsInVolley }]
        };
        
        if (volleyNum + 1 >= combatAction.totalVolleys) {
            const totalHits = newAction.results.reduce((sum, r) => sum + r.hits, 0);
            if (totalHits > 0) {
                addLog(`âœ… æ€»è®¡å‘½ä¸­ ${totalHits} å‘!`, 'success');
                setCombatAction({ ...newAction, totalHits, hitsProcessed: 0 });
                setPhase('auto_fire_damage');
            } else {
                addLog(`ğŸ’¨ å…¨éƒ¨è½ç©º!`, 'roll');
                nextTurn();
            }
        } else {
            setCombatAction(newAction);
            setInputValue('');
        }
    };

    // è‡ªåŠ¨å°„å‡»ä¼¤å®³
    const handleAutoFireDamage = () => {
        const damage = parseInt(inputValue) || 0;
        const target = characters.find(c => c.id === combatAction.targets[combatAction.currentTargetIndex]?.id) || targetActor;
        if (!target) { nextTurn(); return; }
        
        const actualDamage = Math.max(0, damage - (target.armorValue || 0));
        const newHp = Math.max(0, target.hp - actualDamage);
        let newStatus = { ...target.status };
        
        // é€šä¿—æ¨¡å¼ä¸‹ç¦ç”¨é‡ä¼¤è§„åˆ™
        if (hpMultiplier === 1) {
            // æ ‡å‡†æ¨¡å¼ï¼šæ£€æŸ¥é‡ä¼¤
            const isMajorWound = actualDamage >= Math.floor(target.maxHp / 2);
            if (isMajorWound) {
                newStatus.majorWound = true;
                newStatus.prone = true;
            }
            if (newHp === 0 && newStatus.majorWound) {
                newStatus.dying = true;
            }
        } else {
            // é€šä¿—æ¨¡å¼ï¼šHPå½’é›¶æ—¶æ˜è¿·
            if (newHp === 0) { newStatus.unconscious = true; }
        }
        
        updateChar(target.id, { hp: newHp, status: newStatus });
        const logDetail = combatAction.currentDamageLog ? ` [${combatAction.currentDamageLog}]` : '';
        addLog(`ğŸ’¥ ${target.name} -${actualDamage} HP${logDetail}`, 'damage');
        
        const nextProcessed = combatAction.hitsProcessed + 1;
        if (nextProcessed < combatAction.totalHits) {
            setCombatAction({ ...combatAction, hitsProcessed: nextProcessed, currentDamageLog: null });
            setInputValue('');
        } else {
            nextTurn();
        }
    };

    // å¤šç›®æ ‡åˆ‡æ¢
    const toggleMultiTarget = (charId) => {
        const char = characters.find(c => c.id === charId);
        if (!char) return;
        
        if (multiTargets.find(t => t.id === charId)) {
            setMultiTargets(multiTargets.filter(t => t.id !== charId));
        } else {
            setMultiTargets([...multiTargets, { id: charId, name: char.name, distance: 0 }]);
        }
    };

    const updateTargetDistance = (charId, distance) => {
        setMultiTargets(multiTargets.map(t => 
            t.id === charId ? { ...t, distance: parseInt(distance) || 0 } : t
        ));
    };

    // å¼€å§‹åŒ»ç–—æµç¨‹ï¼ˆé€‰æ‹©ç±»å‹åè¿›å…¥è¾“å…¥phaseï¼‰
    const startMedical = (type) => {
        if (!targetActor) return;
        setMedicalType(type);
        setPhase('medical_roll');
        setInputValue('');
    };

    // æ‰§è¡ŒåŒ»ç–—ï¼ˆæ‰‹åŠ¨è¾“å…¥æˆ–è‡ªåŠ¨æŠ•éª°åè°ƒç”¨ï¼‰
    const executeMedical = () => {
        if (!targetActor || !medicalType) return;
        const roll = parseInt(inputValue);
        if (!roll || roll < 1 || roll > 100) return;
        
        saveToHistory();
        const skillValue = medicalType === 'firstAid' ? (currentActor.firstAid || 30) : (currentActor.medicine || 5);
        const success = calculateSuccessLevel(roll, skillValue);
        const skillName = medicalType === 'firstAid' ? 'æ€¥æ•‘ First Aid' : 'åŒ»å­¦ Medicine';
        addLog(`${medicalType === 'firstAid' ? 'ğŸ©¹' : 'âš•ï¸'} ${skillName} [${roll}/${skillValue}] â†’ ${getSuccessLabel(success)}`, 'roll');
        
        if (success > 0) {
            if (medicalType === 'firstAid') {
                if (targetActor.status.dying) {
                    // é€šä¿—æ¨¡å¼ï¼šæ€¥æ•‘è„±ç¦»æ¿’æ­»æ—¶æ¢å¤1D4 HP
                    const healAmount = hpMultiplier === 2 ? rollDice('1D4').total : 1;
                    updateChar(targetActor.id, { hp: healAmount, status: { ...targetActor.status, dying: false } });
                    addLog(`âœ… ${targetActor.name} è„±ç¦»æ¿’æ­» +${healAmount} HP`, 'success');
                } else {
                    // é€šä¿—æ¨¡å¼: +1D4 HP, æ ‡å‡†æ¨¡å¼: +1 HP
                    const healAmount = hpMultiplier === 2 ? rollDice('1D4').total : 1;
                    const newHp = Math.min(targetActor.maxHp, targetActor.hp + healAmount);
                    updateChar(targetActor.id, { hp: newHp });
                    addLog(`âœ… ${targetActor.name} +${healAmount} HP`, 'success');
                }
            } else {
                // é€šä¿—æ¨¡å¼: +1D6 HP, æ ‡å‡†æ¨¡å¼: +1D3 HP
                const healDice = hpMultiplier === 2 ? '1D6' : '1D3';
                const heal = rollDice(healDice);
                const newHp = Math.min(targetActor.maxHp, targetActor.hp + heal.total);
                updateChar(targetActor.id, { hp: newHp });
                addLog(`âœ… ${targetActor.name} +${heal.total} HP`, 'success');
            }
        }
        nextTurn();
    };

    // ä¿ç•™æ—§å‡½æ•°çš„å…¼å®¹æ€§ï¼ˆç›´æ¥æŠ•éª°ç‰ˆæœ¬ï¼Œä¾›å¿«é€Ÿä½¿ç”¨ï¼‰
    const performFirstAid = () => {
        if (!targetActor) return;
        saveToHistory();
        const roll = doRollDirect();
        const success = calculateSuccessLevel(roll, currentActor.firstAid || 30);
        addLog(`ğŸ©¹ æ€¥æ•‘ [${roll}/${currentActor.firstAid || 30}] â†’ ${getSuccessLabel(success)}`, 'roll');
        if (success > 0) {
            if (targetActor.status.dying) {
                const healAmount = hpMultiplier === 2 ? rollDice('1D4').total : 1;
                updateChar(targetActor.id, { hp: healAmount, status: { ...targetActor.status, dying: false } });
                addLog(`âœ… ${targetActor.name} è„±ç¦»æ¿’æ­» +${healAmount} HP`, 'success');
            } else {
                const healAmount = hpMultiplier === 2 ? rollDice('1D4').total : 1;
                const newHp = Math.min(targetActor.maxHp, targetActor.hp + healAmount);
                updateChar(targetActor.id, { hp: newHp });
                addLog(`âœ… ${targetActor.name} +${healAmount} HP`, 'success');
            }
        }
        nextTurn();
    };

    const performMedicine = () => {
        if (!targetActor) return;
        saveToHistory();
        const roll = doRollDirect();
        const success = calculateSuccessLevel(roll, currentActor.medicine || 5);
        addLog(`âš•ï¸ åŒ»å­¦ [${roll}/${currentActor.medicine || 5}] â†’ ${getSuccessLabel(success)}`, 'roll');
        if (success > 0) {
            const healDice = hpMultiplier === 2 ? '1D6' : '1D3';
            const heal = rollDice(healDice);
            const newHp = Math.min(targetActor.maxHp, targetActor.hp + heal.total);
            updateChar(targetActor.id, { hp: newHp });
            addLog(`âœ… ${targetActor.name} +${heal.total} HP`, 'success');
        }
        nextTurn();
    };

    // =====================================================
    // å¹¸è¿æ¶ˆè€—å‡½æ•° (é€šä¿—æ¨¡å¼)
    // =====================================================
    
    // æ“¦ä¼¤è€Œå·²: æ¶ˆè€—20å¹¸è¿ â†’ æ¢å¤1D6 HP
    const spendLuckJustAScratch = (charId) => {
        const char = characters.find(c => c.id === charId);
        if (!char || hpMultiplier !== 2) return;
        if ((char.luck || 0) < 20) {
            addLog(`âš ï¸ ${char.name} å¹¸è¿ä¸è¶³ (${char.luck || 0}/20)`, 'system');
            return;
        }
        saveToHistory();
        const heal = rollDice('1D6');
        const newHp = Math.min(char.maxHp, char.hp + heal.total);
        const newLuck = (char.luck || 50) - 20;
        updateChar(charId, { hp: newHp, luck: newLuck });
        addLog(`ğŸ€ ${char.name}ã€æ“¦ä¼¤è€Œå·²ã€‘æ¶ˆè€—20å¹¸è¿ â†’ +${heal.total} HP (${char.hp}â†’${newHp}) [å¹¸è¿ ${char.luck}â†’${newLuck}]`, 'success');
    };
    
    // èº²è¿‡ä¸€åŠ«: æ¶ˆè€—10å¹¸è¿ â†’ æœ¬æ¬¡ä¼¤å®³-5
    const spendLuckDodgedABullet = () => {
        const target = combatAction?.isCounterAttack ? currentActor : targetActor;
        if (!target || hpMultiplier !== 2) return;
        if ((target.luck || 0) < 10) {
            addLog(`âš ï¸ ${target.name} å¹¸è¿ä¸è¶³ (${target.luck || 0}/10)`, 'system');
            return;
        }
        saveToHistory();
        const newLuck = (target.luck || 50) - 10;
        updateChar(target.id, { luck: newLuck });
        setLuckDamageReduction(prev => prev + 5);
        addLog(`ğŸ€ ${target.name}ã€èº²è¿‡ä¸€åŠ«ã€‘æ¶ˆè€—10å¹¸è¿ â†’ ä¼¤å®³-5 [å¹¸è¿ ${target.luck}â†’${newLuck}]`, 'success');
    };
    
    // å‘½æ‚¬ä¸€çº¿: æ¶ˆè€—æ‰€æœ‰å¹¸è¿(â‰¥30) â†’ é¿å…æ­»äº¡ï¼Œæ¢å¤1D6+1 HP
    const useDeathsDoor = () => {
        if (!deathsDoorPending) return;
        const { targetId, damage } = deathsDoorPending;
        const target = characters.find(c => c.id === targetId);
        if (!target || (target.luck || 0) < 30) return;
        
        saveToHistory();
        const luckSpent = target.luck || 50;
        const heal = rollDice('1D6');
        const newHp = heal.total + 1; // 1D6+1
        
        updateChar(targetId, { 
            hp: newHp, 
            luck: 0,
            status: { ...target.status, unconscious: false, dying: false }
        });
        
        addLog(`ğŸ€ğŸ’€ ${target.name}ã€å‘½æ‚¬ä¸€çº¿ã€‘æ¶ˆè€—å…¨éƒ¨${luckSpent}å¹¸è¿ â†’ å¥‡è¿¹ç”Ÿè¿˜ï¼HPæ¢å¤è‡³ ${newHp}`, 'success');
        addLog(`ğŸ“– ${target.name} åœ¨åƒé’§ä¸€å‘ä¹‹é™…æ­»é‡Œé€ƒç”Ÿ...`, 'system');
        
        setDeathsDoorPending(null);
        nextTurn();
    };
    
    const declineDeathsDoor = () => {
        if (!deathsDoorPending) return;
        const { targetId, actualDamage, newHp, newStatus, damageLog } = deathsDoorPending;
        const target = characters.find(c => c.id === targetId);
        if (!target) return;
        
        // åº”ç”¨åŸæœ¬çš„ä¼¤å®³
        updateChar(targetId, { hp: newHp, status: newStatus });
        
        const logDetail = damageLog ? ` [${damageLog}]` : '';
        addLog(`ğŸ’¥ ${target.name} -${actualDamage} HP${logDetail} (${target.hp}â†’${newHp})`, 'damage');
        
        if (newHp === 0) {
            addLog(`ğŸ’« ${target.name} æ˜è¿· Unconscious!`, 'damage');
        }
        if (actualDamage >= target.maxHp) {
            addLog(`â˜ ï¸ ${target.name} DEAD!`, 'damage');
        }
        
        setDeathsDoorPending(null);
        nextTurn();
    };

    const handleRoll = () => {
        const roll = parseInt(inputValue);
        if (!roll || roll < 1 || roll > 100) return;
        if (combatAction.type === 'ranged') {
            let skillValue = currentActor.firearms;
            if (combatAction.difficulty === 'hard') skillValue = Math.floor(skillValue / 2);
            if (combatAction.difficulty === 'extreme') skillValue = Math.floor(skillValue / 5);
            const successLevel = calculateSuccessLevel(roll, skillValue);
            const newAmmo = currentActor.rangedWeapon.ammo - 1;
            updateChar(currentActor.id, { rangedWeapon: { ...currentActor.rangedWeapon, ammo: newAmmo } });
            if (roll >= currentActor.rangedWeapon.malfunction) { addLog(`ğŸ’¥ MALFUNCTION!`, 'damage'); nextTurn(); return; }
            if (successLevel > 0) {
                addLog(`ğŸ¯ HIT [${roll}/${combatAction.attackerSkill}] ${getSuccessLabel(successLevel)}`, 'roll');
                setCombatAction(prev => ({ ...prev, damageAttacker: currentActor, damageSuccessLevel: successLevel }));
                setPhase('input_damage');
            } else {
                addLog(`ğŸ’¨ MISS [${roll}/${combatAction.attackerSkill}]`, 'roll'); nextTurn();
            }
        } else {
            const successLevel = calculateSuccessLevel(roll, combatAction.attackerSkill);
            addLog(`ğŸ² ATK [${roll}/${combatAction.attackerSkill}] ${getSuccessLabel(successLevel)}`, 'roll');
            setCombatAction(prev => ({ ...prev, attackerRoll: roll, attackerSuccessLevel: successLevel }));
            setPhase('input_defense_roll');
        }
        setInputValue('');
    };

    const handleDefenseRoll = () => {
        const roll = parseInt(inputValue);
        if (!roll || roll < 1 || roll > 100) return;
        const result = executeOpposedCheck(combatAction.attackerSkill, combatAction.defenderSkill, combatAction.attackerRoll, roll, combatAction.defenseType);
        addLog(`ğŸ² DEF [${roll}/${combatAction.defenderSkill}] ${getSuccessLabel(result.defLvl)}`, 'roll');
        updateChar(targetActor.id, { status: { ...targetActor.status, defenseUsedThisRound: true } });
        if (result.winner === 'attacker') {
            if (combatAction.type === 'maneuver') {
                const maneuverNames = { disarm: 'ç¼´æ¢°', knockdown: 'å‡»å€’', grapple: 'æ“’æŠ±', push: 'æ¨æ’', stun: 'å‡»æ™•' };
                addLog(`âœ… ${maneuverNames[combatAction.maneuverType] || combatAction.maneuverType} æˆåŠŸï¼`, 'success');
                
                // ========== æˆ˜æŠ€æ•ˆæœå¤„ç† ==========
                if (combatAction.maneuverType === 'disarm') {
                    // ç¼´æ¢°ä¼˜å…ˆçº§: è¿œç¨‹æ­¦å™¨ > è¿‘æˆ˜æ­¦å™¨ (è¿œç¨‹æ­¦å™¨å¨èƒæ›´å¤§)
                    // COCè§„åˆ™: ç¼´æ¢°é’ˆå¯¹ç›®æ ‡æ‰‹ä¸­çš„æ­¦å™¨
                    let targetWeapon = null;
                    let weaponType = null;
                    
                    // ä¼˜å…ˆæ£€æŸ¥è¿œç¨‹æ­¦å™¨
                    if (targetActor.rangedWeapon) {
                        targetWeapon = targetActor.rangedWeapon;
                        weaponType = 'ranged';
                    } else if (targetActor.meleeWeapon && targetActor.meleeWeapon.name !== 'æ‹³å¤´') {
                        // æ²¡æœ‰è¿œç¨‹æ­¦å™¨æ—¶ï¼Œæ£€æŸ¥è¿‘æˆ˜æ­¦å™¨ï¼ˆæ’é™¤æ‹³å¤´ï¼‰
                        targetWeapon = targetActor.meleeWeapon;
                        weaponType = 'melee';
                    }
                    
                    if (targetWeapon) {
                        const disarmedWeaponName = targetWeapon.name;
                        if (weaponType === 'ranged') {
                            // è¿œç¨‹æ­¦å™¨è¢«ç¼´æ¢°ï¼ŒåŒæ—¶å–æ¶ˆæ¶æªçŠ¶æ€
                            updateChar(targetActor.id, { rangedWeapon: null, hasGunReady: false });
                        } else {
                            // è¿‘æˆ˜æ­¦å™¨è¢«ç¼´æ¢°ï¼Œæ¢å¤ä¸ºæ‹³å¤´
                            updateChar(targetActor.id, { 
                                meleeWeapon: { name: 'æ‹³å¤´', damage: '1D3', type: 'melee', impale: false }
                            });
                        }
                        addLog(`ğŸ¤š ${targetActor.name} çš„ [${disarmedWeaponName}] è¢«å¤ºèµ°ï¼`, 'damage');
                    } else {
                        addLog(`ğŸ¤š ${targetActor.name} æ²¡æœ‰å¯è¢«ç¼´æ¢°çš„æ­¦å™¨`, 'system');
                    }
                } else if (combatAction.maneuverType === 'knockdown') {
                    // å‡»å€’: ç›®æ ‡å€’åœ°
                    updateChar(targetActor.id, { status: { ...targetActor.status, prone: true } });
                    addLog(`ğŸ¦µ ${targetActor.name} è¢«å‡»å€’åœ¨åœ°ï¼`, 'damage');
                } else if (combatAction.maneuverType === 'grapple') {
                    // æ“’æŠ±: ç›®æ ‡è¢«æ“’æŠ± (åŒæ–¹è¿›å…¥æ“’æŠ±çŠ¶æ€)
                    updateChar(targetActor.id, { status: { ...targetActor.status, grappled: true } });
                    updateChar(currentActor.id, { status: { ...currentActor.status, grappling: true } });
                    addLog(`ğŸ¤¼ ${currentActor.name} æ“’æŠ±ä½äº† ${targetActor.name}ï¼`, 'damage');
                } else if (combatAction.maneuverType === 'push') {
                    // æ¨æ’: ç›®æ ‡è¢«æ¨å¼€ (å¯èƒ½å€’åœ°)
                    // å¦‚æœæ”»å‡»è€…BUILDæ¯”ç›®æ ‡å¤§ï¼Œç›®æ ‡å€’åœ°
                    if (currentActor.build > targetActor.build) {
                        updateChar(targetActor.id, { status: { ...targetActor.status, prone: true } });
                        addLog(`ğŸ’¨ ${targetActor.name} è¢«æ¨å€’åœ¨åœ°ï¼`, 'damage');
                    } else {
                        addLog(`ğŸ’¨ ${targetActor.name} è¢«æ¨å¼€ï¼`, 'system');
                    }
                } else if (combatAction.maneuverType === 'stun') {
                    // å‡»æ™•æˆ˜æŠ€ (é€šä¿—è§„åˆ™): ç›®æ ‡æ˜è¿·ï¼Œä»…é€ æˆ1ç‚¹ä¼¤å®³
                    const newHp = Math.max(0, targetActor.hp - 1);
                    updateChar(targetActor.id, { 
                        hp: newHp,
                        status: { ...targetActor.status, unconscious: true } 
                    });
                    addLog(`ğŸ’« ${targetActor.name} è¢«å‡»æ™•æ˜è¿·ï¼-1 HP (${targetActor.hp}â†’${newHp})`, 'damage');
                }
                nextTurn();
            } else {
                setCombatAction(prev => ({ ...prev, damageAttacker: currentActor, damageSuccessLevel: result.atkLvl, isCounterAttack: false }));
                setPhase('input_damage');
            }
        } else {
            if (combatAction.defenseType === 'counter' && result.defLvl > 0) {
                addLog(`âš”ï¸ ${targetActor.name} å‘åŠ¨åå‡»ï¼`, 'success');
                setCombatAction(prev => ({ ...prev, damageAttacker: targetActor, damageSuccessLevel: result.defLvl, isCounterAttack: true, weapon: targetActor.meleeWeapon || { name: "æ‹³å¤´", damage: "1D3", type: "melee", impale: false } }));
                setPhase('input_damage');
            } else {
                addLog(`ğŸ’¨ æ”»å‡»æœªå‘½ä¸­`, 'system'); nextTurn();
            }
        }
        setInputValue('');
    };

    const handleDamage = () => {
        const damage = parseInt(inputValue) || 0;
        const target = combatAction.isCounterAttack ? currentActor : targetActor;
        
        // å–½å•°è§„åˆ™ (é€šä¿—æ¨¡å¼): è¢«å‘½ä¸­å³å€’
        if (hpMultiplier === 2 && target.isMook && damage > 0) {
            updateChar(target.id, { hp: 0, status: { ...target.status, unconscious: true } });
            addLog(`ğŸ’€ ${target.name} [å–½å•°] è¢«å‡»å€’ï¼`, 'damage');
            nextTurn();
            return;
        }
        
        // åº”ç”¨æŠ¤ç”²å’Œå¹¸è¿å‡ä¼¤
        const actualDamage = Math.max(0, damage - (target.armorValue || 0) - luckDamageReduction);
        const newHp = Math.max(0, target.hp - actualDamage);
        let newStatus = { ...target.status };
        
        // é€šä¿—æ¨¡å¼ä¸‹ç¦ç”¨é‡ä¼¤è§„åˆ™
        if (hpMultiplier === 1) {
            // æ ‡å‡†æ¨¡å¼ï¼šæ£€æŸ¥é‡ä¼¤
            const isMajorWound = actualDamage >= Math.floor(target.maxHp / 2);
            if (isMajorWound) { newStatus.majorWound = true; newStatus.prone = true; addLog(`ğŸ’€ ${target.name} å—åˆ°äº†é‡ä¼¤ï¼`, 'damage'); }
            if (newHp === 0 && newStatus.majorWound) { newStatus.dying = true; addLog(`âš ï¸ ${target.name} DYING!`, 'damage'); }
        } else {
            // é€šä¿—æ¨¡å¼ï¼šæ£€æŸ¥å‘½æ‚¬ä¸€çº¿æ¡ä»¶
            if (newHp === 0 && (target.luck || 0) >= 30) {
                // è§¦å‘å‘½æ‚¬ä¸€çº¿é€‰æ‹©
                newStatus.unconscious = true;
                setDeathsDoorPending({
                    targetId: target.id,
                    damage,
                    actualDamage,
                    newHp,
                    newStatus,
                    damageLog: combatAction.damageLog,
                    luckDetail: luckDamageReduction > 0 ? ` ğŸ€-${luckDamageReduction}` : ''
                });
                addLog(`âš ï¸ ${target.name} å³å°†å€’ä¸‹ï¼å¯ä½¿ç”¨ã€å‘½æ‚¬ä¸€çº¿ã€‘`, 'system');
                return; // æš‚åœï¼Œç­‰å¾…ç©å®¶å†³ç­–
            }
            // é€šä¿—æ¨¡å¼ï¼šHPå½’é›¶æ—¶æ˜è¿·
            if (newHp === 0) { newStatus.unconscious = true; }
        }
        
        if (actualDamage >= target.maxHp) { addLog(`â˜ ï¸ ${target.name} DEAD!`, 'damage'); }
        updateChar(target.id, { hp: newHp, status: newStatus });
        const logDetail = combatAction.damageLog ? ` [${combatAction.damageLog}]` : '';
        const luckDetail = luckDamageReduction > 0 ? ` ğŸ€-${luckDamageReduction}` : '';
        addLog(`ğŸ’¥ ${target.name} -${actualDamage} HP${logDetail}${luckDetail} (${target.hp}â†’${newHp})`, 'damage');
        if (hpMultiplier === 2 && newHp === 0) {
            addLog(`ğŸ’« ${target.name} æ˜è¿· Unconscious!`, 'damage');
        }
        nextTurn();
    };

    return (
        <div className="combat-grid h-full">
            {/* å·¦ä¾§è§’è‰²åˆ—è¡¨ */}
            <div className={`panel-left panel-scroll ${mobileTab === 'status' ? 'panel-mobile-active' : ''}`}>
                <div className="p-3 border-b-2 border-black text-xs font-bold uppercase tracking-widest bg-white flex justify-between items-center text-gray-500">
                    <span>è¡ŒåŠ¨åºåˆ— TURN ORDER</span>
                    <span className="font-mono">HP</span>
                </div>
                <div>
                    {combatOrder.map((c, i) => {
                        const isActive = i === turn.index % combatOrder.length;
                        const isTarget = selectedTargetId === c.id;
                        return (
                            <div 
                                key={c.id}
                                onClick={() => {
                                    if (autoFireMode && phase === 'select_action') {
                                        toggleMultiTarget(c.id);
                                    }
                                    setSelectedTargetId(c.id);
                                }}
                                className={`char-card px-4 py-3 ${c.type === 'player' ? 'faction-strip-player' : 'faction-strip-enemy'} ${isActive ? 'selected' : ''} ${isTarget ? 'target-selected' : ''} ${multiTargets.find(t => t.id === c.id) ? 'ring-2 ring-red-500' : ''}`}
                            >
                                <div className="flex justify-between items-center">
                                    <div className="overflow-hidden">
                                        <div className={`font-bold text-sm tracking-tight`}>
                                            {c.name}
                                            {/* å–½å•°æ ‡è®° */}
                                            {hpMultiplier === 2 && c.isMook && (
                                                <span className="ml-1 text-[9px] bg-red-500 text-white px-1 font-bold">å–½å•°</span>
                                            )}
                                        </div>
                                        <div className={`flex gap-2 text-[10px] font-mono mt-1 sub-text ${isActive ? 'text-gray-400' : 'text-gray-500'}`}>
                                            <span>
                                                å…ˆæ”» {(() => {
                                                    let init = c.hasGunReady ? c.dex + 50 : c.dex;
                                                    const hasQuickDraw = hpMultiplier === 2 && c.hasGunReady && (c.talents || []).includes('quick_draw');
                                                    if (hasQuickDraw) init += 10;
                                                    return init;
                                                })()}
                                                {hpMultiplier === 2 && c.hasGunReady && (c.talents || []).includes('quick_draw') && (
                                                    <span className="text-yellow-500 ml-0.5">âš¡</span>
                                                )}
                                            </span>
                                            <span className="border-l border-current pl-2 opacity-50">ä½“æ ¼ {c.build}</span>
                                            {(c.attacksPerRound || 1) > 1 && (
                                                <span className="border-l border-current pl-2 text-orange-400">âš”ï¸{c.attacksLeft || 1}/{c.attacksPerRound}</span>
                                            )}
                                        </div>
                                    </div>
                                    <div className="text-right pl-2">
                                        <div className={`font-mono font-bold text-sm ${c.hp < c.maxHp/2 ? 'text-red-500' : ''}`}>
                                            {c.isMook && hpMultiplier === 2 ? 'â€”' : `${c.hp}/${c.maxHp}`}
                                        </div>
                                        {/* å¹¸è¿å€¼æ˜¾ç¤ºï¼ˆé€šä¿—æ¨¡å¼ï¼‰ */}
                                        {hpMultiplier === 2 && (
                                            <div className="text-[10px] font-mono text-purple-500 mt-0.5">
                                                ğŸ€ {c.luck || 50}
                                            </div>
                                        )}
                                        <div className="flex gap-1 mt-1 justify-end flex-wrap max-w-[80px]">
                                            {c.status.majorWound && <span className="text-[9px] bg-red-600 text-white px-1 font-bold">é‡ä¼¤</span>}
                                            {c.status.dying && <span className="text-[9px] bg-black text-white px-1 font-bold">æ¿’æ­»</span>}
                                            {c.status.unconscious && <span className="text-[9px] bg-gray-600 text-white px-1 font-bold">æ˜è¿·</span>}
                                            {c.status.prone && <span className="text-[9px] bg-gray-300 text-black px-1 font-bold">å€’åœ°</span>}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        );
                    })}
                </div>
            </div>

            {/* ä¸­é—´æ“ä½œåŒº */}
            <div className={`panel-center ${mobileTab === 'action' ? 'panel-mobile-active' : ''}`}>
                <div className="bg-black text-white p-5 sticky top-0 z-20 border-b-4 border-white/20">
                    <div className="flex justify-between items-start">
                        <div>
                            <div className="flex items-baseline gap-1 mb-1">
                                <span className="text-[10px] text-gray-400">å½“å‰è¡ŒåŠ¨</span>
                            </div>
                            <div className="font-black text-2xl tracking-tight">{currentActor?.name || '-'}</div>
                            {currentActor && <div className="text-xs text-gray-400 mt-2 font-mono">æ–—æ®´ {currentActor.fight} | é—ªé¿ {currentActor.dodge} | å°„å‡» {currentActor.firearms}</div>}
                        </div>
                        <div className="text-right">
                            <div className="flex items-baseline gap-1 mb-1 justify-end">
                                <span className="text-[10px] text-gray-400">æ”»å‡»ç›®æ ‡</span>
                            </div>
                            <div className={`font-black text-2xl tracking-tight ${targetActor ? 'text-red-400' : 'text-gray-600 italic'}`}>{targetActor?.name || 'â€”'}</div>
                            {targetActor && <div className="text-xs text-gray-400 mt-2 font-mono">ç”Ÿå‘½ {targetActor.hp}/{targetActor.maxHp}</div>}
                        </div>
                    </div>
                    {/* VS è£…é¥° */}
                    <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-6xl font-black italic text-white/5 select-none pointer-events-none">VS</div>
                </div>

                <div className="action-area">
                    <div className="centered-card p-6">
                        {/* å‘½æ‚¬ä¸€çº¿å†³ç­–ç•Œé¢ */}
                        {deathsDoorPending && (() => {
                            const target = characters.find(c => c.id === deathsDoorPending.targetId);
                            return target && (
                                <div className="space-y-6">
                                    <div className="text-center border-b-4 border-red-500 pb-4">
                                        <div className="text-5xl mb-3">ğŸ’€</div>
                                        <div className="font-black text-xl tracking-[0.1em] text-red-600">
                                            å‘½ æ‚¬ ä¸€ çº¿
                                        </div>
                                        <div className="text-xs text-gray-500 mt-2 font-mono">DEATH'S DOOR</div>
                                    </div>
                                    
                                    <div className="bg-red-50 border-2 border-red-300 p-4 text-center">
                                        <div className="text-lg font-black text-red-700">{target.name}</div>
                                        <div className="text-sm text-red-600 mt-2">
                                            å³å°†å—åˆ° <span className="font-mono font-bold">{deathsDoorPending.actualDamage}</span> ç‚¹ä¼¤å®³
                                        </div>
                                        <div className="text-sm text-red-600">
                                            HPå°†é™è‡³ <span className="font-mono font-bold">0</span>
                                        </div>
                                    </div>
                                    
                                    <div className="bg-purple-50 border-2 border-purple-300 p-4">
                                        <div className="text-center mb-3">
                                            <div className="text-sm font-bold text-purple-700">ğŸ€ å½“å‰å¹¸è¿: {target.luck || 50}</div>
                                        </div>
                                        <div className="text-xs text-purple-600 space-y-1">
                                            <div>â€¢ æ¶ˆè€— <span className="font-bold">å…¨éƒ¨{target.luck || 50}ç‚¹</span> å¹¸è¿</div>
                                            <div>â€¢ å¥‡è¿¹ç”Ÿè¿˜ï¼ŒHPæ¢å¤è‡³ <span className="font-bold">1D6+1</span></div>
                                            <div>â€¢ å¹¸è¿å½’é›¶</div>
                                        </div>
                                    </div>
                                    
                                    <div className="grid grid-cols-1 gap-3">
                                        <button 
                                            onClick={useDeathsDoor}
                                            className="py-4 bg-purple-600 text-white font-black text-base tracking-[0.1em] hover:bg-purple-700 transition-colors border-2 border-purple-600"
                                        >
                                            ğŸ€ ä½¿ç”¨å‘½æ‚¬ä¸€çº¿ - æ­»é‡Œé€ƒç”Ÿï¼
                                        </button>
                                        <button 
                                            onClick={declineDeathsDoor}
                                            className="py-3 bg-gray-100 text-gray-600 font-bold text-sm hover:bg-gray-200 transition-colors border-2 border-gray-300"
                                        >
                                            æ”¾å¼ƒ - æ¥å—å‘½è¿
                                        </button>
                                    </div>
                                </div>
                            );
                        })()}
                        
                        {/* Phase: Select Action */}
                        {phase === 'select_action' && !showMedical && !deathsDoorPending && (
                            <>
                                {/* ========== v4.3.0 è¾“å…¥æ¨¡å¼ + éª°å­ä¿®æ­£ ========== */}
                                <div className="mb-5">
                                    <div className="flex items-center justify-between mb-2">
                                        <span className="text-[10px] font-black text-gray-400 tracking-widest">è¾“å…¥æ¨¡å¼</span>
                                        <span className={`text-[9px] px-2 py-0.5 font-bold ${inputMode === 'manual' ? 'bg-blue-600 text-white' : 'bg-green-600 text-white'}`}>
                                            {inputMode === 'manual' ? 'âŒ¨ï¸ æ‰‹åŠ¨å½•å…¥' : 'ğŸ² è‡ªåŠ¨æ·éª°'}
                                        </span>
                                    </div>
                                    <InputModeToggle value={inputMode} onChange={setInputMode} />
                                </div>
                                
                                {inputMode === 'auto' && (
                                    <div className="mb-5">
                                        <DiceModifierSelector value={diceModifier} onChange={setDiceModifier} />
                                    </div>
                                )}
                                
                                {!selectedTargetId ? (
                                    <div className="text-center text-gray-400 py-12">
                                        <div className="text-5xl mb-4">ğŸ‘ˆ</div>
                                        <div className="text-sm font-black tracking-[0.1em]">è¯·é€‰æ‹©ç›®æ ‡</div>
                                        <div className="text-xs text-gray-300 mt-2">ç‚¹å‡»å·¦ä¾§åˆ—è¡¨é€‰æ‹©æ”»å‡»å¯¹è±¡</div>
                                    </div>
                                ) : (
                                    <>
                                        {/* ========== v4.3.1 æ‰‹åŠ¨å½•å…¥ç»“ç®—å¡ç‰‡ ========== */}
                                        {pendingAction && pendingAction.type === 'manual_rapid' && (
                                            <div className="mb-6">
                                                <ManualRapidResolutionCard
                                                    title={pendingAction.title}
                                                    shots={pendingAction.shots}
                                                    weaponDamage={pendingAction.weaponDamage}
                                                    db={pendingAction.db}
                                                    attacker={pendingAction.attacker}
                                                    target={pendingAction.target}
                                                    targetId={pendingAction.targetId}
                                                    hpMultiplier={hpMultiplier}
                                                    weapon={pendingAction.weapon}
                                                    onApply={applyRapidResult}
                                                    onCancel={cancelManualAction}
                                                />
                                            </div>
                                        )}
                                        
                                        {pendingAction && pendingAction.type === 'manual_autofire' && (
                                            <div className="mb-6">
                                                <ManualAutoFireResolutionCard
                                                    title={pendingAction.title}
                                                    bullets={pendingAction.bullets}
                                                    attacker={pendingAction.attacker}
                                                    targets={pendingAction.targets}
                                                    onApply={applyAutoFireResult}
                                                    onCancel={cancelManualAction}
                                                />
                                            </div>
                                        )}
                                        
                                        {pendingAction && (pendingAction.type === 'melee' || pendingAction.type === 'ranged') && (
                                            <div className="mb-6">
                                                <ManualResolutionCard
                                                    title={pendingAction.title}
                                                    targetNumber={pendingAction.targetNumber}
                                                    weaponDamage={pendingAction.weaponDamage}
                                                    db={pendingAction.db}
                                                    attacker={pendingAction.attacker}
                                                    target={pendingAction.target}
                                                    targetId={pendingAction.targetId}
                                                    isPulp={hpMultiplier === 2}
                                                    hpMultiplier={hpMultiplier}
                                                    weapon={pendingAction.weapon}
                                                    onApply={applyManualResult}
                                                    onCancel={cancelManualAction}
                                                />
                                            </div>
                                        )}
                                        
                                        {/* ========== v4.3.0 è‡ªåŠ¨æ·éª°ç»“ç®—å¡ç‰‡ ========== */}
                                        {resolutionCards.length > 0 && (
                                            <div className="mb-6">
                                                {resolutionCards.map(card => (
                                                    <AutoResolutionCard
                                                        key={card.id}
                                                        title={card.title}
                                                        targetNumber={card.targetNumber}
                                                        roll={card.roll}
                                                        successLevel={card.successLevel}
                                                        damage={card.damage}
                                                        damageLog={card.damageLog}
                                                        attacker={card.attacker}
                                                        target={card.target}
                                                        isPulp={hpMultiplier === 2}
                                                        luckAvailable={targetActor?.luck || 0}
                                                        onApply={(customDamage) => applyResolutionCard(card, customDamage)}
                                                        onCancel={() => cancelResolutionCard(card.id)}
                                                        onLuckSpend={(type) => {
                                                            if (type === 'dodge') {
                                                                setLuckDamageReduction(prev => prev + 5);
                                                                updateChar(targetActor.id, { luck: (targetActor.luck || 0) - 10 });
                                                                addLog(`ğŸ€ ${targetActor.name} èº²è¿‡ä¸€åŠ«ï¼-10å¹¸è¿ï¼Œä¼¤å®³-5`, 'system');
                                                            }
                                                        }}
                                                    />
                                                ))}
                                            </div>
                                        )}
                                        
                                        {/* æ”»å‡»åŠ¨ä½œåŒº */}
                                        <div className="mb-6">
                                            <div className="flex items-baseline gap-2 mb-3 border-b-2 border-black pb-2">
                                                <span className="text-xs font-black tracking-wide">æ”»å‡»åŠ¨ä½œ</span>
                                            </div>
                                            <div className="grid grid-cols-1 gap-3">
                                                {/* ç–¯ç‹‚å†²é”‹é€‰é¡¹ (é€šä¿—æ¨¡å¼) */}
                                                {hpMultiplier === 2 && (
                                                    <div className="border border-orange-200 p-2 bg-orange-50 mb-1">
                                                        <label className="flex items-center gap-2 cursor-pointer">
                                                            <input 
                                                                type="checkbox" 
                                                                checked={madChargeMode} 
                                                                onChange={e => setMadChargeMode(e.target.checked)}
                                                                className="w-4 h-4 accent-orange-600"
                                                            />
                                                            <span className="text-xs text-orange-700 font-bold">ğŸƒğŸ’¨ ç–¯ç‹‚å†²é”‹</span>
                                                        </label>
                                                        {madChargeMode && (
                                                            <div className="text-[9px] text-orange-500 mt-1 ml-6">
                                                                âœ“ æ”»å‡»å¥–åŠ±éª° âœ— æœ¬è½®æ— æ³•é—ªé¿ âš ï¸ å¯¹æ–¹åå‡»ä¹Ÿè·å¾—å¥–åŠ±éª°
                                                            </div>
                                                        )}
                                                    </div>
                                                )}
                                                
                                                {/* è¿‘æˆ˜æ”»å‡»æŒ‰é’® */}
                                                <button 
                                                    onClick={startMeleeAttack}
                                                    disabled={!!pendingAction || resolutionCards.length > 0}
                                                    className={`action-btn primary ${madChargeMode && hpMultiplier === 2 ? 'bg-orange-500 border-orange-500 hover:bg-orange-600' : ''} ${(pendingAction || resolutionCards.length > 0) ? 'opacity-50 cursor-not-allowed' : ''}`}
                                                >
                                                    <span className="font-black tracking-[0.05em]">
                                                        {madChargeMode && hpMultiplier === 2 ? 'ğŸƒğŸ’¨ ç–¯ç‹‚å†²é”‹' : 'âš”ï¸ è¿‘æˆ˜æ”»å‡»'}
                                                    </span>
                                                    <span className="detail">
                                                        {currentActor?.meleeWeapon?.name || 'æ‹³å¤´'} ({currentActor?.fight}%)
                                                    </span>
                                                </button>

                                                {currentActor?.rangedWeapon ? (
                                                    <div className="border-2 border-gray-200 p-4 bg-white">
                                                        <div className="flex justify-between items-center mb-3">
                                                            <span className="font-bold">ğŸ”« {currentActor.rangedWeapon.name}</span>
                                                            <div className="flex items-center gap-2">
                                                                <span className={`text-xs font-mono px-2 py-1 font-bold ${
                                                                    currentActor.rangedWeapon.ammo === 0 
                                                                        ? 'bg-red-600 text-white animate-pulse' 
                                                                        : 'bg-black text-white'
                                                                }`}>
                                                                    å¼¹è¯ {currentActor.rangedWeapon.ammo}/{currentActor.rangedWeapon.maxAmmo}
                                                                </span>
                                                                {/* v4.3.6 è£…å¼¹æŒ‰é’® */}
                                                                <button
                                                                    onClick={() => {
                                                                        updateChar(currentActor.id, { 
                                                                            rangedWeapon: { ...currentActor.rangedWeapon, ammo: currentActor.rangedWeapon.maxAmmo } 
                                                                        });
                                                                        addLog(`ğŸ”„ ${currentActor.name} é‡æ–°è£…å¡« ${currentActor.rangedWeapon.name}`, 'system');
                                                                    }}
                                                                    disabled={currentActor.rangedWeapon.ammo === currentActor.rangedWeapon.maxAmmo}
                                                                    className={`text-xs font-bold px-3 py-1 border-2 transition-all ${
                                                                        currentActor.rangedWeapon.ammo === 0
                                                                            ? 'bg-red-600 text-white border-red-600 animate-pulse'
                                                                            : currentActor.rangedWeapon.ammo === currentActor.rangedWeapon.maxAmmo
                                                                                ? 'bg-white text-gray-400 border-gray-300 cursor-not-allowed'
                                                                                : 'bg-white text-gray-600 border-gray-300 hover:border-black hover:text-black'
                                                                    }`}
                                                                >
                                                                    {currentActor.rangedWeapon.ammo === 0 ? 'âš ï¸ RELOAD' : 'ğŸ”„'}
                                                                </button>
                                                            </div>
                                                        </div>
                                                        
                                                        {/* è·ç¦»è®¾ç½® */}
                                                        <div className="flex items-center gap-2 mb-3 pb-3 border-b border-gray-100">
                                                            <span className="text-[10px] font-bold text-gray-500">è·ç¦»</span>
                                                            <div className="w-16"><SmartInput value={shootingDistance} onChange={setShootingDistance} /></div>
                                                            <span className="text-[10px] text-gray-400">/ {currentActor.rangedWeapon.range}ç </span>
                                                        </div>
                                                        
                                                        {/* å°„å‡»æ¨¡å¼é€‰æ‹© */}
                                                        <div className="mb-3">
                                                            <div className="text-[10px] font-bold text-gray-500 mb-2">å°„å‡»æ¨¡å¼</div>
                                                            <div className="grid grid-cols-3 gap-1">
                                                                <button 
                                                                    onClick={() => { setRapidFireShots(1); setAutoFireMode(false); }}
                                                                    className={`p-2 text-[10px] font-bold border transition-colors ${rapidFireShots === 1 && !autoFireMode ? 'bg-black text-white border-black' : 'bg-white border-gray-300 text-gray-500'}`}
                                                                >
                                                                    å•å‘
                                                                </button>
                                                                <button 
                                                                    onClick={() => { setRapidFireShots(2); setAutoFireMode(false); }}
                                                                    className={`p-2 text-[10px] font-bold border transition-colors ${rapidFireShots === 2 && !autoFireMode ? 'bg-black text-white border-black' : 'bg-white border-gray-300 text-gray-500'}`}
                                                                >
                                                                    è¿å°„Ã—2
                                                                </button>
                                                                <button 
                                                                    onClick={() => { setRapidFireShots(3); setAutoFireMode(false); }}
                                                                    className={`p-2 text-[10px] font-bold border transition-colors ${rapidFireShots === 3 && !autoFireMode ? 'bg-black text-white border-black' : 'bg-white border-gray-300 text-gray-500'}`}
                                                                >
                                                                    è¿å°„Ã—3
                                                                </button>
                                                            </div>
                                                            {/* æ™ºèƒ½æç¤º */}
                                                            {rapidFireShots === 1 && !autoFireMode && shootingDistance <= 3 && (
                                                                <div className="text-[10px] text-green-600 mt-1 p-1.5 bg-green-50 border border-green-200">
                                                                    âœ… æŠµè¿‘å°„å‡» (â‰¤3ç±³) å¯è·å¾—å¥–åŠ±éª°
                                                                </div>
                                                            )}
                                                            {rapidFireShots > 1 && !autoFireMode && shootingDistance <= 3 && (
                                                                <div className="text-[10px] text-blue-600 mt-1 p-1.5 bg-blue-50 border border-blue-200">
                                                                    âš–ï¸ æŠµè¿‘å¥–åŠ±éª°å¯æŠµæ¶ˆè¿å°„æƒ©ç½šéª°
                                                                </div>
                                                            )}
                                                            {rapidFireShots > 1 && !autoFireMode && shootingDistance > 3 && (
                                                                <div className="text-[10px] text-orange-600 mt-1">âš ï¸ æ¯å‘æ‰¿å—1ä¸ªæƒ©ç½šéª°</div>
                                                            )}
                                                        </div>
                                                        
                                                        {/* å…¨è‡ªåŠ¨æ¨¡å¼ï¼ˆä»…é™è‡ªåŠ¨æ­¦å™¨ï¼‰ */}
                                                        {currentActor.rangedWeapon.autoFire && (
                                                            <div className="mb-3 pt-3 border-t border-gray-100">
                                                                <label className="flex items-center gap-2 cursor-pointer mb-2">
                                                                    <input 
                                                                        type="checkbox" 
                                                                        checked={autoFireMode} 
                                                                        onChange={e => { setAutoFireMode(e.target.checked); if(e.target.checked) setRapidFireShots(1); }}
                                                                        className="w-4 h-4"
                                                                    />
                                                                    <span className="text-xs font-bold">ğŸ”¥ å…¨è‡ªåŠ¨å°„å‡»</span>
                                                                </label>
                                                                {autoFireMode && (
                                                                    <div className="ml-6 space-y-2">
                                                                        <div className="flex items-center gap-2">
                                                                            <span className="text-[10px] text-gray-500">å‘å°„å¼¹æ•°</span>
                                                                            <div className="w-16"><SmartInput value={autoFireBullets} onChange={setAutoFireBullets} /></div>
                                                                            <span className="text-[10px] text-gray-400">å‘</span>
                                                                        </div>
                                                                        <div className="text-[10px] text-gray-500">
                                                                            å¼¹å¹•å¤§å°: {getVolleySize()}å‘ | å…±{Math.ceil(autoFireBullets / getVolleySize())}ç»„å¼¹å¹•
                                                                        </div>
                                                                    </div>
                                                                )}
                                                            </div>
                                                        )}
                                                        
                                                        {/* å°„å‡»è¿‘æˆ˜ä¸­ç›®æ ‡ */}
                                                        <div className="mb-3">
                                                            <label className="flex items-center gap-2 cursor-pointer">
                                                                <input 
                                                                    type="checkbox" 
                                                                    checked={targetInMelee} 
                                                                    onChange={e => setTargetInMelee(e.target.checked)}
                                                                    className="w-4 h-4"
                                                                />
                                                                <span className="text-xs">âš ï¸ ç›®æ ‡åœ¨è¿‘æˆ˜ä¸­ (æƒ©ç½šéª°+å¯èƒ½è¯¯ä¼¤)</span>
                                                            </label>
                                                        </div>
                                                        
                                                        {/* åŒæªå°„å‡»ï¼ˆé€šä¿—æ¨¡å¼ï¼‰ */}
                                                        {hpMultiplier === 2 && !autoFireMode && rapidFireShots === 1 && (
                                                            <div className="mb-3 pt-3 border-t border-dashed border-purple-200">
                                                                <label className="flex items-center gap-2 cursor-pointer">
                                                                    <input 
                                                                        type="checkbox" 
                                                                        checked={dualWieldMode} 
                                                                        onChange={e => setDualWieldMode(e.target.checked)}
                                                                        className="w-4 h-4 accent-purple-600"
                                                                    />
                                                                    <span className="text-xs text-purple-700 font-bold">ğŸ”«ğŸ”« åŒæªå°„å‡» (é€šä¿—è§„åˆ™)</span>
                                                                </label>
                                                                {dualWieldMode && (
                                                                    <div className="text-[9px] text-purple-500 mt-1 ml-6">
                                                                        ä¸»æ‰‹æ­£å¸¸ + å‰¯æ‰‹æƒ©ç½šéª°ï¼Œæ¶ˆè€—2å‘å¼¹è¯
                                                                    </div>
                                                                )}
                                                            </div>
                                                        )}
                                                        
                                                        {/* v4.3.6 å°„å‡»ç¯å¢ƒä¿®æ­£ */}
                                                        <ShootingModifierSelector 
                                                            modifiers={shootingModifiers}
                                                            onChange={setShootingModifiers}
                                                        />
                                                        
                                                        {/* å°„å‡»æŒ‰é’® */}
                                                        <button 
                                                            onClick={handleShootClick}
                                                            disabled={currentActor.rangedWeapon.ammo < (dualWieldMode ? 2 : (autoFireMode ? autoFireBullets : rapidFireShots)) || !!pendingAction || resolutionCards.length > 0}
                                                            className={`w-full action-btn primary ${dualWieldMode ? 'bg-purple-600 border-purple-600 hover:bg-purple-700' : ''} ${(pendingAction || resolutionCards.length > 0) ? 'opacity-50' : ''}`}
                                                        >
                                                            <span className="font-black tracking-[0.05em]">
                                                                {dualWieldMode ? 'ğŸ”«ğŸ”« åŒæªå°„å‡»' :
                                                                 autoFireMode ? `ğŸ”¥ å…¨è‡ªåŠ¨å°„å‡» (${autoFireBullets}å‘)` : 
                                                                 rapidFireShots > 1 ? `ğŸ”« è¿å°„ ${rapidFireShots} å‘` : 
                                                                 `ğŸ”« å°„å‡»`}
                                                            </span>
                                                            <span className="detail">{currentActor.firearms}%</span>
                                                        </button>
                                                    </div>
                                                ) : (
                                                    <div className="text-center p-4 bg-gray-50 border-2 border-dashed border-gray-200 text-gray-400 text-xs">
                                                        æ— è¿œç¨‹æ­¦å™¨
                                                    </div>
                                                )}
                                            </div>
                                        </div>

                                        {/* æˆ˜æŠ€ä¸é€šç”¨åŠ¨ä½œ */}
                                        <div className="mb-6">
                                            <div className="flex items-baseline gap-2 mb-3 border-b-2 border-black pb-2">
                                                <span className="text-xs font-black tracking-wide">æˆ˜æŠ€ä¸å…¶ä»–</span>
                                            </div>
                                            <div className="grid grid-cols-2 gap-2">
                                                <button onClick={() => { setManeuverType('disarm'); handleManeuver(); }} className="action-btn">
                                                    <span>ğŸ¤š ç¼´æ¢°</span>
                                                    <span className="detail">{currentActor?.fight}%</span>
                                                </button>
                                                <button onClick={() => { setManeuverType('knockdown'); handleManeuver(); }} className="action-btn">
                                                    <span>ğŸ¦µ å‡»å€’</span>
                                                    <span className="detail">{currentActor?.fight}%</span>
                                                </button>
                                                <button onClick={() => { setManeuverType('grapple'); handleManeuver(); }} className="action-btn">
                                                    <span>ğŸ¤¼ æ“’æŠ±</span>
                                                    <span className="detail">{currentActor?.fight}%</span>
                                                </button>
                                                {hpMultiplier === 2 && (
                                                    <button onClick={() => { setManeuverType('stun'); handleManeuver(); }} className="action-btn bg-yellow-50 border-yellow-300 hover:bg-yellow-100">
                                                        <span>ğŸ’« å‡»æ™•</span>
                                                        <span className="detail">{currentActor?.fight}%</span>
                                                    </button>
                                                )}
                                            </div>
                                        </div>

                                        {/* åŒ»ç–—ä¸è·³è¿‡ */}
                                        <div className="grid grid-cols-2 gap-3">
                                            <button onClick={() => setShowMedical(true)} className="action-btn">
                                                <span>ğŸ’Š åŒ»ç–—</span>
                                            </button>
                                            <button onClick={nextTurn} className="action-btn border-gray-300 text-gray-500 hover:border-black hover:text-black">
                                                <span>â­ï¸ è·³è¿‡å›åˆ</span>
                                            </button>
                                        </div>
                                    </>
                                )}
                            </>
                        )}
                        {/* Medical Panel */}
                        {phase === 'select_action' && showMedical && (
                            <div className="space-y-4">
                                <div className="text-center font-black text-sm border-b-2 border-black pb-3 mb-4 tracking-[0.1em]">
                                    ğŸ’Š åŒ» ç–— è¡Œ åŠ¨
                                </div>
                                
                                <div className="bg-blue-50 p-3 border border-blue-200">
                                    <div className="text-xs text-blue-600 font-bold mb-1">æ²»ç–—è€…</div>
                                    <div className="font-bold">{currentActor?.name}</div>
                                    <div className="text-xs text-blue-500 mt-1">æ€¥æ•‘ {currentActor?.firstAid || 30}% | åŒ»å­¦ {currentActor?.medicine || 5}%</div>
                                </div>

                                {targetActor && (
                                    <div className="bg-red-50 p-3 border border-red-200">
                                        <div className="text-xs text-red-600 font-bold mb-1">æ‚£è€…</div>
                                        <div className="font-bold">{targetActor.name}</div>
                                        <div className="text-xs text-red-500 mt-1">ç”Ÿå‘½: {targetActor.hp}/{targetActor.maxHp} {targetActor.status.dying && 'âš ï¸ æ¿’æ­»'}</div>
                                    </div>
                                )}

                                <div className="flex items-baseline gap-2">
                                    <span className="text-xs font-black text-gray-500">éª°å­è°ƒæ•´</span>
                                </div>
                                <DiceModifierSelector value={diceModifier} onChange={setDiceModifier} />

                                <div className="flex items-baseline gap-2">
                                    <span className="text-xs font-black text-gray-500">é€‰æ‹©æ²»ç–—æ–¹å¼</span>
                                </div>
                                <div className="grid grid-cols-1 gap-3">
                                    <button onClick={() => startMedical('firstAid')} disabled={!targetActor} className="action-btn">
                                        <span className="font-bold">ğŸ©¹ æ€¥æ•‘</span>
                                        <span className="detail">æ¢å¤ 1 HP</span>
                                    </button>
                                    <button onClick={() => startMedical('medicine')} disabled={!targetActor} className="action-btn">
                                        <span className="font-bold">âš•ï¸ åŒ»å­¦</span>
                                        <span className="detail">æ¢å¤ 1D3 HP</span>
                                    </button>
                                </div>

                                <button onClick={() => setShowMedical(false)} className="w-full mt-4 py-2 text-xs text-gray-500 hover:text-black font-bold">â† è¿”å›</button>
                            </div>
                        )}

                        {/* Medical Roll Input Phase */}
                        {phase === 'medical_roll' && medicalType && (
                            <div className="space-y-6">
                                <div className="text-center border-b-2 border-black pb-3">
                                    <div className="font-black text-sm tracking-[0.1em]">
                                        {medicalType === 'firstAid' ? 'ğŸ©¹ æ€¥ æ•‘ æ£€ å®š' : 'âš•ï¸ åŒ» å­¦ æ£€ å®š'}
                                    </div>
                                </div>
                                
                                <div className="text-center bg-gray-50 p-4 border-2 border-gray-200">
                                    <div className="text-xs font-bold text-gray-500">æ£€å®šç›®æ ‡å€¼</div>
                                    <div className="text-5xl font-mono font-black mt-2">
                                        {medicalType === 'firstAid' ? (currentActor?.firstAid || 30) : (currentActor?.medicine || 5)}
                                    </div>
                                </div>

                                <div className="bg-red-50 p-3 border border-red-200 text-center">
                                    <div className="text-xs text-red-600">æ‚£è€…: <strong>{targetActor?.name}</strong></div>
                                    <div className="text-xs text-red-500">ç”Ÿå‘½: {targetActor?.hp}/{targetActor?.maxHp}</div>
                                </div>

                                <DiceModifierSelector value={diceModifier} onChange={setDiceModifier} />
                                
                                <div className="flex gap-3 items-end">
                                    <div className="flex-1">
                                        <SmartInput 
                                            value={inputValue} 
                                            onChange={setInputValue}
                                            label="æ£€å®šç»“æœ"
                                            sublabel="1-100"
                                        />
                                    </div>
                                    <button 
                                        onClick={() => {
                                            const targetNum = medicalType === 'firstAid' ? (currentActor?.firstAid || 30) : (currentActor?.medicine || 5);
                                            openStepDiceRoller(targetNum, null);
                                        }} 
                                        className="h-[52px] w-[52px] bg-black text-white flex items-center justify-center text-2xl border-2 border-black hover:bg-gray-800"
                                    >
                                        ğŸ²
                                    </button>
                                </div>
                                
                                <button 
                                    onClick={executeMedical} 
                                    disabled={!inputValue} 
                                    className="action-btn primary justify-center py-4 text-base font-black tracking-[0.1em]"
                                >
                                    ç¡® è®¤ æ äº¤
                                </button>

                                <button onClick={() => { setPhase('select_action'); setMedicalType(null); }} className="w-full py-2 text-xs text-gray-500 hover:text-black font-bold">â† è¿”å›</button>
                            </div>
                        )}

                        {/* Rapid Fire Roll Phase - è¿å°„æ£€å®š */}
                        {phase === 'rapid_fire_roll' && combatAction?.type === 'rapid_fire' && (
                            <div className="space-y-6">
                                <div className="text-center border-b border-black pb-3">
                                    <div className="font-bold text-sm uppercase">
                                        ğŸ”« è¿å°„æ£€å®š Rapid Fire ({combatAction.shotsCurrent + 1}/{combatAction.shotsTotal})
                                    </div>
                                </div>
                                
                                {/* æ™ºèƒ½æç¤º */}
                                {shootingDistance <= 3 ? (
                                    <div className="bg-green-50 p-3 border border-green-200 text-center">
                                        <div className="text-xs text-green-800 mb-1">âœ… æŠµè¿‘å°„å‡» (â‰¤3m)</div>
                                        <div className="text-sm font-bold text-green-700">å¥–åŠ±éª°å¯æŠµæ¶ˆè¿å°„æƒ©ç½šï¼Œå¯åˆ‡æ¢ä¸ºæ ‡å‡†éª°</div>
                                    </div>
                                ) : (
                                    <div className="bg-orange-50 p-3 border border-orange-200 text-center">
                                        <div className="text-xs text-orange-800 mb-1">âš ï¸ è¿å°„æƒ©ç½šéª°ç”Ÿæ•ˆ</div>
                                        <div className="text-sm font-bold">æ¯å‘æ£€å®šæ‰¿å—1ä¸ªæƒ©ç½šéª°</div>
                                    </div>
                                )}
                                
                                <div className="text-center bg-gray-50 p-4 border border-gray-100">
                                    <div className="label">ç›®æ ‡å€¼ Target Number</div>
                                    <div className="text-5xl font-mono font-bold mt-2">
                                        {combatAction.difficulty === 'extreme' ? Math.floor(currentActor.firearms / 5) :
                                         combatAction.difficulty === 'hard' ? Math.floor(currentActor.firearms / 2) :
                                         currentActor.firearms}
                                    </div>
                                    <div className="text-xs text-gray-500 mt-1">{combatAction.difficulty === 'extreme' ? 'æéš¾' : combatAction.difficulty === 'hard' ? 'å›°éš¾' : 'å¸¸è§„'}</div>
                                </div>

                                {/* éª°å­ä¿®æ­£é€‰æ‹©å™¨ */}
                                <DiceModifierSelector value={diceModifier} onChange={setDiceModifier} />

                                {combatAction.hits.length > 0 && (
                                    <div className="text-sm text-center text-green-600 font-bold">
                                        âœ… å·²å‘½ä¸­ {combatAction.hits.length} å‘
                                    </div>
                                )}
                                
                                <div className="flex gap-3 items-end">
                                    <div className="flex-1">
                                        <SmartInput 
                                            value={inputValue} 
                                            onChange={setInputValue}
                                            label={`ç¬¬${combatAction.shotsCurrent + 1}å‘æ£€å®šç»“æœ`}
                                        />
                                    </div>
                                    <button 
                                        onClick={() => {
                                            const result = rollWithModifier(diceModifier);
                                            // v4.3.6ä¿®å¤: æ”¹ä¸ºæ•°å­—åˆ¤æ–­
                                            if (diceModifier < 0) {
                                                addLog(`ğŸ² ${Math.abs(diceModifier)}ä¸ªæƒ©ç½šéª°: [${result.rolls.join(', ')}] â†’ ${result.result}`, 'roll');
                                            } else if (diceModifier > 0) {
                                                addLog(`ğŸ² ${diceModifier}ä¸ªå¥–åŠ±éª°: [${result.rolls.join(', ')}] â†’ ${result.result}`, 'roll');
                                            } else {
                                                addLog(`ğŸ² æ ‡å‡†éª°: ${result.result}`, 'roll');
                                            }
                                            setInputValue(String(result.result));
                                        }} 
                                        className={`h-[52px] w-[52px] text-white flex items-center justify-center text-2xl border ${
                                            diceModifier < 0 ? 'bg-orange-500 border-orange-500 hover:bg-orange-600' :
                                            diceModifier > 0 ? 'bg-green-500 border-green-500 hover:bg-green-600' :
                                            'bg-black border-black hover:bg-gray-800'
                                        }`}
                                    >
                                        ğŸ²
                                    </button>
                                </div>
                                
                                <button 
                                    onClick={handleRapidFireShot} 
                                    disabled={!inputValue} 
                                    className="action-btn primary justify-center py-4 text-base font-black tracking-[0.05em]"
                                >
                                    ç¡® è®¤ ç¬¬ {combatAction.shotsCurrent + 1} å‘
                                </button>
                            </div>
                        )}

                        {/* Rapid Fire Damage Phase - è¿å°„ä¼¤å®³ */}
                        {phase === 'rapid_fire_damage' && combatAction?.type === 'rapid_fire' && (
                            <div className="space-y-6">
                                <div className="text-center border-b-2 border-black pb-3">
                                    <div className="font-black text-sm tracking-[0.1em]">
                                        ğŸ’¥ è¿ å°„ ä¼¤ å®³ ({combatAction.currentHitIndex + 1}/{combatAction.hits.length})
                                    </div>
                                </div>
                                
                                <div className="text-center p-3 bg-red-50 border border-red-200">
                                    <div className="text-xs text-red-600 font-bold">ç›®æ ‡</div>
                                    <div className="font-bold text-lg">{combatAction.target.name}</div>
                                    <div className="text-xs text-red-500 mt-1">
                                        ç¬¬{combatAction.currentHitIndex + 1}å‘å‘½ä¸­ ({getSuccessLabel(combatAction.hits[combatAction.currentHitIndex]?.level)})
                                    </div>
                                </div>

                                <div className="text-center font-mono text-sm p-3 bg-gray-50 border-2 border-gray-200">
                                    {combatAction.weapon.name} ({combatAction.weapon.damage})
                                </div>
                                
                                <div className="flex gap-3 items-end">
                                    <div className="flex-1">
                                        <SmartInput 
                                            value={inputValue} 
                                            onChange={setInputValue}
                                            label="ä¼¤å®³å€¼"
                                        />
                                    </div>
                                    <button 
                                        onClick={() => {
                                            const dmg = calculateDamage(combatAction.weapon, currentActor, combatAction.hits[combatAction.currentHitIndex]?.level || 1, false, hpMultiplier);
                                            setInputValue(String(dmg.total));
                                            setCombatAction(prev => ({ ...prev, currentDamageLog: dmg.damageLog }));
                                        }} 
                                        className="h-[52px] w-[52px] bg-black text-white flex items-center justify-center text-2xl border-2 border-black hover:bg-gray-800"
                                    >
                                        ğŸ²
                                    </button>
                                </div>
                                
                                <button 
                                    onClick={handleRapidFireDamage} 
                                    disabled={!inputValue} 
                                    className="action-btn primary justify-center py-4 text-base font-black tracking-[0.05em]"
                                >
                                    ç¡®è®¤ä¼¤å®³ Confirm Damage
                                </button>
                            </div>
                        )}

                        {/* Dual Wield Roll Phase - åŒæªå°„å‡»æ£€å®š (é€šä¿—æ¨¡å¼) */}
                        {phase === 'dual_wield_roll' && combatAction?.type === 'dual_wield' && (
                            <div className="space-y-6">
                                <div className="text-center border-b-2 border-purple-500 pb-3">
                                    <div className="font-black text-sm tracking-[0.1em] text-purple-700">
                                        ğŸ”«ğŸ”« åŒæªæ£€å®š ({combatAction.shotsCurrent + 1}/2)
                                    </div>
                                    <div className="text-[9px] text-purple-400 mt-1">DUAL WIELD (PULP)</div>
                                </div>
                                
                                <div className={`p-3 border text-center ${combatAction.shotsCurrent === 0 ? 'bg-green-50 border-green-200' : 'bg-orange-50 border-orange-200'}`}>
                                    <div className="text-xs font-bold mb-1">
                                        {combatAction.shotsCurrent === 0 ? 'ğŸ¯ ä¸»æ‰‹å°„å‡»' : 'âš ï¸ å‰¯æ‰‹å°„å‡» (æƒ©ç½šéª°)'}
                                    </div>
                                    <div className="text-[10px] text-gray-600">
                                        {combatAction.shotsCurrent === 0 ? 'æ­£å¸¸æ£€å®š' : 'ä½¿ç”¨æƒ©ç½šéª°'}
                                    </div>
                                </div>
                                
                                <div className="text-center bg-gray-50 p-4 border border-gray-100">
                                    <div className="label">ç›®æ ‡å€¼ Target Number</div>
                                    <div className="text-5xl font-mono font-bold mt-2">
                                        {combatAction.difficulty === 'extreme' ? Math.floor(currentActor.firearms / 5) :
                                         combatAction.difficulty === 'hard' ? Math.floor(currentActor.firearms / 2) :
                                         currentActor.firearms}
                                    </div>
                                    <div className="text-xs text-gray-500 mt-1">{combatAction.difficulty === 'extreme' ? 'æéš¾' : combatAction.difficulty === 'hard' ? 'å›°éš¾' : 'å¸¸è§„'}</div>
                                </div>

                                {/* éª°å­ä¿®æ­£é€‰æ‹©å™¨ */}
                                <DiceModifierSelector value={diceModifier} onChange={setDiceModifier} />

                                {combatAction.hits.filter(h => h.level > 0).length > 0 && (
                                    <div className="text-sm text-center text-green-600 font-bold">
                                        âœ… å·²å‘½ä¸­ {combatAction.hits.filter(h => h.level > 0).length} å‘
                                    </div>
                                )}
                                
                                <div className="flex gap-3 items-end">
                                    <div className="flex-1">
                                        <SmartInput 
                                            value={inputValue} 
                                            onChange={setInputValue}
                                            label={`${combatAction.shotsCurrent === 0 ? 'ä¸»æ‰‹' : 'å‰¯æ‰‹'}æ£€å®šç»“æœ`}
                                        />
                                    </div>
                                    <button 
                                        onClick={() => {
                                            const result = rollWithModifier(diceModifier);
                                            if (diceModifier === 'penalty') {
                                                addLog(`ğŸ² æƒ©ç½šéª°: [${result.roll1}, ${result.roll2}] â†’ ${result.result}`, 'roll');
                                            } else if (diceModifier === 'bonus') {
                                                addLog(`ğŸ² å¥–åŠ±éª°: [${result.roll1}, ${result.roll2}] â†’ ${result.result}`, 'roll');
                                            } else {
                                                addLog(`ğŸ² æ ‡å‡†éª°: ${result.result}`, 'roll');
                                            }
                                            setInputValue(String(result.result));
                                        }} 
                                        className={`h-[52px] w-[52px] text-white flex items-center justify-center text-2xl border ${
                                            diceModifier === 'penalty' ? 'bg-orange-500 border-orange-500 hover:bg-orange-600' :
                                            diceModifier === 'bonus' ? 'bg-green-500 border-green-500 hover:bg-green-600' :
                                            'bg-purple-600 border-purple-600 hover:bg-purple-700'
                                        }`}
                                    >
                                        ğŸ²
                                    </button>
                                </div>
                                
                                <button 
                                    onClick={handleDualWieldShot} 
                                    disabled={!inputValue} 
                                    className="action-btn primary justify-center py-4 text-base font-black tracking-[0.05em] bg-purple-600 border-purple-600 hover:bg-purple-700"
                                >
                                    ç¡® è®¤ {combatAction.shotsCurrent === 0 ? 'ä¸»æ‰‹' : 'å‰¯æ‰‹'} å°„å‡»
                                </button>
                            </div>
                        )}

                        {/* Dual Wield Damage Phase - åŒæªä¼¤å®³ */}
                        {phase === 'dual_wield_damage' && combatAction?.type === 'dual_wield' && (
                            <div className="space-y-6">
                                <div className="text-center border-b-2 border-purple-500 pb-3">
                                    <div className="font-black text-sm tracking-[0.1em] text-purple-700">
                                        ğŸ’¥ åŒæªä¼¤å®³ ({combatAction.currentHitIndex + 1}/{combatAction.hits.length})
                                    </div>
                                </div>
                                
                                <div className="text-center p-3 bg-red-50 border border-red-200">
                                    <div className="text-xs text-red-600 font-bold">ç›®æ ‡</div>
                                    <div className="font-bold text-lg">{combatAction.target.name}</div>
                                    <div className="text-xs text-red-500 mt-1">
                                        {combatAction.hits[combatAction.currentHitIndex]?.hand} å‘½ä¸­ ({getSuccessLabel(combatAction.hits[combatAction.currentHitIndex]?.level)})
                                    </div>
                                </div>

                                <div className="text-center font-mono text-sm p-3 bg-gray-50 border-2 border-gray-200">
                                    {combatAction.weapon.name} ({combatAction.weapon.damage})
                                </div>
                                
                                <div className="flex gap-3 items-end">
                                    <div className="flex-1">
                                        <SmartInput 
                                            value={inputValue} 
                                            onChange={setInputValue}
                                            label="ä¼¤å®³å€¼"
                                        />
                                    </div>
                                    <button 
                                        onClick={() => {
                                            const dmg = calculateDamage(combatAction.weapon, currentActor, combatAction.hits[combatAction.currentHitIndex]?.level || 1, false, hpMultiplier);
                                            setInputValue(String(dmg.total));
                                            setCombatAction(prev => ({ ...prev, currentDamageLog: dmg.damageLog }));
                                        }} 
                                        className="h-[52px] w-[52px] bg-purple-600 text-white flex items-center justify-center text-2xl border-2 border-purple-600 hover:bg-purple-700"
                                    >
                                        ğŸ²
                                    </button>
                                </div>
                                
                                <button 
                                    onClick={handleDualWieldDamage} 
                                    disabled={!inputValue} 
                                    className="action-btn primary justify-center py-4 text-base font-black tracking-[0.05em] bg-purple-600 border-purple-600 hover:bg-purple-700"
                                >
                                    ç¡®è®¤ä¼¤å®³ Confirm Damage
                                </button>
                            </div>
                        )}

                        {/* Auto Fire Roll Phase - è‡ªåŠ¨å°„å‡»å¼¹å¹•æ£€å®š */}
                        {phase === 'auto_fire_roll' && combatAction?.type === 'auto_fire' && (
                            <div className="space-y-6">
                                <div className="text-center border-b border-black pb-3">
                                    <div className="font-bold text-sm uppercase">
                                        ğŸ”¥ å¼¹å¹•æ£€å®š Volley ({combatAction.currentVolley + 1}/{combatAction.totalVolleys})
                                    </div>
                                </div>
                                
                                {combatAction.currentVolley > 0 && (
                                    <div className="bg-orange-50 p-3 border border-orange-200 text-center">
                                        <div className="text-xs text-orange-800">
                                            âš ï¸ ç´¯è®¡æƒ©ç½šéª°: {Math.min(combatAction.currentVolley, 2)}ä¸ª
                                            {combatAction.currentVolley > 2 && ` + éš¾åº¦æå‡${combatAction.currentVolley - 2}çº§`}
                                        </div>
                                    </div>
                                )}
                                
                                <div className="text-center bg-gray-50 p-4 border border-gray-100">
                                    <div className="label">ç›®æ ‡å€¼ Target Number</div>
                                    <div className="text-5xl font-mono font-bold mt-2">
                                        {(() => {
                                            let skill = currentActor.firearms;
                                            const boost = combatAction.currentVolley > 2 ? combatAction.currentVolley - 2 : 0;
                                            for (let i = 0; i < boost; i++) skill = Math.floor(skill / 2);
                                            return skill;
                                        })()}
                                    </div>
                                    <div className="text-xs text-gray-500 mt-1">æ¯ç»„å¼¹å¹•{combatAction.volleySize}å‘</div>
                                </div>

                                {combatAction.results.length > 0 && (
                                    <div className="text-sm">
                                        <div className="font-bold mb-1">å·²å®Œæˆå¼¹å¹•:</div>
                                        {combatAction.results.map((r, i) => (
                                            <div key={i} className="text-xs">
                                                å¼¹å¹•{i+1}: [{r.roll}] {getSuccessLabel(r.successLevel)} - å‘½ä¸­{r.hits}å‘
                                            </div>
                                        ))}
                                    </div>
                                )}
                                
                                <div className="flex gap-3 items-end">
                                    <div className="flex-1">
                                        <SmartInput 
                                            value={inputValue} 
                                            onChange={setInputValue}
                                            label={`å¼¹å¹•${combatAction.currentVolley + 1}æ£€å®šç»“æœ`}
                                        />
                                    </div>
                                    <button 
                                        onClick={() => {
                                            const penaltyCount = Math.min(combatAction.currentVolley, 2);
                                            // v4.3.6ä¿®å¤: æ”¹ä¸ºæ•°å­—å‚æ•°
                                            if (penaltyCount > 0) {
                                                const result = rollWithModifier(-penaltyCount);
                                                addLog(`ğŸ² ${penaltyCount}ä¸ªæƒ©ç½šéª°: [${result.rolls.join(', ')}] â†’ ${result.result}`, 'roll');
                                                setInputValue(String(result.result));
                                            } else {
                                                const result = rollWithModifier(0);
                                                addLog(`ğŸ² æ ‡å‡†éª°: ${result.result}`, 'roll');
                                                setInputValue(String(result.result));
                                            }
                                        }} 
                                        className="h-[52px] w-[52px] bg-red-500 text-white flex items-center justify-center text-2xl border border-red-500 hover:bg-red-600"
                                    >
                                        ğŸ²
                                    </button>
                                </div>
                                
                                <button 
                                    onClick={handleVolleyRoll} 
                                    disabled={!inputValue} 
                                    className="action-btn primary justify-center py-4 text-base"
                                >
                                    ç¡®è®¤å¼¹å¹•{combatAction.currentVolley + 1} Confirm
                                </button>
                            </div>
                        )}

                        {/* Auto Fire Damage Phase - è‡ªåŠ¨å°„å‡»ä¼¤å®³ */}
                        {phase === 'auto_fire_damage' && combatAction?.type === 'auto_fire' && (
                            <div className="space-y-6">
                                <div className="text-center border-b border-black pb-3">
                                    <div className="font-bold text-sm uppercase">
                                        ğŸ’¥ è‡ªåŠ¨å°„å‡»ä¼¤å®³ ({combatAction.hitsProcessed + 1}/{combatAction.totalHits})
                                    </div>
                                </div>
                                
                                <div className="text-center p-3 bg-red-50 border border-red-100">
                                    <div className="text-xs text-red-800">ç›®æ ‡ Target</div>
                                    <div className="font-bold text-lg">{combatAction.targets[combatAction.currentTargetIndex]?.name || targetActor?.name}</div>
                                    <div className="text-xs text-red-600 mt-1">æ€»è®¡å‘½ä¸­{combatAction.totalHits}å‘</div>
                                </div>

                                <div className="text-center font-mono text-sm p-3 bg-gray-50 border border-gray-100">
                                    {combatAction.weapon.name} ({combatAction.weapon.damage})
                                </div>
                                
                                <div className="flex gap-3 items-end">
                                    <div className="flex-1">
                                        <SmartInput 
                                            value={inputValue} 
                                            onChange={setInputValue}
                                            label={`ç¬¬${combatAction.hitsProcessed + 1}å‘ä¼¤å®³`}
                                        />
                                    </div>
                                    <button 
                                        onClick={() => {
                                            const dmg = calculateDamage(combatAction.weapon, currentActor, 1, false, hpMultiplier);
                                            setInputValue(String(dmg.total));
                                            setCombatAction(prev => ({ ...prev, currentDamageLog: dmg.damageLog }));
                                        }} 
                                        className="h-[52px] w-[52px] bg-black text-white flex items-center justify-center text-2xl border border-black hover:bg-gray-800"
                                    >
                                        ğŸ²
                                    </button>
                                </div>
                                
                                <button 
                                    onClick={handleAutoFireDamage} 
                                    disabled={!inputValue} 
                                    className="action-btn primary justify-center py-4 text-base"
                                >
                                    ç¡®è®¤ä¼¤å®³ Confirm
                                </button>
                            </div>
                        )}

                        {/* Defense Phase */}
                        {phase === 'waiting_defense' && (
                            <div className="space-y-6">
                                <div className="flex justify-between items-center p-4 border border-black bg-gray-50">
                                    <div className="text-center">
                                        <div className="font-bold text-lg">{combatAction?.attacker.name}</div>
                                        <div className="text-[10px] bg-black text-white px-2 py-0.5 inline-block uppercase mt-1">æ”»å‡»è€… ATK</div>
                                    </div>
                                    <div className="font-black text-2xl text-gray-300">VS</div>
                                    <div className="text-center">
                                        <div className="font-bold text-lg">{combatAction?.target.name}</div>
                                        <div className="text-[10px] bg-gray-500 text-white px-2 py-0.5 inline-block uppercase mt-1">é˜²å¾¡è€… DEF</div>
                                    </div>
                                </div>
                                
                                {targetActor?.status.defenseUsedThisRound && (
                                    <div className="text-xs text-center p-2 bg-yellow-50 text-yellow-800 border border-yellow-200 font-bold">
                                        âš ï¸ æœ¬è½®å·²é˜²å¾¡ (æ”»å‡»è·å¾—å¥–åŠ±éª°)
                                    </div>
                                )}
                                
                                {/* ç–¯ç‹‚å†²é”‹è­¦å‘Š - é˜²å¾¡è€…è§†è§’ */}
                                {hpMultiplier === 2 && targetActor?.status.madChargeUsed && (
                                    <div className="text-xs text-center p-2 bg-orange-50 text-orange-800 border border-orange-200 font-bold">
                                        ğŸƒğŸ’¨ æœ¬è½®ä½¿ç”¨äº†ç–¯ç‹‚å†²é”‹ï¼Œæ— æ³•é—ªé¿ï¼
                                    </div>
                                )}
                                
                                {/* ç–¯ç‹‚å†²é”‹è­¦å‘Š - æ”»å‡»è€…è§†è§’ï¼šé˜²å¾¡è€…åå‡»è·å¾—å¥–åŠ±éª° */}
                                {hpMultiplier === 2 && combatAction?.madCharge && (
                                    <div className="text-xs text-center p-2 bg-orange-100 text-orange-700 border border-orange-300 font-bold">
                                        ğŸƒğŸ’¨ ç–¯ç‹‚å†²é”‹ä¸­ï¼é˜²å¾¡è€…åå‡»è·å¾—å¥–åŠ±éª°
                                    </div>
                                )}
                                
                                <div className="label mb-2 text-center">é€‰æ‹©é˜²å¾¡æ‰‹æ®µ Choose Defense</div>
                                <div className="grid grid-cols-1 gap-3">
                                    <button 
                                        onClick={() => {
                                            setCombatAction(p => ({ ...p, defenseType: 'counter', defenderSkill: targetActor.fight }));
                                            // ç–¯ç‹‚å†²é”‹è§„åˆ™ï¼šé˜²å¾¡è€…åå‡»ä¹Ÿè·å¾—å¥–åŠ±éª°
                                            if (combatAction?.madCharge && hpMultiplier === 2) {
                                                setDiceModifier(1); // v4.3.6ä¿®å¤: æ•°å­—æ ¼å¼
                                            }
                                            setPhase('input_roll');
                                        }} 
                                        className="action-btn primary justify-center flex-col gap-1 py-4"
                                    >
                                        <span className="text-lg">âš”ï¸ åå‡» Fight Back</span>
                                        <span className="text-xs opacity-70 font-mono">
                                            æŠ€èƒ½: {targetActor?.fight}%
                                            {combatAction?.madCharge && hpMultiplier === 2 && <span className="text-orange-300 ml-1">(å¥–åŠ±éª°)</span>}
                                        </span>
                                    </button>
                                    <button 
                                        onClick={() => {
                                            setCombatAction(p => ({ ...p, defenseType: 'dodge', defenderSkill: targetActor.dodge }));
                                            setPhase('input_roll');
                                        }} 
                                        disabled={hpMultiplier === 2 && targetActor?.status.madChargeUsed}
                                        className={`action-btn justify-center flex-col gap-1 py-4 ${hpMultiplier === 2 && targetActor?.status.madChargeUsed ? 'opacity-50 cursor-not-allowed bg-gray-100' : ''}`}
                                    >
                                        <span className="text-lg">ğŸ’¨ é—ªé¿ Dodge</span>
                                        <span className="text-xs text-gray-500 font-mono">
                                            {hpMultiplier === 2 && targetActor?.status.madChargeUsed ? 'ğŸš« ç–¯ç‹‚å†²é”‹åä¸å¯ç”¨' : `æŠ€èƒ½: ${targetActor?.dodge}%`}
                                        </span>
                                    </button>
                                </div>
                            </div>
                        )}

                        {/* Roll Input Phase */}
                        {(['input_roll', 'input_defense_roll', 'input_damage'].includes(phase)) && combatAction && (
                            <div className="space-y-6">
                                <div className="text-center border-b border-black pb-3">
                                    <div className="font-bold text-sm uppercase">
                                        {phase === 'input_damage' ? 'ä¼¤å®³æ£€å®š Damage Roll' : phase === 'input_roll' ? `${currentActor.name} æ£€å®š` : `${targetActor.name} é˜²å¾¡æ£€å®š`}
                                    </div>
                                </div>
                                
                                {phase !== 'input_damage' && (
                                    <>
                                        <div className="text-center bg-gray-50 p-4 border border-gray-100">
                                            <div className="label">ç›®æ ‡å€¼ Target Number</div>
                                            <div className="text-5xl font-mono font-bold mt-2">
                                                {phase === 'input_roll' 
                                                    ? (combatAction.type === 'ranged' ? currentActor.firearms : combatAction.attackerSkill) 
                                                    : combatAction.defenderSkill}
                                            </div>
                                        </div>
                                        <DiceModifierSelector value={diceModifier} onChange={setDiceModifier} />
                                    </>
                                )}
                                
                                {phase === 'input_damage' && (
                                    <div className="text-center font-mono text-sm p-3 bg-red-50 border border-red-100 text-red-800">
                                        <div className="font-bold">ä½¿ç”¨æ­¦å™¨ Weapon</div>
                                        {combatAction.weapon?.name} ({combatAction.weapon?.damage}{combatAction.weapon?.type === 'melee' && combatAction.damageAttacker?.db !== '0' ? '+DB' : ''})
                                    </div>
                                )}
                                
                                {/* èº²è¿‡ä¸€åŠ« - é€šä¿—æ¨¡å¼ä¼¤å®³é˜¶æ®µå¯ç”¨ */}
                                {phase === 'input_damage' && hpMultiplier === 2 && (() => {
                                    const target = combatAction?.isCounterAttack ? currentActor : targetActor;
                                    return target && (
                                        <div className="p-3 bg-purple-50 border border-purple-200">
                                            <div className="flex items-center justify-between">
                                                <div>
                                                    <div className="text-[10px] font-bold text-purple-700">ğŸ€ å¹¸è¿å‡ä¼¤ (é€šä¿—è§„åˆ™)</div>
                                                    <div className="text-[9px] text-purple-500 mt-0.5">
                                                        {target.name} å¹¸è¿: {target.luck || 50} | å·²å‡ä¼¤: {luckDamageReduction}
                                                    </div>
                                                </div>
                                                <button
                                                    onClick={spendLuckDodgedABullet}
                                                    disabled={(target.luck || 0) < 10}
                                                    className="px-3 py-2 text-[10px] font-bold bg-purple-600 text-white hover:bg-purple-700 disabled:opacity-50 disabled:cursor-not-allowed"
                                                >
                                                    èº²è¿‡ä¸€åŠ« -10ğŸ€ â†’ ä¼¤å®³-5
                                                </button>
                                            </div>
                                        </div>
                                    );
                                })()}
                                
                                <div className="flex gap-3 items-end">
                                    <div className="flex-1">
                                        <SmartInput 
                                            value={inputValue} 
                                            onChange={setInputValue}
                                            label={phase === 'input_damage' ? "è¾“å…¥ä¼¤å®³å€¼ Damage" : "è¾“å…¥æ£€å®šç»“æœ Result (1-100)"}
                                        />
                                    </div>
                                    <button 
                                        onClick={() => {
                                            if (phase === 'input_damage') {
                                                const dmg = calculateDamage(combatAction.weapon, combatAction.damageAttacker, combatAction.damageSuccessLevel || 1, !!combatAction.isCounterAttack, hpMultiplier);
                                                setInputValue(String(dmg.total));
                                                setCombatAction(prev => ({ ...prev, damageLog: dmg.damageLog }));
                                            } else {
                                                const targetNum = phase === 'input_roll' 
                                                    ? (combatAction.type === 'ranged' ? currentActor.firearms : combatAction.attackerSkill) 
                                                    : combatAction.defenderSkill;
                                                openStepDiceRoller(targetNum, null);
                                            }
                                        }} 
                                        className="h-[52px] w-[52px] bg-black text-white flex items-center justify-center text-2xl border-2 border-black hover:bg-gray-800"
                                    >
                                        ğŸ²
                                    </button>
                                </div>
                                
                                <button 
                                    onClick={phase === 'input_damage' ? handleDamage : phase === 'input_defense_roll' ? handleDefenseRoll : handleRoll} 
                                    disabled={!inputValue} 
                                    className="action-btn primary justify-center py-4 text-base font-black tracking-[0.1em]"
                                >
                                    ç¡® è®¤ æ äº¤
                                </button>
                            </div>
                        )}
                    </div>
                </div>
            </div>

            {/* å³ä¾§æ—¥å¿— */}
            <div className={`panel-right ${mobileTab === 'log' ? 'panel-mobile-active' : ''}`}>
                <div className="p-4 border-b-2 border-black bg-white">
                    <div className="flex items-baseline gap-2">
                        <span className="text-xs font-black text-gray-500 tracking-wide">æˆ˜æ–—è®°å½•</span>
                        <span className="text-[9px] font-mono text-gray-300">LOG</span>
                    </div>
                </div>
                <div className="log-scroll-area" ref={logContainerRef}>
                    {logs.map(log => (
                        <div key={log.id} className={`log-item ${log.type}`}>
                            <div className="text-[9px] text-gray-400 mb-1 font-mono">{log.time}</div>
                            <div className="text-gray-700">{log.text}</div>
                        </div>
                    ))}
                    {logs.length === 0 && <div className="text-center text-gray-300 text-xs mt-10 font-bold tracking-wide">æš‚æ— æˆ˜æ–—è®°å½•</div>}
                </div>
            </div>

            {/* ç§»åŠ¨ç«¯åº•éƒ¨å¯¼èˆª */}
            <div className="mobile-nav">
                {['status','action','log'].map(tab => (
                    <button key={tab} onClick={() => setMobileTab(tab)} title={tab === 'status' ? 'æŸ¥çœ‹çŠ¶æ€ Status' : tab === 'action' ? 'æ‰§è¡Œè¡ŒåŠ¨ Action' : 'æˆ˜æ–—è®°å½• Log'} className={`flex flex-col items-center justify-center flex-1 h-full transition-all ${mobileTab === tab ? 'text-black bg-white border-t-4 border-black' : 'text-gray-400 border-t-4 border-transparent hover:bg-gray-50'}`}>
                        <span className="text-xl mb-1">{tab === 'status' ? 'ğŸ“Š' : tab === 'action' ? 'âš”ï¸' : 'ğŸ“œ'}</span>
                        <span className="text-[9px] font-black uppercase tracking-[0.15em]">{tab === 'status' ? 'STATUS' : tab === 'action' ? 'ACTION' : 'LOG'}</span>
                    </button>
                ))}
            </div>
            
            <StepDiceRoller 
                isOpen={showStepDice}
                modifier={diceModifier}
                targetNumber={stepDiceTargetNumber}
                onComplete={handleStepDiceComplete}
                onClose={() => setShowStepDice(false)}
            />
        </div>
    );
}

ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>